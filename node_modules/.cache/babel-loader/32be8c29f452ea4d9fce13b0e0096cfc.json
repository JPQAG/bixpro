{"ast":null,"code":"/* ============================================================\r\n * node-binance-api\r\n * https://github.com/jaggedsoft/node-binance-api\r\n * ============================================================\r\n * Copyright 2017-, Jon Eyrick\r\n * Released under the MIT License\r\n * ============================================================\r\n * @module jaggedsoft/node-binance-api\r\n * @return {object} instance to class object */\nlet api = function Binance(options = {}) {\n  if (!new.target) return new api(options); // Legacy support for calling the constructor without 'new'\n\n  let Binance = this; // eslint-disable-line consistent-this\n\n  const WebSocket = require('ws');\n\n  const request = require('request');\n\n  const crypto = require('crypto');\n\n  const file = require('fs');\n\n  const url = require('url');\n\n  const JSONbig = require('json-bigint');\n\n  const HttpsProxyAgent = require('https-proxy-agent');\n\n  const SocksProxyAgent = require('socks-proxy-agent');\n\n  const stringHash = require('string-hash');\n\n  const async = require('async');\n\n  let base = 'https://api.binance.com/api/';\n  let wapi = 'https://api.binance.com/wapi/';\n  let sapi = 'https://api.binance.com/sapi/';\n  let fapi = 'https://fapi.binance.com/fapi/';\n  let dapi = 'https://dapi.binance.com/dapi/';\n  let fapiTest = 'https://testnet.binancefuture.com/fapi/';\n  let dapiTest = 'https://testnet.binancefuture.com/dapi/';\n  let fstream = 'wss://fstream.binance.com/stream?streams=';\n  let fstreamSingle = 'wss://fstream.binance.com/ws/';\n  let fstreamSingleTest = 'wss://stream.binancefuture.com/ws/';\n  let fstreamTest = 'wss://stream.binancefuture.com/stream?streams=';\n  let dstream = 'wss://dstream.binance.com/stream?streams=';\n  let dstreamSingle = 'wss://dstream.binance.com/ws/';\n  let dstreamSingleTest = 'wss://dstream.binancefuture.com/ws/';\n  let dstreamTest = 'wss://dstream.binancefuture.com/stream?streams=';\n  let stream = 'wss://stream.binance.com:9443/ws/';\n  let combineStream = 'wss://stream.binance.com:9443/stream?streams=';\n  const userAgent = 'Mozilla/4.0 (compatible; Node Binance API)';\n  const contentType = 'application/x-www-form-urlencoded';\n  Binance.subscriptions = {};\n  Binance.futuresSubscriptions = {};\n  Binance.futuresInfo = {};\n  Binance.futuresMeta = {};\n  Binance.futuresTicks = {};\n  Binance.futuresRealtime = {};\n  Binance.futuresKlineQueue = {};\n  Binance.deliverySubscriptions = {};\n  Binance.deliveryInfo = {};\n  Binance.deliveryMeta = {};\n  Binance.deliveryTicks = {};\n  Binance.deliveryRealtime = {};\n  Binance.deliveryKlineQueue = {};\n  Binance.depthCache = {};\n  Binance.depthCacheContext = {};\n  Binance.ohlcLatest = {};\n  Binance.klineQueue = {};\n  Binance.ohlc = {};\n  const default_options = {\n    recvWindow: 5000,\n    useServerTime: false,\n    reconnect: true,\n    keepAlive: true,\n    verbose: false,\n    test: false,\n    hedgeMode: false,\n    localAddress: false,\n    family: false,\n    log: function (...args) {\n      console.log(Array.prototype.slice.call(args));\n    }\n  };\n  Binance.options = default_options;\n  Binance.info = {\n    usedWeight: 0,\n    futuresLatency: false,\n    lastRequest: false,\n    lastURL: false,\n    statusCode: 0,\n    orderCount1s: 0,\n    orderCount1m: 0,\n    orderCount1h: 0,\n    orderCount1d: 0,\n    timeOffset: 0\n  };\n  Binance.socketHeartbeatInterval = null;\n  if (options) setOptions(options);\n\n  function setOptions(opt = {}, callback = false) {\n    if (typeof opt === 'string') {\n      // Pass json config filename\n      Binance.options = JSON.parse(file.readFileSync(opt));\n    } else Binance.options = opt;\n\n    if (typeof Binance.options.recvWindow === 'undefined') Binance.options.recvWindow = default_options.recvWindow;\n    if (typeof Binance.options.useServerTime === 'undefined') Binance.options.useServerTime = default_options.useServerTime;\n    if (typeof Binance.options.reconnect === 'undefined') Binance.options.reconnect = default_options.reconnect;\n    if (typeof Binance.options.test === 'undefined') Binance.options.test = default_options.test;\n    if (typeof Binance.options.hedgeMode === 'undefined') Binance.options.hedgeMode = default_options.hedgeMode;\n    if (typeof Binance.options.log === 'undefined') Binance.options.log = default_options.log;\n    if (typeof Binance.options.verbose === 'undefined') Binance.options.verbose = default_options.verbose;\n    if (typeof Binance.options.keepAlive === 'undefined') Binance.options.keepAlive = default_options.keepAlive;\n    if (typeof Binance.options.localAddress === 'undefined') Binance.options.localAddress = default_options.localAddress;\n    if (typeof Binance.options.family === 'undefined') Binance.options.family = default_options.family;\n\n    if (typeof Binance.options.urls !== 'undefined') {\n      const {\n        urls\n      } = Binance.options;\n      if (typeof urls.base === 'string') base = urls.base;\n      if (typeof urls.wapi === 'string') wapi = urls.wapi;\n      if (typeof urls.sapi === 'string') sapi = urls.sapi;\n      if (typeof urls.fapi === 'string') fapi = urls.fapi;\n      if (typeof urls.fapiTest === 'string') fapiTest = urls.fapiTest;\n      if (typeof urls.stream === 'string') stream = urls.stream;\n      if (typeof urls.combineStream === 'string') combineStream = urls.combineStream;\n      if (typeof urls.fstream === 'string') fstream = urls.fstream;\n      if (typeof urls.fstreamSingle === 'string') fstreamSingle = urls.fstreamSingle;\n      if (typeof urls.fstreamTest === 'string') fstreamTest = urls.fstreamTest;\n      if (typeof urls.fstreamSingleTest === 'string') fstreamSingleTest = urls.fstreamSingleTest;\n      if (typeof urls.dstream === 'string') dstream = urls.dstream;\n      if (typeof urls.dstreamSingle === 'string') dstreamSingle = urls.dstreamSingle;\n      if (typeof urls.dstreamTest === 'string') dstreamTest = urls.dstreamTest;\n      if (typeof urls.dstreamSingleTest === 'string') dstreamSingleTest = urls.dstreamSingleTest;\n    }\n\n    if (Binance.options.useServerTime) {\n      publicRequest(base + 'v3/time', {}, function (error, response) {\n        Binance.info.timeOffset = response.serverTime - new Date().getTime(); //Binance.options.log(\"server time set: \", response.serverTime, Binance.info.timeOffset);\n\n        if (callback) callback();\n      });\n    } else if (callback) callback();\n\n    return this;\n  }\n  /**\r\n   * Replaces socks connection uri hostname with IP address\r\n   * @param {string} connString - socks connection string\r\n   * @return {string} modified string with ip address\r\n   */\n\n\n  const proxyReplacewithIp = connString => {\n    return connString;\n  };\n  /**\r\n   * Returns an array in the form of [host, port]\r\n   * @param {string} connString - connection string\r\n   * @return {array} array of host and port\r\n   */\n\n\n  const parseProxy = connString => {\n    let arr = connString.split('/');\n    let host = arr[2].split(':')[0];\n    let port = arr[2].split(':')[1];\n    return [arr[0], host, port];\n  };\n  /**\r\n   * Checks to see of the object is iterable\r\n   * @param {object} obj - The object check\r\n   * @return {boolean} true or false is iterable\r\n   */\n\n\n  const isIterable = obj => {\n    if (obj === null) return false;\n    return typeof obj[Symbol.iterator] === 'function';\n  };\n\n  const addProxy = opt => {\n    if (Binance.options.proxy) {\n      const proxyauth = Binance.options.proxy.auth ? `${Binance.options.proxy.auth.username}:${Binance.options.proxy.auth.password}@` : '';\n      opt.proxy = `http://${proxyauth}${Binance.options.proxy.host}:${Binance.options.proxy.port}`;\n    }\n\n    return opt;\n  };\n\n  const reqHandler = cb => (error, response, body) => {\n    Binance.info.lastRequest = new Date().getTime();\n\n    if (response) {\n      Binance.info.statusCode = response.statusCode || 0;\n      if (response.request) Binance.info.lastURL = response.request.uri.href;\n\n      if (response.headers) {\n        Binance.info.usedWeight = response.headers['x-mbx-used-weight-1m'] || 0;\n        Binance.info.orderCount1s = response.headers['x-mbx-order-count-1s'] || 0;\n        Binance.info.orderCount1m = response.headers['x-mbx-order-count-1m'] || 0;\n        Binance.info.orderCount1h = response.headers['x-mbx-order-count-1h'] || 0;\n        Binance.info.orderCount1d = response.headers['x-mbx-order-count-1d'] || 0;\n      }\n    }\n\n    if (!cb) return;\n    if (error) return cb(error, {});\n    if (response && response.statusCode !== 200) return cb(response, {});\n    return cb(null, JSONbig.parse(body));\n  };\n\n  const proxyRequest = (opt, cb) => {\n    const req = request(addProxy(opt), reqHandler(cb)).on('error', err => {\n      cb(err, {});\n    });\n    return req;\n  };\n\n  const reqObj = (url, data = {}, method = 'GET', key) => ({\n    url: url,\n    qs: data,\n    method: method,\n    family: Binance.options.family,\n    localAddress: Binance.options.localAddress,\n    timeout: Binance.options.recvWindow,\n    forever: Binance.options.keepAlive,\n    headers: {\n      'User-Agent': userAgent,\n      'Content-type': contentType,\n      'X-MBX-APIKEY': key || ''\n    }\n  });\n\n  const reqObjPOST = (url, data = {}, method = 'POST', key) => ({\n    url: url,\n    form: data,\n    method: method,\n    family: Binance.options.family,\n    localAddress: Binance.options.localAddress,\n    timeout: Binance.options.recvWindow,\n    forever: Binance.options.keepAlive,\n    qsStringifyOptions: {\n      arrayFormat: 'repeat'\n    },\n    headers: {\n      'User-Agent': userAgent,\n      'Content-type': contentType,\n      'X-MBX-APIKEY': key || ''\n    }\n  });\n  /**\r\n   * Create a http request to the public API\r\n   * @param {string} url - The http endpoint\r\n   * @param {object} data - The data to send\r\n   * @param {function} callback - The callback method to call\r\n   * @param {string} method - the http method\r\n   * @return {undefined}\r\n   */\n\n\n  const publicRequest = (url, data = {}, callback, method = 'GET') => {\n    let opt = reqObj(url, data, method);\n    proxyRequest(opt, callback);\n  }; // XXX: This one works with array (e.g. for dust.transfer)\n  // XXX: I _guess_ we could use replace this function with the `qs` module\n\n\n  const makeQueryString = q => Object.keys(q).reduce((a, k) => {\n    if (Array.isArray(q[k])) {\n      q[k].forEach(v => {\n        a.push(k + \"=\" + encodeURIComponent(v));\n      });\n    } else if (q[k] !== undefined) {\n      a.push(k + \"=\" + encodeURIComponent(q[k]));\n    }\n\n    return a;\n  }, []).join(\"&\");\n  /**\r\n   * Create a http request to the public API\r\n   * @param {string} url - The http endpoint\r\n   * @param {object} data - The data to send\r\n   * @param {function} callback - The callback method to call\r\n   * @param {string} method - the http method\r\n   * @return {undefined}\r\n   */\n\n\n  const apiRequest = (url, data = {}, callback, method = 'GET') => {\n    requireApiKey('apiRequest');\n    let opt = reqObj(url, data, method, Binance.options.APIKEY);\n    proxyRequest(opt, callback);\n  }; // Check if API key is empty or invalid\n\n\n  const requireApiKey = function (source = 'requireApiKey', fatalError = true) {\n    if (!Binance.options.APIKEY) {\n      if (fatalError) throw Error(`${source}: Invalid API Key!`);\n      return false;\n    }\n\n    return true;\n  }; // Check if API secret is present\n\n\n  const requireApiSecret = function (source = 'requireApiSecret', fatalError = true) {\n    if (!Binance.options.APIKEY) {\n      if (fatalError) throw Error(`${source}: Invalid API Key!`);\n      return false;\n    }\n\n    if (!Binance.options.APISECRET) {\n      if (fatalError) throw Error(`${source}: Invalid API Secret!`);\n      return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Make market request\r\n   * @param {string} url - The http endpoint\r\n   * @param {object} data - The data to send\r\n   * @param {function} callback - The callback method to call\r\n   * @param {string} method - the http method\r\n   * @return {undefined}\r\n   */\n\n\n  const marketRequest = (url, data = {}, callback, method = 'GET') => {\n    requireApiKey('marketRequest');\n    let query = makeQueryString(data);\n    let opt = reqObj(url + (query ? '?' + query : ''), data, method, Binance.options.APIKEY);\n    proxyRequest(opt, callback);\n  };\n  /**\r\n   * Create a signed http request\r\n   * @param {string} url - The http endpoint\r\n   * @param {object} data - The data to send\r\n   * @param {function} callback - The callback method to call\r\n   * @param {string} method - the http method\r\n   * @param {boolean} noDataInSignature - Prevents data from being added to signature\r\n   * @return {undefined}\r\n   */\n\n\n  const signedRequest = (url, data = {}, callback, method = 'GET', noDataInSignature = false) => {\n    requireApiSecret('signedRequest');\n    data.timestamp = new Date().getTime() + Binance.info.timeOffset;\n    if (typeof data.recvWindow === 'undefined') data.recvWindow = Binance.options.recvWindow;\n    let query = method === 'POST' && noDataInSignature ? '' : makeQueryString(data);\n    let signature = crypto.createHmac('sha256', Binance.options.APISECRET).update(query).digest('hex'); // set the HMAC hash header\n\n    if (method === 'POST') {\n      let opt = reqObjPOST(url, data, method, Binance.options.APIKEY);\n      opt.form.signature = signature;\n      proxyRequest(opt, callback);\n    } else {\n      let opt = reqObj(url + '?' + query + '&signature=' + signature, data, method, Binance.options.APIKEY);\n      proxyRequest(opt, callback);\n    }\n  };\n  /**\r\n   * Create a signed spot order\r\n   * @param {string} side - BUY or SELL\r\n   * @param {string} symbol - The symbol to buy or sell\r\n   * @param {string} quantity - The quantity to buy or sell\r\n   * @param {string} price - The price per unit to transact each unit at\r\n   * @param {object} flags - additional order settings\r\n   * @param {function} callback - the callback function\r\n   * @return {undefined}\r\n   */\n\n\n  const order = (side, symbol, quantity, price, flags = {}, callback = false) => {\n    let endpoint = flags.type === 'OCO' ? 'v3/order/oco' : 'v3/order';\n    if (Binance.options.test) endpoint += '/test';\n    let opt = {\n      symbol: symbol,\n      side: side,\n      type: 'LIMIT',\n      quantity: quantity\n    };\n    if (typeof flags.type !== 'undefined') opt.type = flags.type;\n\n    if (opt.type.includes('LIMIT')) {\n      opt.price = price;\n\n      if (opt.type !== 'LIMIT_MAKER') {\n        opt.timeInForce = 'GTC';\n      }\n    }\n\n    if (opt.type === 'OCO') {\n      opt.price = price;\n      opt.stopLimitPrice = flags.stopLimitPrice;\n      opt.stopLimitTimeInForce = 'GTC';\n      delete opt.type;\n      if (typeof flags.listClientOrderId !== 'undefined') opt.listClientOrderId = flags.listClientOrderId;\n      if (typeof flags.limitClientOrderId !== 'undefined') opt.limitClientOrderId = flags.limitClientOrderId;\n      if (typeof flags.stopClientOrderId !== 'undefined') opt.stopClientOrderId = flags.stopClientOrderId;\n    }\n\n    if (typeof flags.timeInForce !== 'undefined') opt.timeInForce = flags.timeInForce;\n    if (typeof flags.newOrderRespType !== 'undefined') opt.newOrderRespType = flags.newOrderRespType;\n    if (typeof flags.newClientOrderId !== 'undefined') opt.newClientOrderId = flags.newClientOrderId;\n    /*\r\n     * STOP_LOSS\r\n     * STOP_LOSS_LIMIT\r\n     * TAKE_PROFIT\r\n     * TAKE_PROFIT_LIMIT\r\n     * LIMIT_MAKER\r\n     */\n\n    if (typeof flags.icebergQty !== 'undefined') opt.icebergQty = flags.icebergQty;\n\n    if (typeof flags.stopPrice !== 'undefined') {\n      opt.stopPrice = flags.stopPrice;\n      if (opt.type === 'LIMIT') throw Error('stopPrice: Must set \"type\" to one of the following: STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, TAKE_PROFIT_LIMIT');\n    }\n\n    signedRequest(base + endpoint, opt, (error, response) => {\n      if (!response) {\n        if (callback) callback(error, response);else Binance.options.log('Order() error:', error);\n        return;\n      }\n\n      if (typeof response.msg !== 'undefined' && response.msg === 'Filter failure: MIN_NOTIONAL') {\n        Binance.options.log('Order quantity too small. See exchangeInfo() for minimum amounts');\n      }\n\n      if (callback) callback(error, response);else Binance.options.log(side + '(' + symbol + ',' + quantity + ',' + price + ') ', response);\n    }, 'POST');\n  };\n  /**\r\n   * Create a signed margin order\r\n   * @param {string} side - BUY or SELL\r\n   * @param {string} symbol - The symbol to buy or sell\r\n   * @param {string} quantity - The quantity to buy or sell\r\n   * @param {string} price - The price per unit to transact each unit at\r\n   * @param {object} flags - additional order settings\r\n   * @param {function} callback - the callback function\r\n   * @return {undefined}\r\n   */\n\n\n  const marginOrder = (side, symbol, quantity, price, flags = {}, callback = false) => {\n    let endpoint = 'v1/margin/order';\n    if (Binance.options.test) endpoint += '/test';\n    let opt = {\n      symbol: symbol,\n      side: side,\n      type: 'LIMIT',\n      quantity: quantity\n    };\n    if (typeof flags.type !== 'undefined') opt.type = flags.type;\n    if (typeof flags.isIsolated !== 'undefined') opt.isIsolated = flags.isIsolated;\n\n    if (opt.type.includes('LIMIT')) {\n      opt.price = price;\n\n      if (opt.type !== 'LIMIT_MAKER') {\n        opt.timeInForce = 'GTC';\n      }\n    }\n\n    if (typeof flags.timeInForce !== 'undefined') opt.timeInForce = flags.timeInForce;\n    if (typeof flags.newOrderRespType !== 'undefined') opt.newOrderRespType = flags.newOrderRespType;\n    if (typeof flags.newClientOrderId !== 'undefined') opt.newClientOrderId = flags.newClientOrderId;\n    if (typeof flags.sideEffectType !== 'undefined') opt.sideEffectType = flags.sideEffectType;\n    /*\r\n     * STOP_LOSS\r\n     * STOP_LOSS_LIMIT\r\n     * TAKE_PROFIT\r\n     * TAKE_PROFIT_LIMIT\r\n     */\n\n    if (typeof flags.icebergQty !== 'undefined') opt.icebergQty = flags.icebergQty;\n\n    if (typeof flags.stopPrice !== 'undefined') {\n      opt.stopPrice = flags.stopPrice;\n      if (opt.type === 'LIMIT') throw Error('stopPrice: Must set \"type\" to one of the following: STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, TAKE_PROFIT_LIMIT');\n    }\n\n    signedRequest(sapi + endpoint, opt, function (error, response) {\n      if (!response) {\n        if (callback) callback(error, response);else Binance.options.log('Order() error:', error);\n        return;\n      }\n\n      if (typeof response.msg !== 'undefined' && response.msg === 'Filter failure: MIN_NOTIONAL') {\n        Binance.options.log('Order quantity too small. See exchangeInfo() for minimum amounts');\n      }\n\n      if (callback) callback(error, response);else Binance.options.log(side + '(' + symbol + ',' + quantity + ',' + price + ') ', response);\n    }, 'POST');\n  }; // Futures internal functions\n\n\n  const futuresOrder = async (side, symbol, quantity, price = false, params = {}) => {\n    params.symbol = symbol;\n    params.side = side;\n    if (quantity) params.quantity = quantity; // if in the binance futures setting Hedged mode is active, positionSide parameter is mandatory\n\n    if (typeof params.positionSide === 'undefined' && Binance.options.hedgeMode) {\n      params.positionSide = side === 'BUY' ? 'LONG' : 'SHORT';\n    } // LIMIT STOP MARKET STOP_MARKET TAKE_PROFIT TAKE_PROFIT_MARKET\n    // reduceOnly stopPrice\n\n\n    if (price) {\n      params.price = price;\n      if (typeof params.type === 'undefined') params.type = 'LIMIT';\n    } else {\n      if (typeof params.type === 'undefined') params.type = 'MARKET';\n    }\n\n    if (!params.timeInForce && (params.type.includes('LIMIT') || params.type === 'STOP' || params.type === 'TAKE_PROFIT')) {\n      params.timeInForce = 'GTX'; // Post only by default. Use GTC for limit orders.\n    }\n\n    return promiseRequest('v1/order', params, {\n      base: fapi,\n      type: 'TRADE',\n      method: 'POST'\n    });\n  };\n\n  const deliveryOrder = async (side, symbol, quantity, price = false, params = {}) => {\n    params.symbol = symbol;\n    params.side = side;\n    params.quantity = quantity; // if in the binance futures setting Hedged mode is active, positionSide parameter is mandatory\n\n    if (Binance.options.hedgeMode) {\n      params.positionSide = side === 'BUY' ? 'LONG' : 'SHORT';\n    } // LIMIT STOP MARKET STOP_MARKET TAKE_PROFIT TAKE_PROFIT_MARKET\n    // reduceOnly stopPrice\n\n\n    if (price) {\n      params.price = price;\n      if (typeof params.type === 'undefined') params.type = 'LIMIT';\n    } else {\n      if (typeof params.type === 'undefined') params.type = 'MARKET';\n    }\n\n    if (!params.timeInForce && (params.type.includes('LIMIT') || params.type === 'STOP' || params.type === 'TAKE_PROFIT')) {\n      params.timeInForce = 'GTX'; // Post only by default. Use GTC for limit orders.\n    }\n\n    return promiseRequest('v1/order', params, {\n      base: dapi,\n      type: 'TRADE',\n      method: 'POST'\n    });\n  };\n\n  const promiseRequest = async (url, data = {}, flags = {}) => {\n    return new Promise((resolve, reject) => {\n      let query = '',\n          headers = {\n        'User-Agent': userAgent,\n        'Content-type': 'application/x-www-form-urlencoded'\n      };\n      if (typeof flags.method === 'undefined') flags.method = 'GET'; // GET POST PUT DELETE\n\n      if (typeof flags.type === 'undefined') flags.type = false; // TRADE, SIGNED, MARKET_DATA, USER_DATA, USER_STREAM\n      else {\n          if (typeof data.recvWindow === 'undefined') data.recvWindow = Binance.options.recvWindow;\n          requireApiKey('promiseRequest');\n          headers['X-MBX-APIKEY'] = Binance.options.APIKEY;\n        }\n      let baseURL = typeof flags.base === 'undefined' ? base : flags.base;\n      if (Binance.options.test && baseURL === fapi) baseURL = fapiTest;\n      if (Binance.options.test && baseURL === dapi) baseURL = dapiTest;\n      let opt = {\n        headers,\n        url: baseURL + url,\n        method: flags.method,\n        timeout: Binance.options.recvWindow,\n        followAllRedirects: true\n      };\n\n      if (flags.type === 'SIGNED' || flags.type === 'TRADE' || flags.type === 'USER_DATA') {\n        if (!requireApiSecret('promiseRequest')) return reject('promiseRequest: Invalid API Secret!');\n        data.timestamp = new Date().getTime() + Binance.info.timeOffset;\n        query = makeQueryString(data);\n        data.signature = crypto.createHmac('sha256', Binance.options.APISECRET).update(query).digest('hex'); // HMAC hash header\n\n        opt.url = `${baseURL}${url}?${query}&signature=${data.signature}`;\n      }\n\n      opt.qs = data;\n      /*if ( flags.method === 'POST' ) {\r\n          opt.form = data;\r\n      } else {\r\n          opt.qs = data;\r\n      }*/\n\n      try {\n        request(addProxy(opt), (error, response, body) => {\n          if (error) return reject(error);\n\n          try {\n            Binance.info.lastRequest = new Date().getTime();\n\n            if (response) {\n              Binance.info.statusCode = response.statusCode || 0;\n              if (response.request) Binance.info.lastURL = response.request.uri.href;\n\n              if (response.headers) {\n                Binance.info.usedWeight = response.headers['x-mbx-used-weight-1m'] || 0;\n                Binance.info.futuresLatency = response.headers['x-response-time'] || 0;\n              }\n            }\n\n            if (!error && response.statusCode == 200) return resolve(JSONbig.parse(body));\n\n            if (typeof response.body !== 'undefined') {\n              return resolve(JSONbig.parse(response.body));\n            }\n\n            return reject(response);\n          } catch (err) {\n            return reject(`promiseRequest error #${response.statusCode}`);\n          }\n        }).on('error', reject);\n      } catch (err) {\n        return reject(err);\n      }\n    });\n  };\n  /**\r\n   * No-operation function\r\n   * @return {undefined}\r\n   */\n\n\n  const noop = () => {}; // Do nothing.\n\n  /**\r\n   * Reworked Tuitio's heartbeat code into a shared single interval tick\r\n   * @return {undefined}\r\n   */\n\n\n  const socketHeartbeat = () => {\n    /* Sockets removed from `subscriptions` during a manual terminate()\r\n     will no longer be at risk of having functions called on them */\n    for (let endpointId in Binance.subscriptions) {\n      const ws = Binance.subscriptions[endpointId];\n\n      if (ws.isAlive) {\n        ws.isAlive = false;\n        if (ws.readyState === WebSocket.OPEN) ws.ping(noop);\n      } else {\n        if (Binance.options.verbose) Binance.options.log('Terminating inactive/broken WebSocket: ' + ws.endpoint);\n        if (ws.readyState === WebSocket.OPEN) ws.terminate();\n      }\n    }\n  };\n  /**\r\n   * Called when socket is opened, subscriptions are registered for later reference\r\n   * @param {function} opened_callback - a callback function\r\n   * @return {undefined}\r\n   */\n\n\n  const handleSocketOpen = function (opened_callback) {\n    this.isAlive = true;\n\n    if (Object.keys(Binance.subscriptions).length === 0) {\n      Binance.socketHeartbeatInterval = setInterval(socketHeartbeat, 30000);\n    }\n\n    Binance.subscriptions[this.endpoint] = this;\n    if (typeof opened_callback === 'function') opened_callback(this.endpoint);\n  };\n  /**\r\n   * Called when socket is closed, subscriptions are de-registered for later reference\r\n   * @param {boolean} reconnect - true or false to reconnect the socket\r\n   * @param {string} code - code associated with the socket\r\n   * @param {string} reason - string with the response\r\n   * @return {undefined}\r\n   */\n\n\n  const handleSocketClose = function (reconnect, code, reason) {\n    delete Binance.subscriptions[this.endpoint];\n\n    if (Binance.subscriptions && Object.keys(Binance.subscriptions).length === 0) {\n      clearInterval(Binance.socketHeartbeatInterval);\n    }\n\n    Binance.options.log('WebSocket closed: ' + this.endpoint + (code ? ' (' + code + ')' : '') + (reason ? ' ' + reason : ''));\n\n    if (Binance.options.reconnect && this.reconnect && reconnect) {\n      if (this.endpoint && parseInt(this.endpoint.length, 10) === 60) Binance.options.log('Account data WebSocket reconnecting...');else Binance.options.log('WebSocket reconnecting: ' + this.endpoint + '...');\n\n      try {\n        reconnect();\n      } catch (error) {\n        Binance.options.log('WebSocket reconnect error: ' + error.message);\n      }\n    }\n  };\n  /**\r\n   * Called when socket errors\r\n   * @param {object} error - error object message\r\n   * @return {undefined}\r\n   */\n\n\n  const handleSocketError = function (error) {\n    /* Errors ultimately result in a `close` event.\r\n     see: https://github.com/websockets/ws/blob/828194044bf247af852b31c49e2800d557fedeff/lib/websocket.js#L126 */\n    Binance.options.log('WebSocket error: ' + this.endpoint + (error.code ? ' (' + error.code + ')' : '') + (error.message ? ' ' + error.message : ''));\n  };\n  /**\r\n   * Called on each socket heartbeat\r\n   * @return {undefined}\r\n   */\n\n\n  const handleSocketHeartbeat = function () {\n    this.isAlive = true;\n  };\n  /**\r\n   * Used to subscribe to a single websocket endpoint\r\n   * @param {string} endpoint - endpoint to connect to\r\n   * @param {function} callback - the function to call when information is received\r\n   * @param {boolean} reconnect - whether to reconnect on disconnect\r\n   * @param {object} opened_callback - the function to call when opened\r\n   * @return {WebSocket} - websocket reference\r\n   */\n\n\n  const subscribe = function (endpoint, callback, reconnect = false, opened_callback = false) {\n    let httpsproxy = process.env.https_proxy || false;\n    let socksproxy = process.env.socks_proxy || false;\n    let ws = false;\n\n    if (socksproxy !== false) {\n      socksproxy = proxyReplacewithIp(socksproxy);\n      if (Binance.options.verbose) Binance.options.log('using socks proxy server ' + socksproxy);\n      let agent = new SocksProxyAgent({\n        protocol: parseProxy(socksproxy)[0],\n        host: parseProxy(socksproxy)[1],\n        port: parseProxy(socksproxy)[2]\n      });\n      ws = new WebSocket(stream + endpoint, {\n        agent: agent\n      });\n    } else if (httpsproxy !== false) {\n      let config = url.parse(httpsproxy);\n      let agent = new HttpsProxyAgent(config);\n      if (Binance.options.verbose) Binance.options.log('using proxy server ' + agent);\n      ws = new WebSocket(stream + endpoint, {\n        agent: agent\n      });\n    } else {\n      ws = new WebSocket(stream + endpoint);\n    }\n\n    if (Binance.options.verbose) Binance.options.log('Subscribed to ' + endpoint);\n    ws.reconnect = Binance.options.reconnect;\n    ws.endpoint = endpoint;\n    ws.isAlive = false;\n    ws.on('open', handleSocketOpen.bind(ws, opened_callback));\n    ws.on('pong', handleSocketHeartbeat);\n    ws.on('error', handleSocketError);\n    ws.on('close', handleSocketClose.bind(ws, reconnect));\n    ws.on('message', data => {\n      try {\n        callback(JSON.parse(data));\n      } catch (error) {\n        Binance.options.log('Parse error: ' + error.message);\n      }\n    });\n    return ws;\n  };\n  /**\r\n   * Used to subscribe to a combined websocket endpoint\r\n   * @param {string} streams - streams to connect to\r\n   * @param {function} callback - the function to call when information is received\r\n   * @param {boolean} reconnect - whether to reconnect on disconnect\r\n   * @param {object} opened_callback - the function to call when opened\r\n   * @return {WebSocket} - websocket reference\r\n   */\n\n\n  const subscribeCombined = function (streams, callback, reconnect = false, opened_callback = false) {\n    let httpsproxy = process.env.https_proxy || false;\n    let socksproxy = process.env.socks_proxy || false;\n    const queryParams = streams.join('/');\n    let ws = false;\n\n    if (socksproxy !== false) {\n      socksproxy = proxyReplacewithIp(socksproxy);\n      if (Binance.options.verbose) Binance.options.log('using socks proxy server ' + socksproxy);\n      let agent = new SocksProxyAgent({\n        protocol: parseProxy(socksproxy)[0],\n        host: parseProxy(socksproxy)[1],\n        port: parseProxy(socksproxy)[2]\n      });\n      ws = new WebSocket(combineStream + queryParams, {\n        agent: agent\n      });\n    } else if (httpsproxy !== false) {\n      if (Binance.options.verbose) Binance.options.log('using proxy server ' + httpsproxy);\n      let config = url.parse(httpsproxy);\n      let agent = new HttpsProxyAgent(config);\n      ws = new WebSocket(combineStream + queryParams, {\n        agent: agent\n      });\n    } else {\n      ws = new WebSocket(combineStream + queryParams);\n    }\n\n    ws.reconnect = Binance.options.reconnect;\n    ws.endpoint = stringHash(queryParams);\n    ws.isAlive = false;\n\n    if (Binance.options.verbose) {\n      Binance.options.log('CombinedStream: Subscribed to [' + ws.endpoint + '] ' + queryParams);\n    }\n\n    ws.on('open', handleSocketOpen.bind(ws, opened_callback));\n    ws.on('pong', handleSocketHeartbeat);\n    ws.on('error', handleSocketError);\n    ws.on('close', handleSocketClose.bind(ws, reconnect));\n    ws.on('message', data => {\n      try {\n        callback(JSON.parse(data).data);\n      } catch (error) {\n        Binance.options.log('CombinedStream: Parse error: ' + error.message);\n      }\n    });\n    return ws;\n  };\n  /**\r\n   * Used to terminate a web socket\r\n   * @param {string} endpoint - endpoint identifier associated with the web socket\r\n   * @param {boolean} reconnect - auto reconnect after termination\r\n   * @return {undefined}\r\n   */\n\n\n  const terminate = function (endpoint, reconnect = false) {\n    let ws = Binance.subscriptions[endpoint];\n    if (!ws) return;\n    ws.removeAllListeners('message');\n    ws.reconnect = reconnect;\n    ws.terminate();\n  };\n  /**\r\n   * Futures heartbeat code with a shared single interval tick\r\n   * @return {undefined}\r\n   */\n\n\n  const futuresSocketHeartbeat = () => {\n    /* Sockets removed from subscriptions during a manual terminate()\r\n     will no longer be at risk of having functions called on them */\n    for (let endpointId in Binance.futuresSubscriptions) {\n      const ws = Binance.futuresSubscriptions[endpointId];\n\n      if (ws.isAlive) {\n        ws.isAlive = false;\n        if (ws.readyState === WebSocket.OPEN) ws.ping(noop);\n      } else {\n        if (Binance.options.verbose) Binance.options.log(`Terminating zombie futures WebSocket: ${ws.endpoint}`);\n        if (ws.readyState === WebSocket.OPEN) ws.terminate();\n      }\n    }\n  };\n  /**\r\n   * Called when a futures socket is opened, subscriptions are registered for later reference\r\n   * @param {function} openCallback - a callback function\r\n   * @return {undefined}\r\n   */\n\n\n  const handleFuturesSocketOpen = function (openCallback) {\n    this.isAlive = true;\n\n    if (Object.keys(Binance.futuresSubscriptions).length === 0) {\n      Binance.socketHeartbeatInterval = setInterval(futuresSocketHeartbeat, 30000);\n    }\n\n    Binance.futuresSubscriptions[this.endpoint] = this;\n    if (typeof openCallback === 'function') openCallback(this.endpoint);\n  };\n  /**\r\n   * Called when futures websocket is closed, subscriptions are de-registered for later reference\r\n   * @param {boolean} reconnect - true or false to reconnect the socket\r\n   * @param {string} code - code associated with the socket\r\n   * @param {string} reason - string with the response\r\n   * @return {undefined}\r\n   */\n\n\n  const handleFuturesSocketClose = function (reconnect, code, reason) {\n    delete Binance.futuresSubscriptions[this.endpoint];\n\n    if (Binance.futuresSubscriptions && Object.keys(Binance.futuresSubscriptions).length === 0) {\n      clearInterval(Binance.socketHeartbeatInterval);\n    }\n\n    Binance.options.log('Futures WebSocket closed: ' + this.endpoint + (code ? ' (' + code + ')' : '') + (reason ? ' ' + reason : ''));\n\n    if (Binance.options.reconnect && this.reconnect && reconnect) {\n      if (this.endpoint && parseInt(this.endpoint.length, 10) === 60) Binance.options.log('Futures account data WebSocket reconnecting...');else Binance.options.log('Futures WebSocket reconnecting: ' + this.endpoint + '...');\n\n      try {\n        reconnect();\n      } catch (error) {\n        Binance.options.log('Futures WebSocket reconnect error: ' + error.message);\n      }\n    }\n  };\n  /**\r\n   * Called when a futures websocket errors\r\n   * @param {object} error - error object message\r\n   * @return {undefined}\r\n   */\n\n\n  const handleFuturesSocketError = function (error) {\n    Binance.options.log('Futures WebSocket error: ' + this.endpoint + (error.code ? ' (' + error.code + ')' : '') + (error.message ? ' ' + error.message : ''));\n  };\n  /**\r\n   * Called on each futures socket heartbeat\r\n   * @return {undefined}\r\n   */\n\n\n  const handleFuturesSocketHeartbeat = function () {\n    this.isAlive = true;\n  };\n  /**\r\n   * Used to subscribe to a single futures websocket endpoint\r\n   * @param {string} endpoint - endpoint to connect to\r\n   * @param {function} callback - the function to call when information is received\r\n   * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}\r\n   * @return {WebSocket} - websocket reference\r\n   */\n\n\n  const futuresSubscribeSingle = function (endpoint, callback, params = {}) {\n    if (typeof params === 'boolean') params = {\n      reconnect: params\n    };\n    if (!params.reconnect) params.reconnect = false;\n    if (!params.openCallback) params.openCallback = false;\n    if (!params.id) params.id = false;\n    let httpsproxy = process.env.https_proxy || false;\n    let socksproxy = process.env.socks_proxy || false;\n    let ws = false;\n\n    if (socksproxy !== false) {\n      socksproxy = proxyReplacewithIp(socksproxy);\n      if (Binance.options.verbose) Binance.options.log(`futuresSubscribeSingle: using socks proxy server: ${socksproxy}`);\n      let agent = new SocksProxyAgent({\n        protocol: parseProxy(socksproxy)[0],\n        host: parseProxy(socksproxy)[1],\n        port: parseProxy(socksproxy)[2]\n      });\n      ws = new WebSocket((Binance.options.test ? fstreamSingleTest : fstreamSingle) + endpoint, {\n        agent\n      });\n    } else if (httpsproxy !== false) {\n      if (Binance.options.verbose) Binance.options.log(`futuresSubscribeSingle: using proxy server: ${agent}`);\n      let config = url.parse(httpsproxy);\n      let agent = new HttpsProxyAgent(config);\n      ws = new WebSocket((Binance.options.test ? fstreamSingleTest : fstreamSingle) + endpoint, {\n        agent\n      });\n    } else {\n      ws = new WebSocket((Binance.options.test ? fstreamSingleTest : fstreamSingle) + endpoint);\n    }\n\n    if (Binance.options.verbose) Binance.options.log('futuresSubscribeSingle: Subscribed to ' + endpoint);\n    ws.reconnect = Binance.options.reconnect;\n    ws.endpoint = endpoint;\n    ws.isAlive = false;\n    ws.on('open', handleFuturesSocketOpen.bind(ws, params.openCallback));\n    ws.on('pong', handleFuturesSocketHeartbeat);\n    ws.on('error', handleFuturesSocketError);\n    ws.on('close', handleFuturesSocketClose.bind(ws, params.reconnect));\n    ws.on('message', data => {\n      try {\n        callback(JSON.parse(data));\n      } catch (error) {\n        Binance.options.log('Parse error: ' + error.message);\n      }\n    });\n    return ws;\n  };\n  /**\r\n   * Used to subscribe to a combined futures websocket endpoint\r\n   * @param {string} streams - streams to connect to\r\n   * @param {function} callback - the function to call when information is received\r\n   * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}\r\n   * @return {WebSocket} - websocket reference\r\n   */\n\n\n  const futuresSubscribe = function (streams, callback, params = {}) {\n    if (typeof streams === 'string') return futuresSubscribeSingle(streams, callback, params);\n    if (typeof params === 'boolean') params = {\n      reconnect: params\n    };\n    if (!params.reconnect) params.reconnect = false;\n    if (!params.openCallback) params.openCallback = false;\n    if (!params.id) params.id = false;\n    let httpsproxy = process.env.https_proxy || false;\n    let socksproxy = process.env.socks_proxy || false;\n    const queryParams = streams.join('/');\n    let ws = false;\n\n    if (socksproxy !== false) {\n      socksproxy = proxyReplacewithIp(socksproxy);\n      if (Binance.options.verbose) Binance.options.log(`futuresSubscribe: using socks proxy server ${socksproxy}`);\n      let agent = new SocksProxyAgent({\n        protocol: parseProxy(socksproxy)[0],\n        host: parseProxy(socksproxy)[1],\n        port: parseProxy(socksproxy)[2]\n      });\n      ws = new WebSocket((Binance.options.test ? fstreamTest : fstream) + queryParams, {\n        agent\n      });\n    } else if (httpsproxy !== false) {\n      if (Binance.options.verbose) Binance.options.log(`futuresSubscribe: using proxy server ${httpsproxy}`);\n      let config = url.parse(httpsproxy);\n      let agent = new HttpsProxyAgent(config);\n      ws = new WebSocket((Binance.options.test ? fstreamTest : fstream) + queryParams, {\n        agent\n      });\n    } else {\n      ws = new WebSocket((Binance.options.test ? fstreamTest : fstream) + queryParams);\n    }\n\n    ws.reconnect = Binance.options.reconnect;\n    ws.endpoint = stringHash(queryParams);\n    ws.isAlive = false;\n\n    if (Binance.options.verbose) {\n      Binance.options.log(`futuresSubscribe: Subscribed to [${ws.endpoint}] ${queryParams}`);\n    }\n\n    ws.on('open', handleFuturesSocketOpen.bind(ws, params.openCallback));\n    ws.on('pong', handleFuturesSocketHeartbeat);\n    ws.on('error', handleFuturesSocketError);\n    ws.on('close', handleFuturesSocketClose.bind(ws, params.reconnect));\n    ws.on('message', data => {\n      try {\n        callback(JSON.parse(data).data);\n      } catch (error) {\n        Binance.options.log(`futuresSubscribe: Parse error: ${error.message}`);\n      }\n    });\n    return ws;\n  };\n  /**\r\n   * Used to terminate a futures websocket\r\n   * @param {string} endpoint - endpoint identifier associated with the web socket\r\n   * @param {boolean} reconnect - auto reconnect after termination\r\n   * @return {undefined}\r\n   */\n\n\n  const futuresTerminate = function (endpoint, reconnect = false) {\n    let ws = Binance.futuresSubscriptions[endpoint];\n    if (!ws) return;\n    ws.removeAllListeners('message');\n    ws.reconnect = reconnect;\n    ws.terminate();\n  };\n  /**\r\n   * Combines all futures OHLC data with the latest update\r\n   * @param {string} symbol - the symbol\r\n   * @param {string} interval - time interval\r\n   * @return {array} - interval data for given symbol\r\n   */\n\n\n  const futuresKlineConcat = (symbol, interval) => {\n    let output = Binance.futuresTicks[symbol][interval];\n    if (typeof Binance.futuresRealtime[symbol][interval].time === 'undefined') return output;\n    const time = Binance.futuresRealtime[symbol][interval].time;\n    const last_updated = Object.keys(Binance.futuresTicks[symbol][interval]).pop();\n\n    if (time >= last_updated) {\n      output[time] = Binance.futuresRealtime[symbol][interval]; //delete output[time].time;\n\n      output[last_updated].isFinal = true;\n      output[time].isFinal = false;\n    }\n\n    return output;\n  };\n  /**\r\n   * Used for websocket futures @kline\r\n   * @param {string} symbol - the symbol\r\n   * @param {object} kline - object with kline info\r\n   * @param {string} firstTime - time filter\r\n   * @return {undefined}\r\n   */\n\n\n  const futuresKlineHandler = (symbol, kline, firstTime = 0) => {\n    // eslint-disable-next-line no-unused-vars\n    let {\n      e: eventType,\n      E: eventTime,\n      k: ticks\n    } = kline; // eslint-disable-next-line no-unused-vars\n\n    let {\n      o: open,\n      h: high,\n      l: low,\n      c: close,\n      v: volume,\n      i: interval,\n      x: isFinal,\n      q: quoteVolume,\n      V: takerBuyBaseVolume,\n      Q: takerBuyQuoteVolume,\n      n: trades,\n      t: time,\n      T: closeTime\n    } = ticks;\n    if (time <= firstTime) return;\n\n    if (!isFinal) {\n      // if ( typeof Binance.futuresRealtime[symbol][interval].time !== 'undefined' ) {\n      //     if ( Binance.futuresRealtime[symbol][interval].time > time ) return;\n      // }\n      Binance.futuresRealtime[symbol][interval] = {\n        time,\n        closeTime,\n        open,\n        high,\n        low,\n        close,\n        volume,\n        quoteVolume,\n        takerBuyBaseVolume,\n        takerBuyQuoteVolume,\n        trades,\n        isFinal\n      };\n      return;\n    }\n\n    const first_updated = Object.keys(Binance.futuresTicks[symbol][interval]).shift();\n    if (first_updated) delete Binance.futuresTicks[symbol][interval][first_updated];\n    Binance.futuresTicks[symbol][interval][time] = {\n      time,\n      closeTime,\n      open,\n      high,\n      low,\n      close,\n      volume,\n      quoteVolume,\n      takerBuyBaseVolume,\n      takerBuyQuoteVolume,\n      trades,\n      isFinal: false\n    };\n  };\n  /**\r\n   * Converts the futures liquidation stream data into a friendly object\r\n   * @param {object} data - liquidation data callback data type\r\n   * @return {object} - user friendly data type\r\n   */\n\n\n  const fLiquidationConvertData = data => {\n    let eventType = data.e,\n        eventTime = data.E;\n    let {\n      s: symbol,\n      S: side,\n      o: orderType,\n      f: timeInForce,\n      q: origAmount,\n      p: price,\n      ap: avgPrice,\n      X: orderStatus,\n      l: lastFilledQty,\n      z: totalFilledQty,\n      T: tradeTime\n    } = data.o;\n    return {\n      symbol,\n      side,\n      orderType,\n      timeInForce,\n      origAmount,\n      price,\n      avgPrice,\n      orderStatus,\n      lastFilledQty,\n      totalFilledQty,\n      eventType,\n      tradeTime,\n      eventTime\n    };\n  };\n  /**\r\n   * Converts the futures ticker stream data into a friendly object\r\n   * @param {object} data - user data callback data type\r\n   * @return {object} - user friendly data type\r\n   */\n\n\n  const fTickerConvertData = data => {\n    let friendlyData = data => {\n      let {\n        e: eventType,\n        E: eventTime,\n        s: symbol,\n        p: priceChange,\n        P: percentChange,\n        w: averagePrice,\n        c: close,\n        Q: closeQty,\n        o: open,\n        h: high,\n        l: low,\n        v: volume,\n        q: quoteVolume,\n        O: openTime,\n        C: closeTime,\n        F: firstTradeId,\n        L: lastTradeId,\n        n: numTrades\n      } = data;\n      return {\n        eventType,\n        eventTime,\n        symbol,\n        priceChange,\n        percentChange,\n        averagePrice,\n        close,\n        closeQty,\n        open,\n        high,\n        low,\n        volume,\n        quoteVolume,\n        openTime,\n        closeTime,\n        firstTradeId,\n        lastTradeId,\n        numTrades\n      };\n    };\n\n    if (Array.isArray(data)) {\n      const result = [];\n\n      for (let obj of data) {\n        result.push(friendlyData(obj));\n      }\n\n      return result;\n    }\n\n    return friendlyData(data);\n  };\n  /**\r\n   * Converts the futures miniTicker stream data into a friendly object\r\n   * @param {object} data - user data callback data type\r\n   * @return {object} - user friendly data type\r\n   */\n\n\n  const fMiniTickerConvertData = data => {\n    let friendlyData = data => {\n      let {\n        e: eventType,\n        E: eventTime,\n        s: symbol,\n        c: close,\n        o: open,\n        h: high,\n        l: low,\n        v: volume,\n        q: quoteVolume\n      } = data;\n      return {\n        eventType,\n        eventTime,\n        symbol,\n        close,\n        open,\n        high,\n        low,\n        volume,\n        quoteVolume\n      };\n    };\n\n    if (Array.isArray(data)) {\n      const result = [];\n\n      for (let obj of data) {\n        result.push(friendlyData(obj));\n      }\n\n      return result;\n    }\n\n    return friendlyData(data);\n  };\n  /**\r\n   * Converts the futures bookTicker stream data into a friendly object\r\n   * @param {object} data - user data callback data type\r\n   * @return {object} - user friendly data type\r\n   */\n\n\n  const fBookTickerConvertData = data => {\n    let {\n      u: updateId,\n      s: symbol,\n      b: bestBid,\n      B: bestBidQty,\n      a: bestAsk,\n      A: bestAskQty\n    } = data;\n    return {\n      updateId,\n      symbol,\n      bestBid,\n      bestBidQty,\n      bestAsk,\n      bestAskQty\n    };\n  };\n  /**\r\n   * Converts the futures UserData stream MARGIN_CALL data into a friendly object\r\n   * @param {object} data - user data callback data type\r\n   * @return {object} - user friendly data type\r\n   */\n\n\n  const fUserDataMarginConvertData = data => {\n    let {\n      e: eventType,\n      E: eventTime,\n      cw: crossWalletBalance,\n      // only pushed with crossed position margin call\n      p: positions\n    } = data;\n\n    let positionConverter = position => {\n      let {\n        s: symbol,\n        ps: positionSide,\n        pa: positionAmount,\n        mt: marginType,\n        iw: isolatedWallet,\n        // if isolated position\n        mp: markPrice,\n        up: unrealizedPnL,\n        mm: maintenanceMargin // maintenance margin required\n\n      } = position;\n      return {\n        symbol,\n        positionSide,\n        positionAmount,\n        marginType,\n        isolatedWallet,\n        markPrice,\n        unrealizedPnL,\n        maintenanceMargin\n      };\n    };\n\n    const convertedPositions = [];\n\n    for (let position of positions) {\n      convertedPositions.push(positionConverter(position));\n    }\n\n    positions = convertedPositions;\n    return {\n      eventType,\n      eventTime,\n      crossWalletBalance,\n      positions\n    };\n  };\n  /**\r\n   * Converts the futures UserData stream ACCOUNT_CONFIG_UPDATE into a friendly object\r\n   * @param {object} data - user config callback data type\r\n   * @return {object} - user friendly data type\r\n   */\n\n\n  const fUserConfigDataAccountUpdateConvertData = data => {\n    return {\n      eventType: data.e,\n      eventTime: data.E,\n      transactionTime: data.T,\n      ac: {\n        symbol: data.ac.s,\n        leverage: data.ac.l\n      }\n    };\n  };\n  /**\r\n   * Converts the futures UserData stream ACCOUNT_UPDATE data into a friendly object\r\n   * @param {object} data - user data callback data type\r\n   * @return {object} - user friendly data type\r\n   */\n\n\n  const fUserDataAccountUpdateConvertData = data => {\n    let {\n      e: eventType,\n      E: eventTime,\n      T: transaction,\n      a: updateData\n    } = data;\n\n    let updateConverter = updateData => {\n      let {\n        m: eventReasonType,\n        B: balances,\n        P: positions\n      } = updateData;\n\n      let positionConverter = position => {\n        let {\n          s: symbol,\n          pa: positionAmount,\n          ep: entryPrice,\n          cr: accumulatedRealized,\n          // (Pre-fee) Accumulated Realized\n          up: unrealizedPnL,\n          mt: marginType,\n          iw: isolatedWallet,\n          // if isolated position\n          ps: positionSide\n        } = position;\n        return {\n          symbol,\n          positionAmount,\n          entryPrice,\n          accumulatedRealized,\n          unrealizedPnL,\n          marginType,\n          isolatedWallet,\n          positionSide\n        };\n      };\n\n      let balanceConverter = balance => {\n        let {\n          a: asset,\n          wb: walletBalance,\n          cw: crossWalletBalance\n        } = balance;\n        return {\n          asset,\n          walletBalance,\n          crossWalletBalance\n        };\n      };\n\n      const balanceResult = [];\n      const positionResult = [];\n\n      for (let balance of balances) {\n        balanceResult.push(balanceConverter(balance));\n      }\n\n      for (let position of positions) {\n        positionResult.push(positionConverter(position));\n      }\n\n      balances = balanceResult;\n      positions = positionResult;\n      return {\n        eventReasonType,\n        balances,\n        positions\n      };\n    };\n\n    updateData = updateConverter(updateData);\n    return {\n      eventType,\n      eventTime,\n      transaction,\n      updateData\n    };\n  };\n  /**\r\n   * Converts the futures UserData stream ORDER_TRADE_UPDATE data into a friendly object\r\n   * @param {object} data - user data callback data type\r\n   * @return {object} - user friendly data type\r\n   */\n\n\n  const fUserDataOrderUpdateConvertData = data => {\n    let {\n      e: eventType,\n      E: eventTime,\n      T: transaction,\n      // transaction time\n      o: order\n    } = data;\n\n    let orderConverter = order => {\n      let {\n        s: symbol,\n        c: clientOrderId,\n        // special client order id:\n        // starts with \"autoclose-\": liquidation order\n        // \"adl_autoclose\": ADL auto close order\n        S: side,\n        o: orderType,\n        f: timeInForce,\n        q: originalQuantity,\n        p: originalPrice,\n        ap: averagePrice,\n        sp: stopPrice,\n        // please ignore with TRAILING_STOP_MARKET order,\n        x: executionType,\n        X: orderStatus,\n        i: orderId,\n        l: orderLastFilledQuantity,\n        z: orderFilledAccumulatedQuantity,\n        L: lastFilledPrice,\n        N: commissionAsset,\n        // will not push if no commission\n        n: commission,\n        // will not push if no commission\n        T: orderTradeTime,\n        t: tradeId,\n        b: bidsNotional,\n        a: askNotional,\n        m: isMakerSide,\n        // is this trade maker side\n        R: isReduceOnly,\n        // is this reduce only\n        wt: stopPriceWorkingType,\n        ot: originalOrderType,\n        ps: positionSide,\n        cp: closeAll,\n        // if close-all, pushed with conditional order\n        AP: activationPrice,\n        // only pushed with TRAILING_STOP_MARKET order\n        cr: callbackRate,\n        // only pushed with TRAILING_STOP_MARKET order\n        rp: realizedProfit\n      } = order;\n      return {\n        symbol,\n        clientOrderId,\n        side,\n        orderType,\n        timeInForce,\n        originalQuantity,\n        originalPrice,\n        averagePrice,\n        stopPrice,\n        executionType,\n        orderStatus,\n        orderId,\n        orderLastFilledQuantity,\n        orderFilledAccumulatedQuantity,\n        lastFilledPrice,\n        commissionAsset,\n        commission,\n        orderTradeTime,\n        tradeId,\n        bidsNotional,\n        askNotional,\n        isMakerSide,\n        isReduceOnly,\n        stopPriceWorkingType,\n        originalOrderType,\n        positionSide,\n        closeAll,\n        activationPrice,\n        callbackRate,\n        realizedProfit\n      };\n    };\n\n    order = orderConverter(order);\n    return {\n      eventType,\n      eventTime,\n      transaction,\n      order\n    };\n  };\n  /**\r\n   * Converts the futures markPrice stream data into a friendly object\r\n   * @param {object} data - user data callback data type\r\n   * @return {object} - user friendly data type\r\n   */\n\n\n  const fMarkPriceConvertData = data => {\n    let friendlyData = data => {\n      let {\n        e: eventType,\n        E: eventTime,\n        s: symbol,\n        p: markPrice,\n        i: indexPrice,\n        r: fundingRate,\n        T: fundingTime\n      } = data;\n      return {\n        eventType,\n        eventTime,\n        symbol,\n        markPrice,\n        indexPrice,\n        fundingRate,\n        fundingTime\n      };\n    };\n\n    if (Array.isArray(data)) {\n      const result = [];\n\n      for (let obj of data) {\n        result.push(friendlyData(obj));\n      }\n\n      return result;\n    }\n\n    return friendlyData(data);\n  };\n  /**\r\n   * Converts the futures aggTrade stream data into a friendly object\r\n   * @param {object} data - user data callback data type\r\n   * @return {object} - user friendly data type\r\n   */\n\n\n  const fAggTradeConvertData = data => {\n    let friendlyData = data => {\n      let {\n        e: eventType,\n        E: eventTime,\n        s: symbol,\n        a: aggTradeId,\n        p: price,\n        q: amount,\n        f: firstTradeId,\n        l: lastTradeId,\n        T: timestamp,\n        m: maker\n      } = data;\n      return {\n        eventType,\n        eventTime,\n        symbol,\n        aggTradeId,\n        price,\n        amount,\n        total: price * amount,\n        firstTradeId,\n        lastTradeId,\n        timestamp,\n        maker\n      };\n    };\n\n    if (Array.isArray(data)) {\n      const result = [];\n\n      for (let obj of data) {\n        result.push(friendlyData(obj));\n      }\n\n      return result;\n    }\n\n    return friendlyData(data);\n  };\n  /**\r\n   * Delivery heartbeat code with a shared single interval tick\r\n   * @return {undefined}\r\n   */\n\n\n  const deliverySocketHeartbeat = () => {\n    /* Sockets removed from subscriptions during a manual terminate()\r\n     will no longer be at risk of having functions called on them */\n    for (let endpointId in Binance.deliverySubscriptions) {\n      const ws = Binance.deliverySubscriptions[endpointId];\n\n      if (ws.isAlive) {\n        ws.isAlive = false;\n        if (ws.readyState === WebSocket.OPEN) ws.ping(noop);\n      } else {\n        if (Binance.options.verbose) Binance.options.log(`Terminating zombie delivery WebSocket: ${ws.endpoint}`);\n        if (ws.readyState === WebSocket.OPEN) ws.terminate();\n      }\n    }\n  };\n  /**\r\n   * Called when a delivery socket is opened, subscriptions are registered for later reference\r\n   * @param {function} openCallback - a callback function\r\n   * @return {undefined}\r\n   */\n\n\n  const handleDeliverySocketOpen = function (openCallback) {\n    this.isAlive = true;\n\n    if (Object.keys(Binance.deliverySubscriptions).length === 0) {\n      Binance.socketHeartbeatInterval = setInterval(deliverySocketHeartbeat, 30000);\n    }\n\n    Binance.deliverySubscriptions[this.endpoint] = this;\n    if (typeof openCallback === 'function') openCallback(this.endpoint);\n  };\n  /**\r\n   * Called when delivery websocket is closed, subscriptions are de-registered for later reference\r\n   * @param {boolean} reconnect - true or false to reconnect the socket\r\n   * @param {string} code - code associated with the socket\r\n   * @param {string} reason - string with the response\r\n   * @return {undefined}\r\n   */\n\n\n  const handleDeliverySocketClose = function (reconnect, code, reason) {\n    delete Binance.deliverySubscriptions[this.endpoint];\n\n    if (Binance.deliverySubscriptions && Object.keys(Binance.deliverySubscriptions).length === 0) {\n      clearInterval(Binance.socketHeartbeatInterval);\n    }\n\n    Binance.options.log('Delivery WebSocket closed: ' + this.endpoint + (code ? ' (' + code + ')' : '') + (reason ? ' ' + reason : ''));\n\n    if (Binance.options.reconnect && this.reconnect && reconnect) {\n      if (this.endpoint && parseInt(this.endpoint.length, 10) === 60) Binance.options.log('Delivery account data WebSocket reconnecting...');else Binance.options.log('Delivery WebSocket reconnecting: ' + this.endpoint + '...');\n\n      try {\n        reconnect();\n      } catch (error) {\n        Binance.options.log('Delivery WebSocket reconnect error: ' + error.message);\n      }\n    }\n  };\n  /**\r\n   * Called when a delivery websocket errors\r\n   * @param {object} error - error object message\r\n   * @return {undefined}\r\n   */\n\n\n  const handleDeliverySocketError = function (error) {\n    Binance.options.log('Delivery WebSocket error: ' + this.endpoint + (error.code ? ' (' + error.code + ')' : '') + (error.message ? ' ' + error.message : ''));\n  };\n  /**\r\n   * Called on each delivery socket heartbeat\r\n   * @return {undefined}\r\n   */\n\n\n  const handleDeliverySocketHeartbeat = function () {\n    this.isAlive = true;\n  };\n  /**\r\n   * Used to subscribe to a single delivery websocket endpoint\r\n   * @param {string} endpoint - endpoint to connect to\r\n   * @param {function} callback - the function to call when information is received\r\n   * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}\r\n   * @return {WebSocket} - websocket reference\r\n   */\n\n\n  const deliverySubscribeSingle = function (endpoint, callback, params = {}) {\n    if (typeof params === 'boolean') params = {\n      reconnect: params\n    };\n    if (!params.reconnect) params.reconnect = false;\n    if (!params.openCallback) params.openCallback = false;\n    if (!params.id) params.id = false;\n    let httpsproxy = process.env.https_proxy || false;\n    let socksproxy = process.env.socks_proxy || false;\n    let ws = false;\n\n    if (socksproxy !== false) {\n      socksproxy = proxyReplacewithIp(socksproxy);\n      if (Binance.options.verbose) Binance.options.log(`deliverySubscribeSingle: using socks proxy server: ${socksproxy}`);\n      let agent = new SocksProxyAgent({\n        protocol: parseProxy(socksproxy)[0],\n        host: parseProxy(socksproxy)[1],\n        port: parseProxy(socksproxy)[2]\n      });\n      ws = new WebSocket((Binance.options.test ? dstreamSingleTest : dstreamSingle) + endpoint, {\n        agent\n      });\n    } else if (httpsproxy !== false) {\n      if (Binance.options.verbose) Binance.options.log(`deliverySubscribeSingle: using proxy server: ${agent}`);\n      let config = url.parse(httpsproxy);\n      let agent = new HttpsProxyAgent(config);\n      ws = new WebSocket((Binance.options.test ? dstreamSingleTest : dstreamSingle) + endpoint, {\n        agent\n      });\n    } else {\n      ws = new WebSocket((Binance.options.test ? dstreamSingleTest : dstreamSingle) + endpoint);\n    }\n\n    if (Binance.options.verbose) Binance.options.log('deliverySubscribeSingle: Subscribed to ' + endpoint);\n    ws.reconnect = Binance.options.reconnect;\n    ws.endpoint = endpoint;\n    ws.isAlive = false;\n    ws.on('open', handleDeliverySocketOpen.bind(ws, params.openCallback));\n    ws.on('pong', handleDeliverySocketHeartbeat);\n    ws.on('error', handleDeliverySocketError);\n    ws.on('close', handleDeliverySocketClose.bind(ws, params.reconnect));\n    ws.on('message', data => {\n      try {\n        callback(JSON.parse(data));\n      } catch (error) {\n        Binance.options.log('Parse error: ' + error.message);\n      }\n    });\n    return ws;\n  };\n  /**\r\n   * Used to subscribe to a combined delivery websocket endpoint\r\n   * @param {string} streams - streams to connect to\r\n   * @param {function} callback - the function to call when information is received\r\n   * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}\r\n   * @return {WebSocket} - websocket reference\r\n   */\n\n\n  const deliverySubscribe = function (streams, callback, params = {}) {\n    if (typeof streams === 'string') return deliverySubscribeSingle(streams, callback, params);\n    if (typeof params === 'boolean') params = {\n      reconnect: params\n    };\n    if (!params.reconnect) params.reconnect = false;\n    if (!params.openCallback) params.openCallback = false;\n    if (!params.id) params.id = false;\n    let httpsproxy = process.env.https_proxy || false;\n    let socksproxy = process.env.socks_proxy || false;\n    const queryParams = streams.join('/');\n    let ws = false;\n\n    if (socksproxy !== false) {\n      socksproxy = proxyReplacewithIp(socksproxy);\n      if (Binance.options.verbose) Binance.options.log(`deliverySubscribe: using socks proxy server ${socksproxy}`);\n      let agent = new SocksProxyAgent({\n        protocol: parseProxy(socksproxy)[0],\n        host: parseProxy(socksproxy)[1],\n        port: parseProxy(socksproxy)[2]\n      });\n      ws = new WebSocket((Binance.options.test ? dstreamTest : dstream) + queryParams, {\n        agent\n      });\n    } else if (httpsproxy !== false) {\n      if (Binance.options.verbose) Binance.options.log(`deliverySubscribe: using proxy server ${httpsproxy}`);\n      let config = url.parse(httpsproxy);\n      let agent = new HttpsProxyAgent(config);\n      ws = new WebSocket((Binance.options.test ? dstreamTest : dstream) + queryParams, {\n        agent\n      });\n    } else {\n      ws = new WebSocket((Binance.options.test ? dstreamTest : dstream) + queryParams);\n    }\n\n    ws.reconnect = Binance.options.reconnect;\n    ws.endpoint = stringHash(queryParams);\n    ws.isAlive = false;\n\n    if (Binance.options.verbose) {\n      Binance.options.log(`deliverySubscribe: Subscribed to [${ws.endpoint}] ${queryParams}`);\n    }\n\n    ws.on('open', handleDeliverySocketOpen.bind(ws, params.openCallback));\n    ws.on('pong', handleDeliverySocketHeartbeat);\n    ws.on('error', handleDeliverySocketError);\n    ws.on('close', handleDeliverySocketClose.bind(ws, params.reconnect));\n    ws.on('message', data => {\n      try {\n        callback(JSON.parse(data).data);\n      } catch (error) {\n        Binance.options.log(`deliverySubscribe: Parse error: ${error.message}`);\n      }\n    });\n    return ws;\n  };\n  /**\r\n   * Used to terminate a delivery websocket\r\n   * @param {string} endpoint - endpoint identifier associated with the web socket\r\n   * @param {boolean} reconnect - auto reconnect after termination\r\n   * @return {undefined}\r\n   */\n\n\n  const deliveryTerminate = function (endpoint, reconnect = false) {\n    let ws = Binance.deliverySubscriptions[endpoint];\n    if (!ws) return;\n    ws.removeAllListeners('message');\n    ws.reconnect = reconnect;\n    ws.terminate();\n  };\n  /**\r\n   * Combines all delivery OHLC data with the latest update\r\n   * @param {string} symbol - the symbol\r\n   * @param {string} interval - time interval\r\n   * @return {array} - interval data for given symbol\r\n   */\n\n\n  const deliveryKlineConcat = (symbol, interval) => {\n    let output = Binance.deliveryTicks[symbol][interval];\n    if (typeof Binance.deliveryRealtime[symbol][interval].time === 'undefined') return output;\n    const time = Binance.deliveryRealtime[symbol][interval].time;\n    const last_updated = Object.keys(Binance.deliveryTicks[symbol][interval]).pop();\n\n    if (time >= last_updated) {\n      output[time] = Binance.deliveryRealtime[symbol][interval]; //delete output[time].time;\n\n      output[last_updated].isFinal = true;\n      output[time].isFinal = false;\n    }\n\n    return output;\n  };\n  /**\r\n   * Used for websocket delivery @kline\r\n   * @param {string} symbol - the symbol\r\n   * @param {object} kline - object with kline info\r\n   * @param {string} firstTime - time filter\r\n   * @return {undefined}\r\n   */\n\n\n  const deliveryKlineHandler = (symbol, kline, firstTime = 0) => {\n    // eslint-disable-next-line no-unused-vars\n    let {\n      e: eventType,\n      E: eventTime,\n      k: ticks\n    } = kline; // eslint-disable-next-line no-unused-vars\n\n    let {\n      o: open,\n      h: high,\n      l: low,\n      c: close,\n      v: volume,\n      i: interval,\n      x: isFinal,\n      q: quoteVolume,\n      V: takerBuyBaseVolume,\n      Q: takerBuyQuoteVolume,\n      n: trades,\n      t: time,\n      T: closeTime\n    } = ticks;\n    if (time <= firstTime) return;\n\n    if (!isFinal) {\n      // if ( typeof Binance.futuresRealtime[symbol][interval].time !== 'undefined' ) {\n      //     if ( Binance.futuresRealtime[symbol][interval].time > time ) return;\n      // }\n      Binance.deliveryRealtime[symbol][interval] = {\n        time,\n        closeTime,\n        open,\n        high,\n        low,\n        close,\n        volume,\n        quoteVolume,\n        takerBuyBaseVolume,\n        takerBuyQuoteVolume,\n        trades,\n        isFinal\n      };\n      return;\n    }\n\n    const first_updated = Object.keys(Binance.deliveryTicks[symbol][interval]).shift();\n    if (first_updated) delete Binance.deliveryTicks[symbol][interval][first_updated];\n    Binance.deliveryTicks[symbol][interval][time] = {\n      time,\n      closeTime,\n      open,\n      high,\n      low,\n      close,\n      volume,\n      quoteVolume,\n      takerBuyBaseVolume,\n      takerBuyQuoteVolume,\n      trades,\n      isFinal: false\n    };\n  };\n  /**\r\n   * Converts the delivery liquidation stream data into a friendly object\r\n   * @param {object} data - liquidation data callback data type\r\n   * @return {object} - user friendly data type\r\n   */\n\n\n  const dLiquidationConvertData = data => {\n    let eventType = data.e,\n        eventTime = data.E;\n    let {\n      s: symbol,\n      S: side,\n      o: orderType,\n      f: timeInForce,\n      q: origAmount,\n      p: price,\n      ap: avgPrice,\n      X: orderStatus,\n      l: lastFilledQty,\n      z: totalFilledQty,\n      T: tradeTime\n    } = data.o;\n    return {\n      symbol,\n      side,\n      orderType,\n      timeInForce,\n      origAmount,\n      price,\n      avgPrice,\n      orderStatus,\n      lastFilledQty,\n      totalFilledQty,\n      eventType,\n      tradeTime,\n      eventTime\n    };\n  };\n  /**\r\n   * Converts the delivery ticker stream data into a friendly object\r\n   * @param {object} data - user data callback data type\r\n   * @return {object} - user friendly data type\r\n   */\n\n\n  const dTickerConvertData = data => {\n    let friendlyData = data => {\n      let {\n        e: eventType,\n        E: eventTime,\n        s: symbol,\n        p: priceChange,\n        P: percentChange,\n        w: averagePrice,\n        c: close,\n        Q: closeQty,\n        o: open,\n        h: high,\n        l: low,\n        v: volume,\n        q: quoteVolume,\n        O: openTime,\n        C: closeTime,\n        F: firstTradeId,\n        L: lastTradeId,\n        n: numTrades\n      } = data;\n      return {\n        eventType,\n        eventTime,\n        symbol,\n        priceChange,\n        percentChange,\n        averagePrice,\n        close,\n        closeQty,\n        open,\n        high,\n        low,\n        volume,\n        quoteVolume,\n        openTime,\n        closeTime,\n        firstTradeId,\n        lastTradeId,\n        numTrades\n      };\n    };\n\n    if (Array.isArray(data)) {\n      const result = [];\n\n      for (let obj of data) {\n        result.push(friendlyData(obj));\n      }\n\n      return result;\n    }\n\n    return friendlyData(data);\n  };\n  /**\r\n   * Converts the delivery miniTicker stream data into a friendly object\r\n   * @param {object} data - user data callback data type\r\n   * @return {object} - user friendly data type\r\n   */\n\n\n  const dMiniTickerConvertData = data => {\n    let friendlyData = data => {\n      let {\n        e: eventType,\n        E: eventTime,\n        s: symbol,\n        c: close,\n        o: open,\n        h: high,\n        l: low,\n        v: volume,\n        q: quoteVolume\n      } = data;\n      return {\n        eventType,\n        eventTime,\n        symbol,\n        close,\n        open,\n        high,\n        low,\n        volume,\n        quoteVolume\n      };\n    };\n\n    if (Array.isArray(data)) {\n      const result = [];\n\n      for (let obj of data) {\n        result.push(friendlyData(obj));\n      }\n\n      return result;\n    }\n\n    return friendlyData(data);\n  };\n  /**\r\n   * Converts the delivery bookTicker stream data into a friendly object\r\n   * @param {object} data - user data callback data type\r\n   * @return {object} - user friendly data type\r\n   */\n\n\n  const dBookTickerConvertData = data => {\n    let {\n      u: updateId,\n      s: symbol,\n      b: bestBid,\n      B: bestBidQty,\n      a: bestAsk,\n      A: bestAskQty\n    } = data;\n    return {\n      updateId,\n      symbol,\n      bestBid,\n      bestBidQty,\n      bestAsk,\n      bestAskQty\n    };\n  };\n  /**\r\n   * Converts the delivery markPrice stream data into a friendly object\r\n   * @param {object} data - user data callback data type\r\n   * @return {object} - user friendly data type\r\n   */\n\n\n  const dMarkPriceConvertData = data => {\n    let friendlyData = data => {\n      let {\n        e: eventType,\n        E: eventTime,\n        s: symbol,\n        p: markPrice,\n        r: fundingRate,\n        T: fundingTime\n      } = data;\n      return {\n        eventType,\n        eventTime,\n        symbol,\n        markPrice,\n        fundingRate,\n        fundingTime\n      };\n    };\n\n    if (Array.isArray(data)) {\n      const result = [];\n\n      for (let obj of data) {\n        result.push(friendlyData(obj));\n      }\n\n      return result;\n    }\n\n    return friendlyData(data);\n  };\n  /**\r\n   * Converts the delivery aggTrade stream data into a friendly object\r\n   * @param {object} data - user data callback data type\r\n   * @return {object} - user friendly data type\r\n   */\n\n\n  const dAggTradeConvertData = data => {\n    let friendlyData = data => {\n      let {\n        e: eventType,\n        E: eventTime,\n        s: symbol,\n        a: aggTradeId,\n        p: price,\n        q: amount,\n        f: firstTradeId,\n        l: lastTradeId,\n        T: timestamp,\n        m: maker\n      } = data;\n      return {\n        eventType,\n        eventTime,\n        symbol,\n        aggTradeId,\n        price,\n        amount,\n        total: price * amount,\n        firstTradeId,\n        lastTradeId,\n        timestamp,\n        maker\n      };\n    };\n\n    if (Array.isArray(data)) {\n      const result = [];\n\n      for (let obj of data) {\n        result.push(friendlyData(obj));\n      }\n\n      return result;\n    }\n\n    return friendlyData(data);\n  };\n  /**\r\n  * Converts the delivery UserData stream ORDER_TRADE_UPDATE data into a friendly object\r\n  * @param {object} data - user data callback data type\r\n  * @return {object} - user friendly data type\r\n  */\n\n\n  const dUserDataOrderUpdateConvertData = data => {\n    let {\n      e: eventType,\n      E: eventTime,\n      T: transaction,\n      // transaction time\n      o: order\n    } = data;\n\n    let orderConverter = order => {\n      let {\n        s: symbol,\n        c: clientOrderId,\n        // special client order id:\n        // starts with \"autoclose-\": liquidation order\n        // \"adl_autoclose\": ADL auto close order\n        S: side,\n        o: orderType,\n        f: timeInForce,\n        q: originalQuantity,\n        p: originalPrice,\n        ap: averagePrice,\n        sp: stopPrice,\n        // please ignore with TRAILING_STOP_MARKET order,\n        x: executionType,\n        X: orderStatus,\n        i: orderId,\n        l: orderLastFilledQuantity,\n        z: orderFilledAccumulatedQuantity,\n        L: lastFilledPrice,\n        ma: marginAsset,\n        N: commissionAsset,\n        // will not push if no commission\n        n: commission,\n        // will not push if no commission\n        T: orderTradeTime,\n        t: tradeId,\n        rp: realizedProfit,\n        b: bidsNotional,\n        a: askNotional,\n        m: isMakerSide,\n        // is this trade maker side\n        R: isReduceOnly,\n        // is this reduce only\n        wt: stopPriceWorkingType,\n        ot: originalOrderType,\n        ps: positionSide,\n        cp: closeAll,\n        // if close-all, pushed with conditional order\n        AP: activationPrice,\n        // only pushed with TRAILING_STOP_MARKET order\n        cr: callbackRate,\n        // only pushed with TRAILING_STOP_MARKET order\n        pP: priceProtect // If conditional order trigger is protected\n\n      } = order;\n      return {\n        symbol,\n        clientOrderId,\n        side,\n        orderType,\n        timeInForce,\n        originalQuantity,\n        originalPrice,\n        averagePrice,\n        stopPrice,\n        executionType,\n        orderStatus,\n        orderId,\n        orderLastFilledQuantity,\n        orderFilledAccumulatedQuantity,\n        lastFilledPrice,\n        marginAsset,\n        commissionAsset,\n        commission,\n        orderTradeTime,\n        tradeId,\n        bidsNotional,\n        askNotional,\n        isMakerSide,\n        isReduceOnly,\n        stopPriceWorkingType,\n        originalOrderType,\n        positionSide,\n        closeAll,\n        activationPrice,\n        callbackRate,\n        realizedProfit,\n        priceProtect\n      };\n    };\n\n    order = orderConverter(order);\n    return {\n      eventType,\n      eventTime,\n      transaction,\n      order\n    };\n  };\n  /**\r\n   * Used as part of the user data websockets callback\r\n   * @param {object} data - user data callback data type\r\n   * @return {undefined}\r\n   */\n\n\n  const userDataHandler = data => {\n    let type = data.e;\n\n    if (type === 'outboundAccountInfo') {// XXX: Deprecated in 2020-09-08\n    } else if (type === 'executionReport') {\n      if (Binance.options.execution_callback) Binance.options.execution_callback(data);\n    } else if (type === 'listStatus') {\n      if (Binance.options.list_status_callback) Binance.options.list_status_callback(data);\n    } else if (type === 'outboundAccountPosition') {\n      Binance.options.balance_callback(data);\n    } else {\n      Binance.options.log('Unexpected userData: ' + type);\n    }\n  };\n  /**\r\n   * Used as part of the user data websockets callback\r\n   * @param {object} data - user data callback data type\r\n   * @return {undefined}\r\n   */\n\n\n  const userMarginDataHandler = data => {\n    let type = data.e;\n\n    if (type === 'outboundAccountInfo') {// XXX: Deprecated in 2020-09-08\n    } else if (type === 'executionReport') {\n      if (Binance.options.margin_execution_callback) Binance.options.margin_execution_callback(data);\n    } else if (type === 'listStatus') {\n      if (Binance.options.margin_list_status_callback) Binance.options.margin_list_status_callback(data);\n    } else if (type === 'outboundAccountPosition') {\n      Binance.options.margin_balance_callback(data);\n    } else {\n      Binance.options.log('Unexpected userMarginData: ' + type);\n    }\n  };\n  /**\r\n   * Used as part of the user data websockets callback\r\n   * @param {object} data - user data callback data type\r\n   * @return {undefined}\r\n   */\n\n\n  const userFutureDataHandler = data => {\n    let type = data.e;\n\n    if (type === 'MARGIN_CALL') {\n      Binance.options.future_margin_call_callback(fUserDataMarginConvertData(data));\n    } else if (type === 'ACCOUNT_UPDATE') {\n      if (Binance.options.future_account_update_callback) {\n        Binance.options.future_account_update_callback(fUserDataAccountUpdateConvertData(data));\n      }\n    } else if (type === 'ORDER_TRADE_UPDATE') {\n      if (Binance.options.future_order_update_callback) {\n        Binance.options.future_order_update_callback(fUserDataOrderUpdateConvertData(data));\n      }\n    } else if (type === 'ACCOUNT_CONFIG_UPDATE') {\n      if (Binance.options.future_account_config_update_callback) {\n        Binance.options.future_account_config_update_callback(fUserConfigDataAccountUpdateConvertData(data));\n      }\n    } else {\n      Binance.options.log('Unexpected userFutureData: ' + type);\n    }\n  };\n  /**\r\n  * Used as part of the user data websockets callback\r\n  * @param {object} data - user data callback data type\r\n  * @return {undefined}\r\n  */\n\n\n  const userDeliveryDataHandler = data => {\n    let type = data.e;\n\n    if (type === \"MARGIN_CALL\") {\n      Binance.options.delivery_margin_call_callback(fUserDataMarginConvertData(data));\n    } else if (type === \"ACCOUNT_UPDATE\") {\n      if (Binance.options.delivery_account_update_callback) {\n        Binance.options.delivery_account_update_callback(fUserDataAccountUpdateConvertData(data));\n      }\n    } else if (type === \"ORDER_TRADE_UPDATE\") {\n      if (Binance.options.delivery_order_update_callback) {\n        Binance.options.delivery_order_update_callback(dUserDataOrderUpdateConvertData(data));\n      }\n    } else {\n      Binance.options.log(\"Unexpected userDeliveryData: \" + type);\n    }\n  };\n  /**\r\n  * Transfer between main account and futures/delivery accounts\r\n  * @param {string} asset - the asset\r\n  * @param {number} amount - the asset\r\n  * @param {function} callback - the callback function\r\n  * @param {object} options - additional options\r\n  * @return {undefined}\r\n  */\n\n\n  const transferBetweenMainAndFutures = function (asset, amount, type, callback) {\n    let parameters = Object.assign({\n      asset,\n      amount,\n      type\n    });\n\n    if (!callback) {\n      return new Promise((resolve, reject) => {\n        signedRequest(sapi + \"v1/futures/transfer\", parameters, function (error, data) {\n          if (error) return reject(error);\n          return resolve(data);\n        }, \"POST\");\n      });\n    }\n\n    signedRequest(sapi + \"v1/futures/transfer\", parameters, function (error, data) {\n      if (callback) return callback(error, data);\n    }, \"POST\");\n  };\n  /**\r\n   * Converts the previous day stream into friendly object\r\n   * @param {object} data - user data callback data type\r\n   * @return {object} - user friendly data type\r\n   */\n\n\n  const prevDayConvertData = data => {\n    let convertData = data => {\n      let {\n        e: eventType,\n        E: eventTime,\n        s: symbol,\n        p: priceChange,\n        P: percentChange,\n        w: averagePrice,\n        x: prevClose,\n        c: close,\n        Q: closeQty,\n        b: bestBid,\n        B: bestBidQty,\n        a: bestAsk,\n        A: bestAskQty,\n        o: open,\n        h: high,\n        l: low,\n        v: volume,\n        q: quoteVolume,\n        O: openTime,\n        C: closeTime,\n        F: firstTradeId,\n        L: lastTradeId,\n        n: numTrades\n      } = data;\n      return {\n        eventType,\n        eventTime,\n        symbol,\n        priceChange,\n        percentChange,\n        averagePrice,\n        prevClose,\n        close,\n        closeQty,\n        bestBid,\n        bestBidQty,\n        bestAsk,\n        bestAskQty,\n        open,\n        high,\n        low,\n        volume,\n        quoteVolume,\n        openTime,\n        closeTime,\n        firstTradeId,\n        lastTradeId,\n        numTrades\n      };\n    };\n\n    if (Array.isArray(data)) {\n      const result = [];\n\n      for (let obj of data) {\n        let converted = convertData(obj);\n        result.push(converted);\n      }\n\n      return result; // eslint-disable-next-line no-else-return\n    } else {\n      return convertData(data);\n    }\n  };\n  /**\r\n   * Parses the previous day stream and calls the user callback with friendly object\r\n   * @param {object} data - user data callback data type\r\n   * @param {function} callback - user data callback data type\r\n   * @return {undefined}\r\n   */\n\n\n  const prevDayStreamHandler = (data, callback) => {\n    const converted = prevDayConvertData(data);\n    callback(null, converted);\n  };\n  /**\r\n   * Gets the price of a given symbol or symbols\r\n   * @param {array} data - array of symbols\r\n   * @return {array} - symbols with their current prices\r\n   */\n\n\n  const priceData = data => {\n    const prices = {};\n\n    if (Array.isArray(data)) {\n      for (let obj of data) {\n        prices[obj.symbol] = obj.price;\n      }\n    } else {\n      // Single price returned\n      prices[data.symbol] = data.price;\n    }\n\n    return prices;\n  };\n  /**\r\n   * Used by bookTickers to format the bids and asks given given symbols\r\n   * @param {array} data - array of symbols\r\n   * @return {object} - symbols with their bids and asks data\r\n   */\n\n\n  const bookPriceData = data => {\n    let prices = {};\n\n    for (let obj of data) {\n      prices[obj.symbol] = {\n        bid: obj.bidPrice,\n        bids: obj.bidQty,\n        ask: obj.askPrice,\n        asks: obj.askQty\n      };\n    }\n\n    return prices;\n  };\n  /**\r\n   * Used by balance to get the balance data\r\n   * @param {array} data - account info object\r\n   * @return {object} - balances hel with available, onorder amounts\r\n   */\n\n\n  const balanceData = data => {\n    let balances = {};\n    if (typeof data === 'undefined') return {};\n\n    if (typeof data.balances === 'undefined') {\n      Binance.options.log('balanceData error', data);\n      return {};\n    }\n\n    for (let obj of data.balances) {\n      balances[obj.asset] = {\n        available: obj.free,\n        onOrder: obj.locked\n      };\n    }\n\n    return balances;\n  };\n  /**\r\n   * Used by web sockets depth and populates OHLC and info\r\n   * @param {string} symbol - symbol to get candlestick info\r\n   * @param {string} interval - time interval, 1m, 3m, 5m ....\r\n   * @param {array} ticks - tick array\r\n   * @return {undefined}\r\n   */\n\n\n  const klineData = (symbol, interval, ticks) => {\n    // Used for /depth\n    let last_time = 0;\n\n    if (isIterable(ticks)) {\n      for (let tick of ticks) {\n        // eslint-disable-next-line no-unused-vars\n        let [time, open, high, low, close, volume, closeTime, assetVolume, trades, buyBaseVolume, buyAssetVolume, ignored] = tick;\n        Binance.ohlc[symbol][interval][time] = {\n          open: open,\n          high: high,\n          low: low,\n          close: close,\n          volume: volume\n        };\n        last_time = time;\n      }\n\n      Binance.info[symbol][interval].timestamp = last_time;\n    }\n  };\n  /**\r\n   * Combines all OHLC data with latest update\r\n   * @param {string} symbol - the symbol\r\n   * @param {string} interval - time interval, 1m, 3m, 5m ....\r\n   * @return {array} - interval data for given symbol\r\n   */\n\n\n  const klineConcat = (symbol, interval) => {\n    let output = Binance.ohlc[symbol][interval];\n    if (typeof Binance.ohlcLatest[symbol][interval].time === 'undefined') return output;\n    const time = Binance.ohlcLatest[symbol][interval].time;\n    const last_updated = Object.keys(Binance.ohlc[symbol][interval]).pop();\n\n    if (time >= last_updated) {\n      output[time] = Binance.ohlcLatest[symbol][interval];\n      delete output[time].time;\n      output[time].isFinal = false;\n    }\n\n    return output;\n  };\n  /**\r\n   * Used for websocket @kline\r\n   * @param {string} symbol - the symbol\r\n   * @param {object} kline - object with kline info\r\n   * @param {string} firstTime - time filter\r\n   * @return {undefined}\r\n   */\n\n\n  const klineHandler = (symbol, kline, firstTime = 0) => {\n    // TODO: add Taker buy base asset volume\n    // eslint-disable-next-line no-unused-vars\n    let {\n      e: eventType,\n      E: eventTime,\n      k: ticks\n    } = kline; // eslint-disable-next-line no-unused-vars\n\n    let {\n      o: open,\n      h: high,\n      l: low,\n      c: close,\n      v: volume,\n      i: interval,\n      x: isFinal,\n      q: quoteVolume,\n      t: time\n    } = ticks; //n:trades, V:buyVolume, Q:quoteBuyVolume\n\n    if (time <= firstTime) return;\n\n    if (!isFinal) {\n      if (typeof Binance.ohlcLatest[symbol][interval].time !== 'undefined') {\n        if (Binance.ohlcLatest[symbol][interval].time > time) return;\n      }\n\n      Binance.ohlcLatest[symbol][interval] = {\n        open: open,\n        high: high,\n        low: low,\n        close: close,\n        volume: volume,\n        time: time\n      };\n      return;\n    } // Delete an element from the beginning so we don't run out of memory\n\n\n    const first_updated = Object.keys(Binance.ohlc[symbol][interval]).shift();\n    if (first_updated) delete Binance.ohlc[symbol][interval][first_updated];\n    Binance.ohlc[symbol][interval][time] = {\n      open: open,\n      high: high,\n      low: low,\n      close: close,\n      volume: volume\n    };\n  };\n  /**\r\n   * Used by futures websockets chart cache\r\n   * @param {string} symbol - symbol to get candlestick info\r\n   * @param {string} interval - time interval, 1m, 3m, 5m ....\r\n   * @param {array} ticks - tick array\r\n   * @return {undefined}\r\n   */\n\n\n  const futuresKlineData = (symbol, interval, ticks) => {\n    let last_time = 0;\n\n    if (isIterable(ticks)) {\n      for (let tick of ticks) {\n        // eslint-disable-next-line no-unused-vars\n        let [time, open, high, low, close, volume, closeTime, quoteVolume, trades, takerBuyBaseVolume, takerBuyQuoteVolume, ignored] = tick;\n        Binance.futuresTicks[symbol][interval][time] = {\n          time,\n          closeTime,\n          open,\n          high,\n          low,\n          close,\n          volume,\n          quoteVolume,\n          takerBuyBaseVolume,\n          takerBuyQuoteVolume,\n          trades\n        };\n        last_time = time;\n      }\n\n      Binance.futuresMeta[symbol][interval].timestamp = last_time;\n    }\n  };\n  /**\r\n   * Used by delivery websockets chart cache\r\n   * @param {string} symbol - symbol to get candlestick info\r\n   * @param {string} interval - time interval, 1m, 3m, 5m ....\r\n   * @param {array} ticks - tick array\r\n   * @return {undefined}\r\n   */\n\n\n  const deliveryKlineData = (symbol, interval, ticks) => {\n    let last_time = 0;\n\n    if (isIterable(ticks)) {\n      for (let tick of ticks) {\n        // eslint-disable-next-line no-unused-vars\n        let [time, open, high, low, close, volume, closeTime, quoteVolume, trades, takerBuyBaseVolume, takerBuyQuoteVolume, ignored] = tick;\n        Binance.deliveryTicks[symbol][interval][time] = {\n          time,\n          closeTime,\n          open,\n          high,\n          low,\n          close,\n          volume,\n          quoteVolume,\n          takerBuyBaseVolume,\n          takerBuyQuoteVolume,\n          trades\n        };\n        last_time = time;\n      }\n\n      Binance.deliveryMeta[symbol][interval].timestamp = last_time;\n    }\n  };\n  /**\r\n   * Used for /depth endpoint\r\n   * @param {object} data - containing the bids and asks\r\n   * @return {undefined}\r\n   */\n\n\n  const depthData = data => {\n    if (!data) return {\n      bids: [],\n      asks: []\n    };\n    let bids = {},\n        asks = {},\n        obj;\n\n    if (typeof data.bids !== 'undefined') {\n      for (obj of data.bids) {\n        bids[obj[0]] = parseFloat(obj[1]);\n      }\n    }\n\n    if (typeof data.asks !== 'undefined') {\n      for (obj of data.asks) {\n        asks[obj[0]] = parseFloat(obj[1]);\n      }\n    }\n\n    return {\n      lastUpdateId: data.lastUpdateId,\n      bids: bids,\n      asks: asks\n    };\n  };\n  /**\r\n   * Used for /depth endpoint\r\n   * @param {object} depth - information\r\n   * @return {undefined}\r\n   */\n\n\n  const depthHandler = depth => {\n    let symbol = depth.s,\n        obj;\n    let context = Binance.depthCacheContext[symbol];\n\n    let updateDepthCache = () => {\n      Binance.depthCache[symbol].eventTime = depth.E;\n\n      for (obj of depth.b) {\n        //bids\n        if (obj[1] === '0.00000000') {\n          delete Binance.depthCache[symbol].bids[obj[0]];\n        } else {\n          Binance.depthCache[symbol].bids[obj[0]] = parseFloat(obj[1]);\n        }\n      }\n\n      for (obj of depth.a) {\n        //asks\n        if (obj[1] === '0.00000000') {\n          delete Binance.depthCache[symbol].asks[obj[0]];\n        } else {\n          Binance.depthCache[symbol].asks[obj[0]] = parseFloat(obj[1]);\n        }\n      }\n\n      context.skipCount = 0;\n      context.lastEventUpdateId = depth.u;\n      context.lastEventUpdateTime = depth.E;\n    }; // This now conforms 100% to the Binance docs constraints on managing a local order book\n\n\n    if (context.lastEventUpdateId) {\n      const expectedUpdateId = context.lastEventUpdateId + 1;\n\n      if (depth.U <= expectedUpdateId) {\n        updateDepthCache();\n      } else {\n        let msg = 'depthHandler: [' + symbol + '] The depth cache is out of sync.';\n        msg += ' Symptom: Unexpected Update ID. Expected \"' + expectedUpdateId + '\", got \"' + depth.U + '\"';\n        if (Binance.options.verbose) Binance.options.log(msg);\n        throw new Error(msg);\n      }\n    } else if (depth.U > context.snapshotUpdateId + 1) {\n      /* In this case we have a gap between the data of the stream and the snapshot.\r\n       This is an out of sync error, and the connection must be torn down and reconnected. */\n      let msg = 'depthHandler: [' + symbol + '] The depth cache is out of sync.';\n      msg += ' Symptom: Gap between snapshot and first stream data.';\n      if (Binance.options.verbose) Binance.options.log(msg);\n      throw new Error(msg);\n    } else if (depth.u < context.snapshotUpdateId + 1) {\n      /* In this case we've received data that we've already had since the snapshot.\r\n       This isn't really an issue, and we can just update the cache again, or ignore it entirely. */\n      // do nothing\n    } else {\n      // This is our first legal update from the stream data\n      updateDepthCache();\n    }\n  };\n  /**\r\n   * Gets depth cache for given symbol\r\n   * @param {string} symbol - the symbol to fetch\r\n   * @return {object} - the depth cache object\r\n   */\n\n\n  const getDepthCache = symbol => {\n    if (typeof Binance.depthCache[symbol] === 'undefined') return {\n      bids: {},\n      asks: {}\n    };\n    return Binance.depthCache[symbol];\n  };\n  /**\r\n   * Calculate Buy/Sell volume from DepthCache\r\n   * @param {string} symbol - the symbol to fetch\r\n   * @return {object} - the depth volume cache object\r\n   */\n\n\n  const depthVolume = symbol => {\n    let cache = getDepthCache(symbol),\n        quantity,\n        price;\n    let bidbase = 0,\n        askbase = 0,\n        bidqty = 0,\n        askqty = 0;\n\n    for (price in cache.bids) {\n      quantity = cache.bids[price];\n      bidbase += parseFloat((quantity * parseFloat(price)).toFixed(8));\n      bidqty += quantity;\n    }\n\n    for (price in cache.asks) {\n      quantity = cache.asks[price];\n      askbase += parseFloat((quantity * parseFloat(price)).toFixed(8));\n      askqty += quantity;\n    }\n\n    return {\n      bids: bidbase,\n      asks: askbase,\n      bidQty: bidqty,\n      askQty: askqty\n    };\n  };\n  /**\r\n   * Checks whether or not an array contains any duplicate elements\r\n   * @param {array} array - the array to check\r\n   * @return {boolean} - true or false\r\n   */\n\n\n  const isArrayUnique = array => {\n    return new Set(array).size === array.length;\n  };\n\n  return {\n    /**\r\n    * Gets depth cache for given symbol\r\n    * @param {symbol} symbol - get depch cache for this symbol\r\n    * @return {object} - object\r\n    */\n    depthCache: symbol => {\n      return getDepthCache(symbol);\n    },\n\n    /**\r\n    * Gets depth volume for given symbol\r\n    * @param {symbol} symbol - get depch volume for this symbol\r\n    * @return {object} - object\r\n    */\n    depthVolume: symbol => {\n      return depthVolume(symbol);\n    },\n\n    /**\r\n    * Count decimal places\r\n    * @param {float} float - get the price precision point\r\n    * @return {int} - number of place\r\n    */\n    getPrecision: function (float) {\n      if (!float || Number.isInteger(float)) return 0;\n      return float.toString().split('.')[1].length || 0;\n    },\n\n    /**\r\n    * rounds number with given step\r\n    * @param {float} qty - quantity to round\r\n    * @param {float} stepSize - stepSize as specified by exchangeInfo\r\n    * @return {float} - number\r\n    */\n    roundStep: function (qty, stepSize) {\n      // Integers do not require rounding\n      if (Number.isInteger(qty)) return qty;\n      const qtyString = qty.toFixed(16);\n      const desiredDecimals = Math.max(stepSize.indexOf('1') - 1, 0);\n      const decimalIndex = qtyString.indexOf('.');\n      return parseFloat(qtyString.slice(0, decimalIndex + desiredDecimals + 1));\n    },\n\n    /**\r\n    * rounds price to required precision\r\n    * @param {float} price - price to round\r\n    * @param {float} tickSize - tickSize as specified by exchangeInfo\r\n    * @return {float} - number\r\n    */\n    roundTicks: function (price, tickSize) {\n      const formatter = new Intl.NumberFormat('en-US', {\n        style: 'decimal',\n        minimumFractionDigits: 0,\n        maximumFractionDigits: 8\n      });\n      const precision = formatter.format(tickSize).split('.')[1].length || 0;\n      if (typeof price === 'string') price = parseFloat(price);\n      return price.toFixed(precision);\n    },\n\n    /**\r\n    * Gets percentage of given numbers\r\n    * @param {float} min - the smaller number\r\n    * @param {float} max - the bigger number\r\n    * @param {int} width - percentage width\r\n    * @return {float} - percentage\r\n    */\n    percent: function (min, max, width = 100) {\n      return min * 0.01 / (max * 0.01) * width;\n    },\n\n    /**\r\n    * Gets the sum of an array of numbers\r\n    * @param {array} array - the number to add\r\n    * @return {float} - sum\r\n    */\n    sum: function (array) {\n      return array.reduce((a, b) => a + b, 0);\n    },\n\n    /**\r\n    * Reverses the keys of an object\r\n    * @param {object} object - the object\r\n    * @return {object} - the object\r\n    */\n    reverse: function (object) {\n      let range = Object.keys(object).reverse(),\n          output = {};\n\n      for (let price of range) {\n        output[price] = object[price];\n      }\n\n      return output;\n    },\n\n    /**\r\n    * Converts an object to an array\r\n    * @param {object} obj - the object\r\n    * @return {array} - the array\r\n    */\n    array: function (obj) {\n      return Object.keys(obj).map(function (key) {\n        return [Number(key), obj[key]];\n      });\n    },\n\n    /**\r\n    * Sorts bids\r\n    * @param {string} symbol - the object\r\n    * @param {int} max - the max number of bids\r\n    * @param {string} baseValue - the object\r\n    * @return {object} - the object\r\n    */\n    sortBids: function (symbol, max = Infinity, baseValue = false) {\n      let object = {},\n          count = 0,\n          cache;\n      if (typeof symbol === 'object') cache = symbol;else cache = getDepthCache(symbol).bids;\n      const sorted = Object.keys(cache).sort((a, b) => parseFloat(b) - parseFloat(a));\n      let cumulative = 0;\n\n      for (let price of sorted) {\n        if (!baseValue) object[price] = cache[price];else if (baseValue === 'cumulative') {\n          cumulative += cache[price];\n          object[price] = cumulative;\n        } else object[price] = parseFloat((cache[price] * parseFloat(price)).toFixed(8));\n        if (++count >= max) break;\n      }\n\n      return object;\n    },\n\n    /**\r\n    * Sorts asks\r\n    * @param {string} symbol - the object\r\n    * @param {int} max - the max number of bids\r\n    * @param {string} baseValue - the object\r\n    * @return {object} - the object\r\n    */\n    sortAsks: function (symbol, max = Infinity, baseValue = false) {\n      let object = {},\n          count = 0,\n          cache;\n      if (typeof symbol === 'object') cache = symbol;else cache = getDepthCache(symbol).asks;\n      const sorted = Object.keys(cache).sort((a, b) => parseFloat(a) - parseFloat(b));\n      let cumulative = 0;\n\n      for (let price of sorted) {\n        if (!baseValue) object[price] = cache[price];else if (baseValue === 'cumulative') {\n          cumulative += cache[price];\n          object[price] = cumulative;\n        } else object[price] = parseFloat((cache[price] * parseFloat(price)).toFixed(8));\n        if (++count >= max) break;\n      }\n\n      return object;\n    },\n\n    /**\r\n    * Returns the first property of an object\r\n    * @param {object} object - the object to get the first member\r\n    * @return {string} - the object key\r\n    */\n    first: function (object) {\n      return Object.keys(object).shift();\n    },\n\n    /**\r\n    * Returns the last property of an object\r\n    * @param {object} object - the object to get the first member\r\n    * @return {string} - the object key\r\n    */\n    last: function (object) {\n      return Object.keys(object).pop();\n    },\n\n    /**\r\n    * Returns an array of properties starting at start\r\n    * @param {object} object - the object to get the properties form\r\n    * @param {int} start - the starting index\r\n    * @return {array} - the array of entires\r\n    */\n    slice: function (object, start = 0) {\n      return Object.keys(object).slice(start);\n    },\n\n    /**\r\n    * Gets the minimum key form object\r\n    * @param {object} object - the object to get the properties form\r\n    * @return {string} - the minimum key\r\n    */\n    min: function (object) {\n      return Math.min.apply(Math, Object.keys(object));\n    },\n\n    /**\r\n    * Gets the maximum key form object\r\n    * @param {object} object - the object to get the properties form\r\n    * @return {string} - the minimum key\r\n    */\n    max: function (object) {\n      return Math.max.apply(Math, Object.keys(object));\n    },\n\n    /**\r\n    * Sets an option given a key and value\r\n    * @param {string} key - the key to set\r\n    * @param {object} value - the value of the key\r\n    * @return {undefined}\r\n    */\n    setOption: function (key, value) {\n      Binance.options[key] = value;\n    },\n\n    /**\r\n    * Gets an option given a key\r\n    * @param {string} key - the key to set\r\n    * @return {undefined}\r\n    */\n    getOption: key => Binance.options[key],\n\n    /**\r\n    * Returns the entire info object\r\n    * @return {object} - the info object\r\n    */\n    getInfo: () => Binance.info,\n\n    /**\r\n    * Returns the used weight from the last request\r\n    * @return {object} - 1m weight used\r\n    */\n    usedWeight: () => Binance.info.usedWeight,\n\n    /**\r\n    * Returns the status code from the last http response\r\n    * @return {object} - status code\r\n    */\n    statusCode: () => Binance.info.statusCode,\n\n    /**\r\n    * Returns the ping time from the last futures request\r\n    * @return {object} - latency/ping (2ms)\r\n    */\n    futuresLatency: () => Binance.info.futuresLatency,\n\n    /**\r\n    * Returns the complete URL from the last request\r\n    * @return {object} - http address including query string\r\n    */\n    lastURL: () => Binance.info.lastURL,\n\n    /**\r\n    * Returns the order count from the last request\r\n    * @return {object} - orders allowed per 1m\r\n    */\n    orderCount: () => Binance.info.orderCount1m,\n\n    /**\r\n    * Returns the entire options object\r\n    * @return {object} - the options object\r\n    */\n    getOptions: () => Binance.options,\n\n    /**\r\n    * Gets an option given a key\r\n    * @param {object} opt - the object with the class configuration\r\n    * @param {function} callback - the callback function\r\n    * @return {undefined}\r\n    */\n    options: setOptions,\n\n    /**\r\n    * Creates an order\r\n    * @param {string} side - BUY or SELL\r\n    * @param {string} symbol - the symbol to buy\r\n    * @param {numeric} quantity - the quantity required\r\n    * @param {numeric} price - the price to pay for each unit\r\n    * @param {object} flags - aadditionalbuy order flags\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    order: function (side, symbol, quantity, price, flags = {}, callback = false) {\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          order(side, symbol, quantity, price, flags, callback);\n        });\n      } else {\n        order(side, symbol, quantity, price, flags, callback);\n      }\n    },\n\n    /**\r\n    * Creates a buy order\r\n    * @param {string} symbol - the symbol to buy\r\n    * @param {numeric} quantity - the quantity required\r\n    * @param {numeric} price - the price to pay for each unit\r\n    * @param {object} flags - additional buy order flags\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    buy: function (symbol, quantity, price, flags = {}, callback = false) {\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          order('BUY', symbol, quantity, price, flags, callback);\n        });\n      } else {\n        order('BUY', symbol, quantity, price, flags, callback);\n      }\n    },\n\n    /**\r\n    * Creates a sell order\r\n    * @param {string} symbol - the symbol to sell\r\n    * @param {numeric} quantity - the quantity required\r\n    * @param {numeric} price - the price to sell each unit for\r\n    * @param {object} flags - additional order flags\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    sell: function (symbol, quantity, price, flags = {}, callback = false) {\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          order('SELL', symbol, quantity, price, flags, callback);\n        });\n      } else {\n        order('SELL', symbol, quantity, price, flags, callback);\n      }\n    },\n\n    /**\r\n    * Creates a market buy order\r\n    * @param {string} symbol - the symbol to buy\r\n    * @param {numeric} quantity - the quantity required\r\n    * @param {object} flags - additional buy order flags\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    marketBuy: function (symbol, quantity, flags = {\n      type: 'MARKET'\n    }, callback = false) {\n      if (typeof flags === 'function') {\n        // Accept callback as third parameter\n        callback = flags;\n        flags = {\n          type: 'MARKET'\n        };\n      }\n\n      if (typeof flags.type === 'undefined') flags.type = 'MARKET';\n\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          order('BUY', symbol, quantity, 0, flags, callback);\n        });\n      } else {\n        order('BUY', symbol, quantity, 0, flags, callback);\n      }\n    },\n\n    /**\r\n    * Creates a market sell order\r\n    * @param {string} symbol - the symbol to sell\r\n    * @param {numeric} quantity - the quantity required\r\n    * @param {object} flags - additional sell order flags\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    marketSell: function (symbol, quantity, flags = {\n      type: 'MARKET'\n    }, callback = false) {\n      if (typeof flags === 'function') {\n        // Accept callback as third parameter\n        callback = flags;\n        flags = {\n          type: 'MARKET'\n        };\n      }\n\n      if (typeof flags.type === 'undefined') flags.type = 'MARKET';\n\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          order('SELL', symbol, quantity, 0, flags, callback);\n        });\n      } else {\n        order('SELL', symbol, quantity, 0, flags, callback);\n      }\n    },\n\n    /**\r\n    * Cancels an order\r\n    * @param {string} symbol - the symbol to cancel\r\n    * @param {string} orderid - the orderid to cancel\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    cancel: function (symbol, orderid, callback = false) {\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          signedRequest(base + 'v3/order', {\n            symbol: symbol,\n            orderId: orderid\n          }, function (error, data) {\n            return callback.call(this, error, data, symbol);\n          }, 'DELETE');\n        });\n      } else {\n        signedRequest(base + 'v3/order', {\n          symbol: symbol,\n          orderId: orderid\n        }, function (error, data) {\n          return callback.call(this, error, data, symbol);\n        }, 'DELETE');\n      }\n    },\n\n    /**\r\n    * Gets the status of an order\r\n    * @param {string} symbol - the symbol to check\r\n    * @param {string} orderid - the orderid to check\r\n    * @param {function} callback - the callback function\r\n    * @param {object} flags - any additional flags\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    orderStatus: function (symbol, orderid, callback, flags = {}) {\n      let parameters = Object.assign({\n        symbol: symbol,\n        orderId: orderid\n      }, flags);\n\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          signedRequest(base + 'v3/order', parameters, function (error, data) {\n            return callback.call(this, error, data, symbol);\n          });\n        });\n      } else {\n        signedRequest(base + 'v3/order', parameters, function (error, data) {\n          return callback.call(this, error, data, symbol);\n        });\n      }\n    },\n\n    /**\r\n    * Gets open orders\r\n    * @param {string} symbol - the symbol to get\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    openOrders: function (symbol, callback) {\n      let parameters = symbol ? {\n        symbol: symbol\n      } : {};\n\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          signedRequest(base + 'v3/openOrders', parameters, function (error, data) {\n            return callback.call(this, error, data, symbol);\n          });\n        });\n      } else {\n        signedRequest(base + 'v3/openOrders', parameters, function (error, data) {\n          return callback.call(this, error, data, symbol);\n        });\n      }\n    },\n\n    /**\r\n    * Cancels all orders of a given symbol\r\n    * @param {string} symbol - the symbol to cancel all orders for\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    cancelAll: function (symbol, callback = false) {\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          signedRequest(base + 'v3/openOrders', {\n            symbol\n          }, callback, 'DELETE');\n        });\n      } else {\n        signedRequest(base + 'v3/openOrders', {\n          symbol\n        }, callback, 'DELETE');\n      }\n    },\n\n    /**\r\n    * Cancels all orders of a given symbol\r\n    * @param {string} symbol - the symbol to cancel all orders for\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    cancelOrders: function (symbol, callback = false) {\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          signedRequest(base + 'v3/openOrders', {\n            symbol\n          }, function (error, json) {\n            if (json.length === 0) {\n              return callback.call(this, 'No orders present for this symbol', {}, symbol);\n            }\n\n            for (let obj of json) {\n              let quantity = obj.origQty - obj.executedQty;\n              Binance.options.log('cancel order: ' + obj.side + ' ' + symbol + ' ' + quantity + ' @ ' + obj.price + ' #' + obj.orderId);\n              signedRequest(base + 'v3/order', {\n                symbol,\n                orderId: obj.orderId\n              }, function (error, data) {\n                return callback.call(this, error, data, symbol);\n              }, 'DELETE');\n            }\n          });\n        });\n      } else {\n        signedRequest(base + 'v3/openOrders', {\n          symbol: symbol\n        }, function (error, json) {\n          if (json.length === 0) {\n            return callback.call(this, 'No orders present for this symbol', {}, symbol);\n          }\n\n          for (let obj of json) {\n            let quantity = obj.origQty - obj.executedQty;\n            Binance.options.log('cancel order: ' + obj.side + ' ' + symbol + ' ' + quantity + ' @ ' + obj.price + ' #' + obj.orderId);\n            signedRequest(base + 'v3/order', {\n              symbol: symbol,\n              orderId: obj.orderId\n            }, function (error, data) {\n              return callback.call(this, error, data, symbol);\n            }, 'DELETE');\n          }\n        });\n      }\n    },\n\n    /**\r\n    * Gets all order of a given symbol\r\n    * @param {string} symbol - the symbol\r\n    * @param {function} callback - the callback function (can also accept options)\r\n    * @param {object} options - additional options\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    allOrders: function (symbol, callback, options = {}) {\n      let parameters = Object.assign({\n        symbol\n      }, options);\n\n      if (typeof callback == 'object') {\n        // Allow second parameter to be options\n        options = callback;\n        callback = false;\n      }\n\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          signedRequest(base + 'v3/allOrders', parameters, function (error, data) {\n            return callback.call(this, error, data, symbol);\n          });\n        });\n      } else {\n        signedRequest(base + 'v3/allOrders', parameters, function (error, data) {\n          return callback.call(this, error, data, symbol);\n        });\n      }\n    },\n\n    /**\r\n    * Gets the depth information for a given symbol\r\n    * @param {string} symbol - the symbol\r\n    * @param {function} callback - the callback function\r\n    * @param {int} limit - limit the number of returned orders\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    depth: function (symbol, callback, limit = 100) {\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          publicRequest(base + 'v3/depth', {\n            symbol: symbol,\n            limit: limit\n          }, function (error, data) {\n            return callback.call(this, error, depthData(data), symbol);\n          });\n        });\n      } else {\n        publicRequest(base + 'v3/depth', {\n          symbol: symbol,\n          limit: limit\n        }, function (error, data) {\n          return callback.call(this, error, depthData(data), symbol);\n        });\n      }\n    },\n\n    /**\r\n    * Gets the average prices of a given symbol\r\n    * @param {string} symbol - the symbol\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    avgPrice: function (symbol, callback = false) {\n      let opt = {\n        url: base + 'v3/avgPrice?symbol=' + symbol,\n        timeout: Binance.options.recvWindow\n      };\n\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          request(addProxy(opt), (error, response, body) => {\n            if (error) return reject(error);\n            if (response.statusCode !== 200) return reject(response);\n            let result = {};\n            result[symbol] = JSON.parse(response.body).price;\n            return resolve(result);\n          }).on('error', reject);\n        });\n      }\n\n      request(addProxy(opt), (error, response, body) => {\n        if (error) return callback(error);\n        if (response.statusCode !== 200) return callback(response);\n        let result = {};\n        result[symbol] = JSON.parse(response.body).price;\n        return callback(null, result);\n      }).on('error', callback);\n    },\n\n    /**\r\n    * Gets the prices of a given symbol(s)\r\n    * @param {string} symbol - the symbol\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    prices: function (symbol, callback = false) {\n      const params = typeof symbol === 'string' ? '?symbol=' + symbol : '';\n      if (typeof symbol === 'function') callback = symbol; // backwards compatibility\n\n      let opt = {\n        url: base + 'v3/ticker/price' + params,\n        timeout: Binance.options.recvWindow\n      };\n\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          request(addProxy(opt), (error, response, body) => {\n            if (error) return reject(error);\n            if (response.statusCode !== 200) return reject(response);\n            return resolve(priceData(JSON.parse(body)));\n          }).on('error', reject);\n        });\n      }\n\n      request(addProxy(opt), (error, response, body) => {\n        if (error) return callback(error);\n        if (response.statusCode !== 200) return callback(response);\n        return callback(null, priceData(JSON.parse(body)));\n      }).on('error', callback);\n    },\n\n    /**\r\n    * Gets the book tickers of given symbol(s)\r\n    * @param {string} symbol - the symbol\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    bookTickers: function (symbol, callback) {\n      const params = typeof symbol === 'string' ? '?symbol=' + symbol : '';\n      if (typeof symbol === 'function') callback = symbol; // backwards compatibility\n\n      let opt = {\n        url: base + 'v3/ticker/bookTicker' + params,\n        timeout: Binance.options.recvWindow\n      };\n\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          request(addProxy(opt), function (error, response, body) {\n            if (error) return reject(error);\n            if (response.statusCode !== 200) return reject(response);\n            const result = symbol ? JSON.parse(body) : bookPriceData(JSON.parse(body));\n            return resolve(result);\n          }).on('error', reject);\n        });\n      }\n\n      request(addProxy(opt), (error, response, body) => {\n        if (error) return callback(error);\n        if (response.statusCode !== 200) return callback(response);\n        const result = symbol ? JSON.parse(body) : bookPriceData(JSON.parse(body));\n        return callback(null, result);\n      }).on('error', callback);\n    },\n\n    /**\r\n    * Gets the prevday percentage change\r\n    * @param {string} symbol - the symbol or symbols\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    prevDay: function (symbol, callback) {\n      let input = symbol ? {\n        symbol: symbol\n      } : {};\n\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          publicRequest(base + 'v3/ticker/24hr', input, (error, data) => {\n            return callback.call(this, error, data, symbol);\n          });\n        });\n      } else {\n        publicRequest(base + 'v3/ticker/24hr', input, (error, data) => {\n          return callback.call(this, error, data, symbol);\n        });\n      }\n    },\n\n    /**\r\n    * Gets the the exchange info\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    exchangeInfo: function (callback) {\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          publicRequest(base + 'v3/exchangeInfo', {}, callback);\n        });\n      } else {\n        publicRequest(base + 'v3/exchangeInfo', {}, callback);\n      }\n    },\n\n    /**\r\n    * Gets the dust log for user\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    dustLog: function (callback) {\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          signedRequest(wapi + '/v3/userAssetDribbletLog.html', {}, callback);\n        });\n      } else {\n        signedRequest(wapi + '/v3/userAssetDribbletLog.html', {}, callback);\n      }\n    },\n    dustTransfer: function (assets, callback) {\n      signedRequest(sapi + 'v1/asset/dust', {\n        asset: assets\n      }, callback, 'POST');\n    },\n    assetDividendRecord: function (callback, params = {}) {\n      signedRequest(sapi + 'v1/asset/assetDividend', params, callback);\n    },\n\n    /**\r\n    * Gets the the system status\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    systemStatus: function (callback) {\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          publicRequest(wapi + 'v3/systemStatus.html', {}, callback);\n        });\n      } else {\n        publicRequest(wapi + 'v3/systemStatus.html', {}, callback);\n      }\n    },\n\n    /**\r\n    * Withdraws asset to given wallet id\r\n    * @param {string} asset - the asset symbol\r\n    * @param {string} address - the wallet to transfer it to\r\n    * @param {number} amount - the amount to transfer\r\n    * @param {string} addressTag - and addtional address tag\r\n    * @param {function} callback - the callback function\r\n    * @param {string} name - the name to save the address as. Set falsy to prevent Binance saving to address book\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    withdraw: function (asset, address, amount, addressTag = false, callback = false, name = false) {\n      let params = {\n        asset,\n        address,\n        amount\n      };\n      if (name) params.name = name;\n      if (addressTag) params.addressTag = addressTag;\n\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          signedRequest(wapi + 'v3/withdraw.html', params, callback, 'POST');\n        });\n      } else {\n        signedRequest(wapi + 'v3/withdraw.html', params, callback, 'POST');\n      }\n    },\n\n    /**\r\n    * Get the Withdraws history for a given asset\r\n    * @param {function} callback - the callback function\r\n    * @param {object} params - supports limit and fromId parameters\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    withdrawHistory: function (callback, params = {}) {\n      if (typeof params === 'string') params = {\n        asset: params\n      };\n\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          signedRequest(wapi + 'v3/withdrawHistory.html', params, callback);\n        });\n      } else {\n        signedRequest(wapi + 'v3/withdrawHistory.html', params, callback);\n      }\n    },\n\n    /**\r\n    * Get the deposit history\r\n    * @param {function} callback - the callback function\r\n    * @param {object} params - additional params\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    depositHistory: function (callback, params = {}) {\n      if (typeof params === 'string') params = {\n        asset: params\n      }; // Support 'asset' (string) or optional parameters (object)\n\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          signedRequest(wapi + 'v3/depositHistory.html', params, callback);\n        });\n      } else {\n        signedRequest(wapi + 'v3/depositHistory.html', params, callback);\n      }\n    },\n\n    /**\r\n    * Get the deposit history for given asset\r\n    * @param {string} asset - the asset\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    depositAddress: function (asset, callback) {\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          signedRequest(wapi + 'v3/depositAddress.html', {\n            asset: asset\n          }, callback);\n        });\n      } else {\n        signedRequest(wapi + 'v3/depositAddress.html', {\n          asset: asset\n        }, callback);\n      }\n    },\n\n    /**\r\n    * Get the account status\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    accountStatus: function (callback) {\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          signedRequest(wapi + 'v3/accountStatus.html', {}, callback);\n        });\n      } else {\n        signedRequest(wapi + 'v3/accountStatus.html', {}, callback);\n      }\n    },\n\n    /**\r\n    * Get the trade fee\r\n    * @param {function} callback - the callback function\r\n    * @param {string} symbol (optional)\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    tradeFee: function (callback, symbol = false) {\n      let params = symbol ? {\n        symbol: symbol\n      } : {};\n\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          signedRequest(wapi + 'v3/tradeFee.html', params, callback);\n        });\n      } else {\n        signedRequest(wapi + 'v3/tradeFee.html', params, callback);\n      }\n    },\n\n    /**\r\n    * Fetch asset detail (minWithdrawAmount, depositStatus, withdrawFee, withdrawStatus, depositTip)\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    assetDetail: function (callback) {\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          signedRequest(wapi + 'v3/assetDetail.html', {}, callback);\n        });\n      } else {\n        signedRequest(wapi + 'v3/assetDetail.html', {}, callback);\n      }\n    },\n\n    /**\r\n    * Get the account\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    account: function (callback) {\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          signedRequest(base + 'v3/account', {}, callback);\n        });\n      } else {\n        signedRequest(base + 'v3/account', {}, callback);\n      }\n    },\n\n    /**\r\n    * Get the balance data\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    balance: function (callback) {\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          signedRequest(base + 'v3/account', {}, function (error, data) {\n            callback(error, balanceData(data));\n          });\n        });\n      } else {\n        signedRequest(base + 'v3/account', {}, function (error, data) {\n          callback(error, balanceData(data));\n        });\n      }\n    },\n\n    /**\r\n    * Get trades for a given symbol\r\n    * @param {string} symbol - the symbol\r\n    * @param {function} callback - the callback function\r\n    * @param {object} options - additional options\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    trades: (symbol, callback, options = {}) => {\n      let parameters = Object.assign({\n        symbol: symbol\n      }, options);\n\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          signedRequest(base + 'v3/myTrades', parameters, function (error, data) {\n            return callback.call(this, error, data, symbol);\n          });\n        });\n      } else {\n        signedRequest(base + 'v3/myTrades', parameters, function (error, data) {\n          return callback.call(this, error, data, symbol);\n        });\n      }\n    },\n\n    /**\r\n    * Tell api to use the server time to offset time indexes\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    useServerTime: (callback = false) => {\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          publicRequest(base + 'v3/time', {}, function (error, response) {\n            if (!error) {\n              Binance.info.timeOffset = response.serverTime - new Date().getTime(); //Binance.options.log(\"server time set: \", response.serverTime, Binance.info.timeOffset);\n            }\n\n            callback(error, response);\n          });\n        });\n      } else {\n        publicRequest(base + 'v3/time', {}, function (error, response) {\n          if (!error) {\n            Binance.info.timeOffset = response.serverTime - new Date().getTime(); //Binance.options.log(\"server time set: \", response.serverTime, Binance.info.timeOffset);\n          }\n\n          callback(error, response);\n        });\n      }\n    },\n\n    /**\r\n    * Get Binance server time\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    time: function (callback) {\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          publicRequest(base + 'v3/time', {}, callback);\n        });\n      } else {\n        publicRequest(base + 'v3/time', {}, callback);\n      }\n    },\n\n    /**\r\n    * Get agg trades for given symbol\r\n    * @param {string} symbol - the symbol\r\n    * @param {object} options - additional optoins\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    aggTrades: function (symbol, options = {}, callback = false) {\n      //fromId startTime endTime limit\n      let parameters = Object.assign({\n        symbol\n      }, options);\n\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          publicRequest(base + 'v3/aggTrades', parameters, callback);\n        });\n      } else {\n        publicRequest(base + 'v3/aggTrades', parameters, callback);\n      }\n    },\n\n    /**\r\n    * Get the recent trades\r\n    * @param {string} symbol - the symbol\r\n    * @param {function} callback - the callback function\r\n    * @param {int} limit - limit the number of items returned\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    recentTrades: function (symbol, callback, limit = 500) {\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          marketRequest(base + 'v1/trades', {\n            symbol: symbol,\n            limit: limit\n          }, callback);\n        });\n      } else {\n        marketRequest(base + 'v1/trades', {\n          symbol: symbol,\n          limit: limit\n        }, callback);\n      }\n    },\n\n    /**\r\n    * Get the historical trade info\r\n    * @param {string} symbol - the symbol\r\n    * @param {function} callback - the callback function\r\n    * @param {int} limit - limit the number of items returned\r\n    * @param {int} fromId - from this id\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    historicalTrades: function (symbol, callback, limit = 500, fromId = false) {\n      let parameters = {\n        symbol: symbol,\n        limit: limit\n      };\n      if (fromId) parameters.fromId = fromId;\n\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          marketRequest(base + 'v3/historicalTrades', parameters, callback);\n        });\n      } else {\n        marketRequest(base + 'v3/historicalTrades', parameters, callback);\n      }\n    },\n\n    /**\r\n    * Convert chart data to highstock array [timestamp,open,high,low,close]\r\n    * @param {object} chart - the chart\r\n    * @param {boolean} include_volume - to include the volume or not\r\n    * @return {array} - an array\r\n    */\n    highstock: function (chart, include_volume = false) {\n      let array = [];\n\n      for (let timestamp in chart) {\n        let obj = chart[timestamp];\n        let line = [Number(timestamp), parseFloat(obj.open), parseFloat(obj.high), parseFloat(obj.low), parseFloat(obj.close)];\n        if (include_volume) line.push(parseFloat(obj.volume));\n        array.push(line);\n      }\n\n      return array;\n    },\n\n    /**\r\n    * Populates OHLC information\r\n    * @param {object} chart - the chart\r\n    * @return {object} - object with candle information\r\n    */\n    ohlc: function (chart) {\n      let open = [],\n          high = [],\n          low = [],\n          close = [],\n          volume = [];\n\n      for (let timestamp in chart) {\n        //Binance.ohlc[symbol][interval]\n        let obj = chart[timestamp];\n        open.push(parseFloat(obj.open));\n        high.push(parseFloat(obj.high));\n        low.push(parseFloat(obj.low));\n        close.push(parseFloat(obj.close));\n        volume.push(parseFloat(obj.volume));\n      }\n\n      return {\n        open: open,\n        high: high,\n        low: low,\n        close: close,\n        volume: volume\n      };\n    },\n\n    /**\r\n    * Gets the candles information for a given symbol\r\n    * intervals: 1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,1M\r\n    * @param {string} symbol - the symbol\r\n    * @param {function} interval - the callback function\r\n    * @param {function} callback - the callback function\r\n    * @param {object} options - additional options\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    candlesticks: function (symbol, interval = '5m', callback = false, options = {\n      limit: 500\n    }) {\n      let params = Object.assign({\n        symbol: symbol,\n        interval: interval\n      }, options);\n\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          publicRequest(base + 'v3/klines', params, function (error, data) {\n            return callback.call(this, error, data, symbol);\n          });\n        });\n      } else {\n        publicRequest(base + 'v3/klines', params, function (error, data) {\n          return callback.call(this, error, data, symbol);\n        });\n      }\n    },\n\n    /**\r\n    * Queries the public api\r\n    * @param {string} url - the public api endpoint\r\n    * @param {object} data - the data to send\r\n    * @param {function} callback - the callback function\r\n    * @param {string} method - the http method\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    publicRequest: function (url, data, callback, method = 'GET') {\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          publicRequest(url, data, callback, method);\n        });\n      } else {\n        publicRequest(url, data, callback, method);\n      }\n    },\n\n    /**\r\n     * Queries the futures API by default\r\n     * @param {string} url - the signed api endpoint\r\n     * @param {object} data - the data to send\r\n     * @param {object} flags - type of request, authentication method and endpoint url\r\n     */\n    promiseRequest: function (url, data = {}, flags = {}) {\n      return promiseRequest(url, data, flags);\n    },\n\n    /**\r\n    * Queries the signed api\r\n    * @param {string} url - the signed api endpoint\r\n    * @param {object} data - the data to send\r\n    * @param {function} callback - the callback function\r\n    * @param {string} method - the http method\r\n    * @param {boolean} noDataInSignature - Prevents data from being added to signature\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    signedRequest: function (url, data, callback, method = 'GET', noDataInSignature = false) {\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          signedRequest(url, data, callback, method, noDataInSignature);\n        });\n      } else {\n        signedRequest(url, data, callback, method, noDataInSignature);\n      }\n    },\n\n    /**\r\n    * Gets the market asset of given symbol\r\n    * @param {string} symbol - the public api endpoint\r\n    * @return {undefined}\r\n    */\n    getMarket: function (symbol) {\n      if (symbol.endsWith('BTC')) return 'BTC';else if (symbol.endsWith('ETH')) return 'ETH';else if (symbol.endsWith('BNB')) return 'BNB';else if (symbol.endsWith('XRP')) return 'XRP';else if (symbol.endsWith('PAX')) return 'PAX';else if (symbol.endsWith('USDT')) return 'USDT';else if (symbol.endsWith('USDC')) return 'USDC';else if (symbol.endsWith('USDS')) return 'USDS';else if (symbol.endsWith('TUSD')) return 'TUSD';\n    },\n\n    /**\r\n    * Get the account binance lending information\r\n    * @param {function} callback - the callback function\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    lending: async (params = {}) => {\n      return promiseRequest('v1/lending/union/account', params, {\n        base: sapi,\n        type: 'SIGNED'\n      });\n    },\n    //** Futures methods */\n    futuresPing: async (params = {}) => {\n      return promiseRequest('v1/ping', params, {\n        base: fapi\n      });\n    },\n    futuresTime: async (params = {}) => {\n      return promiseRequest('v1/time', params, {\n        base: fapi\n      }).then(r => r.serverTime);\n    },\n    futuresExchangeInfo: async () => {\n      return promiseRequest('v1/exchangeInfo', {}, {\n        base: fapi\n      });\n    },\n    futuresPrices: async (params = {}) => {\n      let data = await promiseRequest('v1/ticker/price', params, {\n        base: fapi\n      });\n      return data.reduce((out, i) => (out[i.symbol] = i.price, out), {});\n    },\n    futuresDaily: async (symbol = false, params = {}) => {\n      if (symbol) params.symbol = symbol;\n      let data = await promiseRequest('v1/ticker/24hr', params, {\n        base: fapi\n      });\n      return symbol ? data : data.reduce((out, i) => (out[i.symbol] = i, out), {});\n    },\n    futuresOpenInterest: async symbol => {\n      return promiseRequest('v1/openInterest', {\n        symbol\n      }, {\n        base: fapi\n      }).then(r => r.openInterest);\n    },\n    futuresCandles: async (symbol, interval = \"30m\", params = {}) => {\n      params.symbol = symbol;\n      params.interval = interval;\n      return promiseRequest('v1/klines', params, {\n        base: fapi\n      });\n    },\n    futuresMarkPrice: async (symbol = false) => {\n      return promiseRequest('v1/premiumIndex', symbol ? {\n        symbol\n      } : {}, {\n        base: fapi\n      });\n    },\n    futuresTrades: async (symbol, params = {}) => {\n      params.symbol = symbol;\n      return promiseRequest('v1/trades', params, {\n        base: fapi\n      });\n    },\n    futuresHistoricalTrades: async (symbol, params = {}) => {\n      params.symbol = symbol;\n      return promiseRequest('v1/historicalTrades', params, {\n        base: fapi,\n        type: 'MARKET_DATA'\n      });\n    },\n    futuresAggTrades: async (symbol, params = {}) => {\n      params.symbol = symbol;\n      return promiseRequest('v1/aggTrades', params, {\n        base: fapi\n      });\n    },\n    futuresForceOrders: async (params = {}) => {\n      return promiseRequest('v1/forceOrders', params, {\n        base: fapi,\n        type: 'SIGNED'\n      });\n    },\n    futuresDeleverageQuantile: async (params = {}) => {\n      return promiseRequest('v1/adlQuantile', params, {\n        base: fapi,\n        type: 'SIGNED'\n      });\n    },\n    futuresUserTrades: async (symbol, params = {}) => {\n      params.symbol = symbol;\n      return promiseRequest('v1/userTrades', params, {\n        base: fapi,\n        type: 'SIGNED'\n      });\n    },\n    futuresGetDataStream: async (params = {}) => {\n      //A User Data Stream listenKey is valid for 60 minutes after creation. setInterval\n      return promiseRequest('v1/listenKey', params, {\n        base: fapi,\n        type: 'SIGNED',\n        method: 'POST'\n      });\n    },\n    futuresKeepDataStream: async (params = {}) => {\n      return promiseRequest('v1/listenKey', params, {\n        base: fapi,\n        type: 'SIGNED',\n        method: 'PUT'\n      });\n    },\n    futuresCloseDataStream: async (params = {}) => {\n      return promiseRequest('v1/listenKey', params, {\n        base: fapi,\n        type: 'SIGNED',\n        method: 'DELETE'\n      });\n    },\n    futuresLiquidationOrders: async (symbol = false, params = {}) => {\n      if (symbol) params.symbol = symbol;\n      return promiseRequest('v1/allForceOrders', params, {\n        base: fapi\n      });\n    },\n    futuresPositionRisk: async (params = {}) => {\n      return promiseRequest('v2/positionRisk', params, {\n        base: fapi,\n        type: 'SIGNED'\n      });\n    },\n    futuresFundingRate: async (symbol, params = {}) => {\n      params.symbol = symbol;\n      return promiseRequest('v1/fundingRate', params, {\n        base: fapi\n      });\n    },\n    futuresLeverageBracket: async (symbol = false, params = {}) => {\n      if (symbol) params.symbol = symbol;\n      return promiseRequest('v1/leverageBracket', params, {\n        base: fapi,\n        type: 'USER_DATA'\n      });\n    },\n    futuresTradingStatus: async (symbol = false, params = {}) => {\n      if (symbol) params.symbol = symbol;\n      return promiseRequest('v1/apiTradingStatus', params, {\n        base: fapi,\n        type: 'USER_DATA'\n      });\n    },\n    futuresCommissionRate: async (symbol = false, params = {}) => {\n      if (symbol) params.symbol = symbol;\n      return promiseRequest('v1/commissionRate', params, {\n        base: fapi,\n        type: 'USER_DATA'\n      });\n    },\n    // leverage 1 to 125\n    futuresLeverage: async (symbol, leverage, params = {}) => {\n      params.symbol = symbol;\n      params.leverage = leverage;\n      return promiseRequest('v1/leverage', params, {\n        base: fapi,\n        method: 'POST',\n        type: 'SIGNED'\n      });\n    },\n    // ISOLATED, CROSSED\n    futuresMarginType: async (symbol, marginType, params = {}) => {\n      params.symbol = symbol;\n      params.marginType = marginType;\n      return promiseRequest('v1/marginType', params, {\n        base: fapi,\n        method: 'POST',\n        type: 'SIGNED'\n      });\n    },\n    // type: 1: Add postion margin2: Reduce postion margin\n    futuresPositionMargin: async (symbol, amount, type = 1, params = {}) => {\n      params.symbol = symbol;\n      params.amount = amount;\n      params.type = type;\n      return promiseRequest('v1/positionMargin', params, {\n        base: fapi,\n        method: 'POST',\n        type: 'SIGNED'\n      });\n    },\n    futuresPositionMarginHistory: async (symbol, params = {}) => {\n      params.symbol = symbol;\n      return promiseRequest('v1/positionMargin/history', params, {\n        base: fapi,\n        type: 'SIGNED'\n      });\n    },\n    futuresIncome: async (params = {}) => {\n      return promiseRequest('v1/income', params, {\n        base: fapi,\n        type: 'SIGNED'\n      });\n    },\n    futuresBalance: async (params = {}) => {\n      return promiseRequest('v2/balance', params, {\n        base: fapi,\n        type: 'SIGNED'\n      });\n    },\n    futuresAccount: async (params = {}) => {\n      return promiseRequest('v2/account', params, {\n        base: fapi,\n        type: 'SIGNED'\n      });\n    },\n    futuresDepth: async (symbol, params = {}) => {\n      params.symbol = symbol;\n      return promiseRequest('v1/depth', params, {\n        base: fapi\n      });\n    },\n    futuresQuote: async (symbol = false, params = {}) => {\n      if (symbol) params.symbol = symbol; //let data = await promiseRequest( 'v1/ticker/bookTicker', params, {base:fapi} );\n      //return data.reduce((out, i) => ((out[i.symbol] = i), out), {}),\n\n      let data = await promiseRequest('v1/ticker/bookTicker', params, {\n        base: fapi\n      });\n      return symbol ? data : data.reduce((out, i) => (out[i.symbol] = i, out), {});\n    },\n    futuresBuy: async (symbol, quantity, price, params = {}) => {\n      return futuresOrder('BUY', symbol, quantity, price, params);\n    },\n    futuresSell: async (symbol, quantity, price, params = {}) => {\n      return futuresOrder('SELL', symbol, quantity, price, params);\n    },\n    futuresMarketBuy: async (symbol, quantity, params = {}) => {\n      return futuresOrder('BUY', symbol, quantity, false, params);\n    },\n    futuresMarketSell: async (symbol, quantity, params = {}) => {\n      return futuresOrder('SELL', symbol, quantity, false, params);\n    },\n    futuresOrder,\n    // side symbol quantity [price] [params]\n    futuresOrderStatus: async (symbol, params = {}) => {\n      // Either orderId or origClientOrderId must be sent\n      params.symbol = symbol;\n      return promiseRequest('v1/order', params, {\n        base: fapi,\n        type: 'SIGNED'\n      });\n    },\n    futuresCancel: async (symbol, params = {}) => {\n      // Either orderId or origClientOrderId must be sent\n      params.symbol = symbol;\n      return promiseRequest('v1/order', params, {\n        base: fapi,\n        type: 'SIGNED',\n        method: 'DELETE'\n      });\n    },\n    futuresCancelAll: async (symbol, params = {}) => {\n      params.symbol = symbol;\n      return promiseRequest('v1/allOpenOrders', params, {\n        base: fapi,\n        type: 'SIGNED',\n        method: 'DELETE'\n      });\n    },\n    futuresCountdownCancelAll: async (symbol, countdownTime = 0, params = {}) => {\n      params.symbol = symbol;\n      params.countdownTime = countdownTime;\n      return promiseRequest('v1/countdownCancelAll', params, {\n        base: fapi,\n        type: 'SIGNED',\n        method: 'POST'\n      });\n    },\n    futuresOpenOrders: async (symbol = false, params = {}) => {\n      if (symbol) params.symbol = symbol;\n      return promiseRequest('v1/openOrders', params, {\n        base: fapi,\n        type: 'SIGNED'\n      });\n    },\n    futuresAllOrders: async (symbol = false, params = {}) => {\n      // Get all account orders; active, canceled, or filled.\n      if (symbol) params.symbol = symbol;\n      return promiseRequest('v1/allOrders', params, {\n        base: fapi,\n        type: 'SIGNED'\n      });\n    },\n    futuresPositionSideDual: async (params = {}) => {\n      return promiseRequest('v1/positionSide/dual', params, {\n        base: fapi,\n        type: 'SIGNED'\n      });\n    },\n    futuresChangePositionSideDual: async (dualSidePosition, params = {}) => {\n      params.dualSidePosition = dualSidePosition;\n      return promiseRequest('v1/positionSide/dual', params, {\n        base: fapi,\n        type: 'SIGNED',\n        method: 'POST'\n      });\n    },\n    futuresTransferAsset: async (asset, amount, type) => {\n      let params = Object.assign({\n        asset,\n        amount,\n        type\n      });\n      return promiseRequest('v1/futures/transfer', params, {\n        base: sapi,\n        type: 'SIGNED',\n        method: 'POST'\n      });\n    },\n    futuresHistDataId: async (symbol = false, params = {}) => {\n      if (symbol) params.symbol = symbol;\n      return promiseRequest('v1/futuresHistDataId', params, {\n        base: sapi,\n        type: 'SIGNED',\n        method: 'POST'\n      });\n    },\n    futuresDownloadLink: async downloadId => {\n      return promiseRequest('v1/downloadLink', {\n        downloadId\n      }, {\n        base: sapi,\n        type: 'SIGNED'\n      });\n    },\n    // futures websockets support: ticker bookTicker miniTicker aggTrade markPrice\n\n    /* TODO: https://binance-docs.github.io/apidocs/futures/en/#change-log\r\n    Cancel multiple orders DELETE /fapi/v1/batchOrders\r\n    New Future Account Transfer POST https://api.binance.com/sapi/v1/futures/transfer\r\n    Get Postion Margin Change History (TRADE)\r\n      wss://fstream.binance.com/ws/<listenKey>\r\n    Diff. Book Depth Streams (250ms, 100ms, or realtime): <symbol>@depth OR <symbol>@depth@100ms OR <symbol>@depth@0ms\r\n    Partial Book Depth Streams (5, 10, 20): <symbol>@depth<levels> OR <symbol>@depth<levels>@100ms\r\n    All Market Liquidation Order Streams: !forceOrder@arr\r\n    Liquidation Order Streams for specific symbol: <symbol>@forceOrder\r\n    Chart data (250ms): <symbol>@kline_<interval>\r\n    SUBSCRIBE, UNSUBSCRIBE, LIST_SUBSCRIPTIONS, SET_PROPERTY, GET_PROPERTY\r\n    Live Subscribing/Unsubscribing to streams: requires sending futures subscription id when connecting\r\n    futuresSubscriptions { \"method\": \"LIST_SUBSCRIPTIONS\", \"id\": 1 }\r\n    futuresUnsubscribe { \"method\": \"UNSUBSCRIBE\", \"params\": [ \"btcusdt@depth\" ], \"id\": 1 }\r\n    futures depthCache\r\n    */\n\n    /*\r\n    const futuresOrder = (side, symbol, quantity, price = 0, flags = {}, callback = false) => {\r\n        let opt = {\r\n            symbol: symbol,\r\n            side: side,\r\n            type: 'LIMIT',\r\n            quantity: quantity\r\n        };\r\n        if (typeof flags.type !== 'undefined') opt.type = flags.type;\r\n        if (opt.type.includes('LIMIT')) {\r\n            opt.price = price;\r\n            opt.timeInForce = 'GTC';\r\n        }\r\n        if (typeof flags.timeInForce !== 'undefined') opt.timeInForce = flags.timeInForce;\r\n        signedRequest(`${fapi}v1/order`, opt, function (error, response) {\r\n            if (!response) {\r\n                if (callback) return callback(error, response);\r\n                else return Binance.options.log('futuresOrder error:', error);\r\n            }\r\n            if (callback) return callback(error, response);\r\n            else return Binance.options.log(`futuresOrder ${side} (${symbol},${quantity},${price})`, response);\r\n        }, 'POST');\r\n    };*/\n    //** Delivery methods */\n    deliveryPing: async (params = {}) => {\n      return promiseRequest('v1/ping', params, {\n        base: dapi\n      });\n    },\n    deliveryTime: async (params = {}) => {\n      return promiseRequest('v1/time', params, {\n        base: dapi\n      }).then(r => r.serverTime);\n    },\n    deliveryExchangeInfo: async () => {\n      return promiseRequest('v1/exchangeInfo', {}, {\n        base: dapi\n      });\n    },\n    deliveryPrices: async (params = {}) => {\n      let data = await promiseRequest('v1/ticker/price', params, {\n        base: dapi\n      });\n      return data.reduce((out, i) => (out[i.symbol] = i.price, out), {});\n    },\n    deliveryDaily: async (symbol = false, params = {}) => {\n      if (symbol) params.symbol = symbol;\n      let data = await promiseRequest('v1/ticker/24hr', params, {\n        base: dapi\n      });\n      return symbol ? data : data.reduce((out, i) => (out[i.symbol] = i, out), {});\n    },\n    deliveryOpenInterest: async symbol => {\n      return promiseRequest('v1/openInterest', {\n        symbol\n      }, {\n        base: dapi\n      }).then(r => r.openInterest);\n    },\n    deliveryCandles: async (symbol, interval = \"30m\", params = {}) => {\n      params.symbol = symbol;\n      params.interval = interval;\n      return promiseRequest('v1/klines', params, {\n        base: dapi\n      });\n    },\n    deliveryContinuousKlines: async (pair, contractType = \"CURRENT_QUARTER\", interval = \"30m\", params = {}) => {\n      params.pair = pair;\n      params.interval = interval;\n      params.contractType = contractType;\n      return promiseRequest('v1/continuousKlines', params, {\n        base: dapi\n      });\n    },\n    deliveryIndexKlines: async (pair, interval = \"30m\", params = {}) => {\n      params.pair = pair;\n      params.interval = interval;\n      return promiseRequest('v1/indexPriceKlines', params, {\n        base: dapi\n      });\n    },\n    deliveryMarkPriceKlines: async (symbol, interval = \"30m\", params = {}) => {\n      params.symbol = symbol;\n      params.interval = interval;\n      return promiseRequest('v1/markPriceKlines', params, {\n        base: dapi\n      });\n    },\n    deliveryMarkPrice: async (symbol = false) => {\n      return promiseRequest('v1/premiumIndex', symbol ? {\n        symbol\n      } : {}, {\n        base: dapi\n      });\n    },\n    deliveryTrades: async (symbol, params = {}) => {\n      params.symbol = symbol;\n      return promiseRequest('v1/trades', params, {\n        base: dapi\n      });\n    },\n    deliveryHistoricalTrades: async (symbol, params = {}) => {\n      params.symbol = symbol;\n      return promiseRequest('v1/historicalTrades', params, {\n        base: dapi,\n        type: 'MARKET_DATA'\n      });\n    },\n    deliveryAggTrades: async (symbol, params = {}) => {\n      params.symbol = symbol;\n      return promiseRequest('v1/aggTrades', params, {\n        base: dapi\n      });\n    },\n    deliveryUserTrades: async (symbol, params = {}) => {\n      params.symbol = symbol;\n      return promiseRequest('v1/userTrades', params, {\n        base: dapi,\n        type: 'SIGNED'\n      });\n    },\n    deliveryGetDataStream: async (params = {}) => {\n      //A User Data Stream listenKey is valid for 60 minutes after creation. setInterval\n      return promiseRequest('v1/listenKey', params, {\n        base: dapi,\n        type: 'SIGNED',\n        method: 'POST'\n      });\n    },\n    deliveryKeepDataStream: async (params = {}) => {\n      return promiseRequest('v1/listenKey', params, {\n        base: dapi,\n        type: 'SIGNED',\n        method: 'PUT'\n      });\n    },\n    deliveryCloseDataStream: async (params = {}) => {\n      return promiseRequest('v1/listenKey', params, {\n        base: dapi,\n        type: 'SIGNED',\n        method: 'DELETE'\n      });\n    },\n    deliveryLiquidationOrders: async (symbol = false, params = {}) => {\n      if (symbol) params.symbol = symbol;\n      return promiseRequest('v1/allForceOrders', params, {\n        base: dapi\n      });\n    },\n    deliveryPositionRisk: async (params = {}) => {\n      return promiseRequest('v1/positionRisk', params, {\n        base: dapi,\n        type: 'SIGNED'\n      });\n    },\n    deliveryLeverageBracket: async (symbol = false, params = {}) => {\n      if (symbol) params.symbol = symbol;\n      return promiseRequest('v1/leverageBracket', params, {\n        base: dapi,\n        type: 'USER_DATA'\n      });\n    },\n    deliveryLeverageBracketSymbols: async (symbol = false, params = {}) => {\n      if (symbol) params.symbol = symbol;\n      return promiseRequest('v2/leverageBracket', params, {\n        base: dapi,\n        type: 'USER_DATA'\n      });\n    },\n    // leverage 1 to 125\n    deliveryLeverage: async (symbol, leverage, params = {}) => {\n      params.symbol = symbol;\n      params.leverage = leverage;\n      return promiseRequest('v1/leverage', params, {\n        base: dapi,\n        method: 'POST',\n        type: 'SIGNED'\n      });\n    },\n    // ISOLATED, CROSSED\n    deliveryMarginType: async (symbol, marginType, params = {}) => {\n      params.symbol = symbol;\n      params.marginType = marginType;\n      return promiseRequest('v1/marginType', params, {\n        base: dapi,\n        method: 'POST',\n        type: 'SIGNED'\n      });\n    },\n    // type: 1: Add postion margin2: Reduce postion margin\n    deliveryPositionMargin: async (symbol, amount, type = 1, params = {}) => {\n      params.symbol = symbol;\n      params.amount = amount;\n      params.type = type;\n      return promiseRequest('v1/positionMargin', params, {\n        base: dapi,\n        method: 'POST',\n        type: 'SIGNED'\n      });\n    },\n    deliveryPositionMarginHistory: async (symbol, params = {}) => {\n      params.symbol = symbol;\n      return promiseRequest('v1/positionMargin/history', params, {\n        base: dapi,\n        type: 'SIGNED'\n      });\n    },\n    deliveryIncome: async (params = {}) => {\n      return promiseRequest('v1/income', params, {\n        base: dapi,\n        type: 'SIGNED'\n      });\n    },\n    deliveryBalance: async (params = {}) => {\n      return promiseRequest('v1/balance', params, {\n        base: dapi,\n        type: 'SIGNED'\n      });\n    },\n    deliveryAccount: async (params = {}) => {\n      return promiseRequest('v1/account', params, {\n        base: dapi,\n        type: 'SIGNED'\n      });\n    },\n    deliveryDepth: async (symbol, params = {}) => {\n      params.symbol = symbol;\n      return promiseRequest('v1/depth', params, {\n        base: dapi\n      });\n    },\n    deliveryQuote: async (symbol = false, params = {}) => {\n      if (symbol) params.symbol = symbol; //let data = await promiseRequest( 'v1/ticker/bookTicker', params, {base:dapi} );\n      //return data.reduce((out, i) => ((out[i.symbol] = i), out), {}),\n\n      let data = await promiseRequest('v1/ticker/bookTicker', params, {\n        base: dapi\n      });\n      return symbol ? data : data.reduce((out, i) => (out[i.symbol] = i, out), {});\n    },\n    deliveryBuy: async (symbol, quantity, price, params = {}) => {\n      return deliveryOrder('BUY', symbol, quantity, price, params);\n    },\n    deliverySell: async (symbol, quantity, price, params = {}) => {\n      return deliveryOrder('SELL', symbol, quantity, price, params);\n    },\n    deliveryMarketBuy: async (symbol, quantity, params = {}) => {\n      return deliveryOrder('BUY', symbol, quantity, false, params);\n    },\n    deliveryMarketSell: async (symbol, quantity, params = {}) => {\n      return deliveryOrder('SELL', symbol, quantity, false, params);\n    },\n    deliveryOrder,\n    // side symbol quantity [price] [params]\n    deliveryOrderStatus: async (symbol, params = {}) => {\n      // Either orderId or origClientOrderId must be sent\n      params.symbol = symbol;\n      return promiseRequest('v1/order', params, {\n        base: dapi,\n        type: 'SIGNED'\n      });\n    },\n    deliveryCancel: async (symbol, params = {}) => {\n      // Either orderId or origClientOrderId must be sent\n      params.symbol = symbol;\n      return promiseRequest('v1/order', params, {\n        base: dapi,\n        type: 'SIGNED',\n        method: 'DELETE'\n      });\n    },\n    deliveryCancelAll: async (symbol, params = {}) => {\n      params.symbol = symbol;\n      return promiseRequest('v1/allOpenOrders', params, {\n        base: dapi,\n        type: 'SIGNED',\n        method: 'DELETE'\n      });\n    },\n    deliveryCountdownCancelAll: async (symbol, countdownTime = 0, params = {}) => {\n      params.symbol = symbol;\n      params.countdownTime = countdownTime;\n      return promiseRequest('v1/countdownCancelAll', params, {\n        base: dapi,\n        type: 'SIGNED',\n        method: 'POST'\n      });\n    },\n    deliveryOpenOrders: async (symbol = false, params = {}) => {\n      if (symbol) params.symbol = symbol;\n      return promiseRequest('v1/openOrders', params, {\n        base: dapi,\n        type: 'SIGNED'\n      });\n    },\n    deliveryAllOrders: async (symbol = false, params = {}) => {\n      // Get all account orders; active, canceled, or filled.\n      if (symbol) params.symbol = symbol;\n      return promiseRequest('v1/allOrders', params, {\n        base: dapi,\n        type: 'SIGNED'\n      });\n    },\n    deliveryPositionSideDual: async (params = {}) => {\n      return promiseRequest('v1/positionSide/dual', params, {\n        base: dapi,\n        type: 'SIGNED'\n      });\n    },\n    deliveryChangePositionSideDual: async (dualSidePosition, params = {}) => {\n      params.dualSidePosition = dualSidePosition;\n      return promiseRequest('v1/positionSide/dual', params, {\n        base: dapi,\n        type: 'SIGNED',\n        method: 'POST'\n      });\n    },\n    //** Margin methods */\n\n    /**\r\n     * Creates an order\r\n     * @param {string} side - BUY or SELL\r\n     * @param {string} symbol - the symbol to buy\r\n     * @param {numeric} quantity - the quantity required\r\n     * @param {numeric} price - the price to pay for each unit\r\n     * @param {object} flags - additional buy order flags\r\n     * @param {function} callback - the callback function\r\n     * @param {string} isIsolated - the isolate margin option\r\n     * @return {undefined}\r\n     */\n    mgOrder: function (side, symbol, quantity, price, flags = {}, callback = false, isIsolated = 'FALSE') {\n      marginOrder(side, symbol, quantity, price, { ...flags,\n        isIsolated\n      }, callback);\n    },\n\n    /**\r\n     * Creates a buy order\r\n     * @param {string} symbol - the symbol to buy\r\n     * @param {numeric} quantity - the quantity required\r\n     * @param {numeric} price - the price to pay for each unit\r\n     * @param {object} flags - additional buy order flags\r\n     * @param {function} callback - the callback function\r\n     * @param {string} isIsolated - the isolate margin option\r\n     * @return {undefined}\r\n     */\n    mgBuy: function (symbol, quantity, price, flags = {}, callback = false, isIsolated = 'FALSE') {\n      marginOrder('BUY', symbol, quantity, price, { ...flags,\n        isIsolated\n      }, callback);\n    },\n\n    /**\r\n     * Creates a sell order\r\n     * @param {string} symbol - the symbol to sell\r\n     * @param {numeric} quantity - the quantity required\r\n     * @param {numeric} price - the price to sell each unit for\r\n     * @param {object} flags - additional order flags\r\n     * @param {function} callback - the callback function\r\n     * @param {string} isIsolated - the isolate margin option\r\n     * @return {undefined}\r\n     */\n    mgSell: function (symbol, quantity, price, flags = {}, callback = false, isIsolated = 'FALSE') {\n      marginOrder('SELL', symbol, quantity, price, { ...flags,\n        isIsolated\n      }, callback);\n    },\n\n    /**\r\n     * Creates a market buy order\r\n     * @param {string} symbol - the symbol to buy\r\n     * @param {numeric} quantity - the quantity required\r\n     * @param {object} flags - additional buy order flags\r\n     * @param {function} callback - the callback function\r\n     * @param {string} isIsolated - the isolate margin option\r\n     * @return {undefined}\r\n     */\n    mgMarketBuy: function (symbol, quantity, flags = {\n      type: 'MARKET'\n    }, callback = false, isIsolated = 'FALSE') {\n      if (typeof flags === 'function') {\n        // Accept callback as third parameter\n        callback = flags;\n        flags = {\n          type: 'MARKET'\n        };\n      }\n\n      if (typeof flags.type === 'undefined') flags.type = 'MARKET';\n      marginOrder('BUY', symbol, quantity, 0, { ...flags,\n        isIsolated\n      }, callback);\n    },\n\n    /**\r\n     * Creates a market sell order\r\n     * @param {string} symbol - the symbol to sell\r\n     * @param {numeric} quantity - the quantity required\r\n     * @param {object} flags - additional sell order flags\r\n     * @param {function} callback - the callback function\r\n     * @param {string} isIsolated - the isolate margin option\r\n     * @return {undefined}\r\n     */\n    mgMarketSell: function (symbol, quantity, flags = {\n      type: 'MARKET'\n    }, callback = false, isIsolated = 'FALSE') {\n      if (typeof flags === 'function') {\n        // Accept callback as third parameter\n        callback = flags;\n        flags = {\n          type: 'MARKET'\n        };\n      }\n\n      if (typeof flags.type === 'undefined') flags.type = 'MARKET';\n      marginOrder('SELL', symbol, quantity, 0, { ...flags,\n        isIsolated\n      }, callback);\n    },\n\n    /**\r\n     * Cancels an order\r\n     * @param {string} symbol - the symbol to cancel\r\n     * @param {string} orderid - the orderid to cancel\r\n     * @param {function} callback - the callback function\r\n     * @return {undefined}\r\n     */\n    mgCancel: function (symbol, orderid, callback = false, isIsolated = 'FALSE') {\n      signedRequest(sapi + 'v1/margin/order', {\n        symbol: symbol,\n        orderId: orderid,\n        isIsolated\n      }, function (error, data) {\n        if (callback) return callback.call(this, error, data, symbol);\n      }, 'DELETE');\n    },\n\n    /**\r\n    * Gets all order of a given symbol\r\n    * @param {string} symbol - the symbol\r\n    * @param {function} callback - the callback function\r\n    * @param {object} options - additional options\r\n    * @return {promise or undefined} - omitting the callback returns a promise\r\n    */\n    mgAllOrders: function (symbol, callback, options = {}) {\n      let parameters = Object.assign({\n        symbol: symbol\n      }, options);\n\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          callback = (error, response) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(response);\n            }\n          };\n\n          signedRequest(sapi + 'v1/margin/allOrders', parameters, function (error, data) {\n            return callback.call(this, error, data, symbol);\n          });\n        });\n      } else {\n        signedRequest(sapi + 'v1/margin/allOrders', parameters, function (error, data) {\n          return callback.call(this, error, data, symbol);\n        });\n      }\n    },\n\n    /**\r\n     * Gets the status of an order\r\n     * @param {string} symbol - the symbol to check\r\n     * @param {string} orderid - the orderid to check\r\n     * @param {function} callback - the callback function\r\n     * @param {object} flags - any additional flags\r\n     * @return {undefined}\r\n     */\n    mgOrderStatus: function (symbol, orderid, callback, flags = {}) {\n      let parameters = Object.assign({\n        symbol: symbol,\n        orderId: orderid\n      }, flags);\n      signedRequest(sapi + 'v1/margin/order', parameters, function (error, data) {\n        if (callback) return callback.call(this, error, data, symbol);\n      });\n    },\n\n    /**\r\n     * Gets open orders\r\n     * @param {string} symbol - the symbol to get\r\n     * @param {function} callback - the callback function\r\n     * @return {undefined}\r\n     */\n    mgOpenOrders: function (symbol, callback) {\n      let parameters = symbol ? {\n        symbol: symbol\n      } : {};\n      signedRequest(sapi + 'v1/margin/openOrders', parameters, function (error, data) {\n        return callback.call(this, error, data, symbol);\n      });\n    },\n\n    /**\r\n     * Cancels all order of a given symbol\r\n     * @param {string} symbol - the symbol to cancel all orders for\r\n     * @param {function} callback - the callback function\r\n     * @return {undefined}\r\n     */\n    mgCancelOrders: function (symbol, callback = false) {\n      signedRequest(sapi + 'v1/margin/openOrders', {\n        symbol: symbol\n      }, function (error, json) {\n        if (json.length === 0) {\n          if (callback) return callback.call(this, 'No orders present for this symbol', {}, symbol);\n        }\n\n        for (let obj of json) {\n          let quantity = obj.origQty - obj.executedQty;\n          Binance.options.log('cancel order: ' + obj.side + ' ' + symbol + ' ' + quantity + ' @ ' + obj.price + ' #' + obj.orderId);\n          signedRequest(sapi + 'v1/margin/order', {\n            symbol: symbol,\n            orderId: obj.orderId\n          }, function (error, data) {\n            if (callback) return callback.call(this, error, data, symbol);\n          }, 'DELETE');\n        }\n      });\n    },\n\n    /**\r\n     * Transfer from main account to margin account\r\n     * @param {string} asset - the asset\r\n     * @param {number} amount - the asset\r\n     * @param {function} callback - the callback function\r\n     * @param {object} options - additional options\r\n     * @return {undefined}\r\n     */\n    mgTransferMainToMargin: function (asset, amount, callback) {\n      let parameters = Object.assign({\n        asset: asset,\n        amount: amount,\n        type: 1\n      });\n      signedRequest(sapi + 'v1/margin/transfer', parameters, function (error, data) {\n        if (callback) return callback(error, data);\n      }, 'POST');\n    },\n\n    /**\r\n     * Transfer from margin account to main account\r\n     * @param {string} asset - the asset\r\n     * @param {number} amount - the asset\r\n     * @param {function} callback - the callback function\r\n     * @return {undefined}\r\n     */\n    mgTransferMarginToMain: function (asset, amount, callback) {\n      let parameters = Object.assign({\n        asset: asset,\n        amount: amount,\n        type: 2\n      });\n      signedRequest(sapi + 'v1/margin/transfer', parameters, function (error, data) {\n        if (callback) return callback(error, data);\n      }, 'POST');\n    },\n\n    /**\r\n    * Transfer from main account to delivery account\r\n    * @param {string} asset - the asset\r\n    * @param {number} amount - the asset\r\n    * @param {function} callback - the callback function (optionnal)\r\n    * @param {object} options - additional options\r\n    * @return {undefined}\r\n    */\n    transferMainToFutures: (asset, amount, callback) => transferBetweenMainAndFutures(asset, amount, 1, callback),\n\n    /**\r\n    * Transfer from delivery account to main account\r\n    * @param {string} asset - the asset\r\n    * @param {number} amount - the asset\r\n    * @param {function} callback - the callback function (optionnal)\r\n    * @return {undefined}\r\n    */\n    transferFuturesToMain: (asset, amount, callback) => transferBetweenMainAndFutures(asset, amount, 2, callback),\n\n    /**\r\n    * Transfer from main account to delivery account\r\n    * @param {string} asset - the asset\r\n    * @param {number} amount - the asset\r\n    * @param {function} callback - the callback function (optionnal)\r\n    * @param {object} options - additional options\r\n    * @return {undefined}\r\n    */\n    transferMainToDelivery: (asset, amount, callback) => transferBetweenMainAndFutures(asset, amount, 3, callback),\n\n    /**\r\n    * Transfer from delivery account to main account\r\n    * @param {string} asset - the asset\r\n    * @param {number} amount - the asset\r\n    * @param {function} callback - the callback function (optionnal)\r\n    * @return {undefined}\r\n    */\n    transferDeliveryToMain: (asset, amount, callback) => transferBetweenMainAndFutures(asset, amount, 4, callback),\n\n    /**\r\n     * Get maximum transfer-out amount of an asset\r\n     * @param {string} asset - the asset\r\n     * @param {function} callback - the callback function\r\n     * @return {undefined}\r\n     */\n    maxTransferable: function (asset, callback) {\n      signedRequest(sapi + 'v1/margin/maxTransferable', {\n        asset: asset\n      }, function (error, data) {\n        if (callback) return callback(error, data);\n      });\n    },\n\n    /**\r\n     * Margin account borrow/loan\r\n     * @param {string} asset - the asset\r\n     * @param {number} amount - the asset\r\n     * @param {function} callback - the callback function\r\n     * @param {string} isIsolated - the isolated option\r\n     * @param {string} symbol - symbol for isolated margin\r\n     * @return {undefined}\r\n     */\n    mgBorrow: function (asset, amount, callback, isIsolated = 'FALSE', symbol = null) {\n      let parameters = Object.assign({\n        asset: asset,\n        amount: amount\n      });\n      if (isIsolated === 'TRUE' && !symbol) throw new Error('If \"isIsolated\" = \"TRUE\", \"symbol\" must be sent');\n      const isolatedObj = isIsolated === 'TRUE' ? {\n        isIsolated,\n        symbol\n      } : {};\n      signedRequest(sapi + 'v1/margin/loan', { ...parameters,\n        ...isolatedObj\n      }, function (error, data) {\n        if (callback) return callback(error, data);\n      }, 'POST');\n    },\n\n    /**\r\n     * Margin account repay\r\n     * @param {string} asset - the asset\r\n     * @param {number} amount - the asset\r\n     * @param {function} callback - the callback function\r\n     * @param {string} isIsolated - the isolated option\r\n     * @param {string} symbol - symbol for isolated margin\r\n     * @return {undefined}\r\n     */\n    mgRepay: function (asset, amount, callback, isIsolated = 'FALSE', symbol = null) {\n      let parameters = Object.assign({\n        asset: asset,\n        amount: amount\n      });\n      if (isIsolated === 'TRUE' && !symbol) throw new Error('If \"isIsolated\" = \"TRUE\", \"symbol\" must be sent');\n      const isolatedObj = isIsolated === 'TRUE' ? {\n        isIsolated,\n        symbol\n      } : {};\n      signedRequest(sapi + 'v1/margin/repay', { ...parameters,\n        ...isolatedObj\n      }, function (error, data) {\n        if (callback) return callback(error, data);\n      }, 'POST');\n    },\n\n    /**\r\n     * Margin account details\r\n     * @param {function} callback - the callback function\r\n     * @param {boolean} isIsolated - the callback function\r\n     * @return {undefined}\r\n     */\n    mgAccount: function (callback, isIsolated = false) {\n      const endpoint = 'v1/margin' + isIsolated ? '/isolated' : '' + '/account';\n      signedRequest(sapi + endpoint, {}, function (error, data) {\n        if (callback) return callback(error, data);\n      });\n    },\n\n    /**\r\n     * Get maximum borrow amount of an asset\r\n     * @param {string} asset - the asset\r\n     * @param {function} callback - the callback function\r\n     * @return {undefined}\r\n     */\n    maxBorrowable: function (asset, callback) {\n      signedRequest(sapi + 'v1/margin/maxBorrowable', {\n        asset: asset\n      }, function (error, data) {\n        if (callback) return callback(error, data);\n      });\n    },\n    // Futures WebSocket Functions:\n\n    /**\r\n     * Subscribe to a single futures websocket\r\n     * @param {string} url - the futures websocket endpoint\r\n     * @param {function} callback - optional execution callback\r\n     * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}\r\n     * @return {WebSocket} the websocket reference\r\n     */\n    futuresSubscribeSingle: function (url, callback, params = {}) {\n      return futuresSubscribeSingle(url, callback, params);\n    },\n\n    /**\r\n     * Subscribe to a combined futures websocket\r\n     * @param {string} streams - the list of websocket endpoints to connect to\r\n     * @param {function} callback - optional execution callback\r\n     * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}\r\n     * @return {WebSocket} the websocket reference\r\n     */\n    futuresSubscribe: function (streams, callback, params = {}) {\n      return futuresSubscribe(streams, callback, params);\n    },\n\n    /**\r\n     * Returns the known futures websockets subscriptions\r\n     * @return {array} array of futures websocket subscriptions\r\n     */\n    futuresSubscriptions: function () {\n      return Binance.futuresSubscriptions;\n    },\n\n    /**\r\n     * Terminates a futures websocket\r\n     * @param {string} endpoint - the string associated with the endpoint\r\n     * @return {undefined}\r\n     */\n    futuresTerminate: function (endpoint) {\n      if (Binance.options.verbose) Binance.options.log('Futures WebSocket terminating:', endpoint);\n      return futuresTerminate(endpoint);\n    },\n\n    /**\r\n     * Futures WebSocket aggregated trades\r\n     * @param {array/string} symbols - an array or string of symbols to query\r\n     * @param {function} callback - callback function\r\n     * @return {string} the websocket endpoint\r\n     */\n    futuresAggTradeStream: function futuresAggTradeStream(symbols, callback) {\n      let reconnect = () => {\n        if (Binance.options.reconnect) futuresAggTradeStream(symbols, callback);\n      };\n\n      let subscription,\n          cleanCallback = data => callback(fAggTradeConvertData(data));\n\n      if (Array.isArray(symbols)) {\n        if (!isArrayUnique(symbols)) throw Error('futuresAggTradeStream: \"symbols\" cannot contain duplicate elements.');\n        let streams = symbols.map(symbol => symbol.toLowerCase() + '@aggTrade');\n        subscription = futuresSubscribe(streams, cleanCallback, {\n          reconnect\n        });\n      } else {\n        let symbol = symbols;\n        subscription = futuresSubscribeSingle(symbol.toLowerCase() + '@aggTrade', cleanCallback, {\n          reconnect\n        });\n      }\n\n      return subscription.endpoint;\n    },\n\n    /**\r\n     * Futures WebSocket mark price\r\n     * @param {symbol} symbol name or false. can also be a callback\r\n     * @param {function} callback - callback function\r\n     * @param {string} speed - 1 second updates. leave blank for default 3 seconds\r\n     * @return {string} the websocket endpoint\r\n     */\n    futuresMarkPriceStream: function fMarkPriceStream(symbol = false, callback = console.log, speed = '@1s') {\n      if (typeof symbol == 'function') {\n        callback = symbol;\n        symbol = false;\n      }\n\n      let reconnect = () => {\n        if (Binance.options.reconnect) fMarkPriceStream(symbol, callback, speed);\n      };\n\n      const endpoint = symbol ? `${symbol.toLowerCase()}@markPrice` : '!markPrice@arr';\n      let subscription = futuresSubscribeSingle(endpoint + speed, data => callback(fMarkPriceConvertData(data)), {\n        reconnect\n      });\n      return subscription.endpoint;\n    },\n\n    /**\r\n     * Futures WebSocket liquidations stream\r\n     * @param {symbol} symbol name or false. can also be a callback\r\n     * @param {function} callback - callback function\r\n     * @return {string} the websocket endpoint\r\n     */\n    futuresLiquidationStream: function fLiquidationStream(symbol = false, callback = console.log) {\n      if (typeof symbol == 'function') {\n        callback = symbol;\n        symbol = false;\n      }\n\n      let reconnect = () => {\n        if (Binance.options.reconnect) fLiquidationStream(symbol, callback);\n      };\n\n      const endpoint = symbol ? `${symbol.toLowerCase()}@forceOrder` : '!forceOrder@arr';\n      let subscription = futuresSubscribeSingle(endpoint, data => callback(fLiquidationConvertData(data)), {\n        reconnect\n      });\n      return subscription.endpoint;\n    },\n\n    /**\r\n     * Futures WebSocket prevDay ticker\r\n     * @param {symbol} symbol name or false. can also be a callback\r\n     * @param {function} callback - callback function\r\n     * @return {string} the websocket endpoint\r\n     */\n    futuresTickerStream: function fTickerStream(symbol = false, callback = console.log) {\n      if (typeof symbol == 'function') {\n        callback = symbol;\n        symbol = false;\n      }\n\n      let reconnect = () => {\n        if (Binance.options.reconnect) fTickerStream(symbol, callback);\n      };\n\n      const endpoint = symbol ? `${symbol.toLowerCase()}@ticker` : '!ticker@arr';\n      let subscription = futuresSubscribeSingle(endpoint, data => callback(fTickerConvertData(data)), {\n        reconnect\n      });\n      return subscription.endpoint;\n    },\n\n    /**\r\n     * Futures WebSocket miniTicker\r\n     * @param {symbol} symbol name or false. can also be a callback\r\n     * @param {function} callback - callback function\r\n     * @return {string} the websocket endpoint\r\n     */\n    futuresMiniTickerStream: function fMiniTickerStream(symbol = false, callback = console.log) {\n      if (typeof symbol == 'function') {\n        callback = symbol;\n        symbol = false;\n      }\n\n      let reconnect = () => {\n        if (Binance.options.reconnect) fMiniTickerStream(symbol, callback);\n      };\n\n      const endpoint = symbol ? `${symbol.toLowerCase()}@miniTicker` : '!miniTicker@arr';\n      let subscription = futuresSubscribeSingle(endpoint, data => callback(fMiniTickerConvertData(data)), {\n        reconnect\n      });\n      return subscription.endpoint;\n    },\n\n    /**\r\n     * Futures WebSocket bookTicker\r\n     * @param {symbol} symbol name or false. can also be a callback\r\n     * @param {function} callback - callback function\r\n     * @return {string} the websocket endpoint\r\n     */\n    futuresBookTickerStream: function fBookTickerStream(symbol = false, callback = console.log) {\n      if (typeof symbol == 'function') {\n        callback = symbol;\n        symbol = false;\n      }\n\n      let reconnect = () => {\n        if (Binance.options.reconnect) fBookTickerStream(symbol, callback);\n      };\n\n      const endpoint = symbol ? `${symbol.toLowerCase()}@bookTicker` : '!bookTicker';\n      let subscription = futuresSubscribeSingle(endpoint, data => callback(fBookTickerConvertData(data)), {\n        reconnect\n      });\n      return subscription.endpoint;\n    },\n\n    /**\r\n     * Websocket futures klines\r\n     * @param {array/string} symbols - an array or string of symbols to query\r\n     * @param {string} interval - the time interval\r\n     * @param {function} callback - callback function\r\n     * @param {int} limit - maximum results, no more than 1000\r\n     * @return {string} the websocket endpoint\r\n     */\n    futuresChart: async function futuresChart(symbols, interval, callback, limit = 500) {\n      let reconnect = () => {\n        if (Binance.options.reconnect) futuresChart(symbols, interval, callback, limit);\n      };\n\n      let futuresChartInit = symbol => {\n        if (typeof Binance.futuresMeta[symbol] === 'undefined') Binance.futuresMeta[symbol] = {};\n        if (typeof Binance.futuresMeta[symbol][interval] === 'undefined') Binance.futuresMeta[symbol][interval] = {};\n        if (typeof Binance.futuresTicks[symbol] === 'undefined') Binance.futuresTicks[symbol] = {};\n        if (typeof Binance.futuresTicks[symbol][interval] === 'undefined') Binance.futuresTicks[symbol][interval] = {};\n        if (typeof Binance.futuresRealtime[symbol] === 'undefined') Binance.futuresRealtime[symbol] = {};\n        if (typeof Binance.futuresRealtime[symbol][interval] === 'undefined') Binance.futuresRealtime[symbol][interval] = {};\n        if (typeof Binance.futuresKlineQueue[symbol] === 'undefined') Binance.futuresKlineQueue[symbol] = {};\n        if (typeof Binance.futuresKlineQueue[symbol][interval] === 'undefined') Binance.futuresKlineQueue[symbol][interval] = [];\n        Binance.futuresMeta[symbol][interval].timestamp = 0;\n      };\n\n      let handleFuturesKlineStream = kline => {\n        let symbol = kline.s,\n            interval = kline.k.i;\n\n        if (!Binance.futuresMeta[symbol][interval].timestamp) {\n          if (typeof Binance.futuresKlineQueue[symbol][interval] !== 'undefined' && kline !== null) {\n            Binance.futuresKlineQueue[symbol][interval].push(kline);\n          }\n        } else {\n          //Binance.options.log('futures klines at ' + kline.k.t);\n          futuresKlineHandler(symbol, kline);\n          if (callback) callback(symbol, interval, futuresKlineConcat(symbol, interval));\n        }\n      };\n\n      let getFuturesKlineSnapshot = async (symbol, limit = 500) => {\n        let data = await promiseRequest('v1/klines', {\n          symbol,\n          interval,\n          limit\n        }, {\n          base: fapi\n        });\n        futuresKlineData(symbol, interval, data); //Binance.options.log('/futures klines at ' + Binance.futuresMeta[symbol][interval].timestamp);\n\n        if (typeof Binance.futuresKlineQueue[symbol][interval] !== 'undefined') {\n          for (let kline of Binance.futuresKlineQueue[symbol][interval]) futuresKlineHandler(symbol, kline, Binance.futuresMeta[symbol][interval].timestamp);\n\n          delete Binance.futuresKlineQueue[symbol][interval];\n        }\n\n        if (callback) callback(symbol, interval, futuresKlineConcat(symbol, interval));\n      };\n\n      let subscription;\n\n      if (Array.isArray(symbols)) {\n        if (!isArrayUnique(symbols)) throw Error('futuresChart: \"symbols\" array cannot contain duplicate elements.');\n        symbols.forEach(futuresChartInit);\n        let streams = symbols.map(symbol => `${symbol.toLowerCase()}@kline_${interval}`);\n        subscription = futuresSubscribe(streams, handleFuturesKlineStream, reconnect);\n        symbols.forEach(element => getFuturesKlineSnapshot(element, limit));\n      } else {\n        let symbol = symbols;\n        futuresChartInit(symbol);\n        subscription = futuresSubscribeSingle(symbol.toLowerCase() + '@kline_' + interval, handleFuturesKlineStream, reconnect);\n        getFuturesKlineSnapshot(symbol, limit);\n      }\n\n      return subscription.endpoint;\n    },\n\n    /**\r\n     * Websocket futures candlesticks\r\n     * @param {array/string} symbols - an array or string of symbols to query\r\n     * @param {string} interval - the time interval\r\n     * @param {function} callback - callback function\r\n     * @return {string} the websocket endpoint\r\n     */\n    futuresCandlesticks: function futuresCandlesticks(symbols, interval, callback) {\n      let reconnect = () => {\n        if (Binance.options.reconnect) futuresCandlesticks(symbols, interval, callback);\n      };\n\n      let subscription;\n\n      if (Array.isArray(symbols)) {\n        if (!isArrayUnique(symbols)) throw Error('futuresCandlesticks: \"symbols\" array cannot contain duplicate elements.');\n        let streams = symbols.map(symbol => symbol.toLowerCase() + '@kline_' + interval);\n        subscription = futuresSubscribe(streams, callback, {\n          reconnect\n        });\n      } else {\n        let symbol = symbols.toLowerCase();\n        subscription = futuresSubscribeSingle(symbol + '@kline_' + interval, callback, {\n          reconnect\n        });\n      }\n\n      return subscription.endpoint;\n    },\n    // Delivery WebSocket Functions:\n\n    /**\r\n     * Subscribe to a single delivery websocket\r\n     * @param {string} url - the delivery websocket endpoint\r\n     * @param {function} callback - optional execution callback\r\n     * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}\r\n     * @return {WebSocket} the websocket reference\r\n     */\n    deliverySubscribeSingle: function (url, callback, params = {}) {\n      return deliverySubscribeSingle(url, callback, params);\n    },\n\n    /**\r\n     * Subscribe to a combined delivery websocket\r\n     * @param {string} streams - the list of websocket endpoints to connect to\r\n     * @param {function} callback - optional execution callback\r\n     * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}\r\n     * @return {WebSocket} the websocket reference\r\n     */\n    deliverySubscribe: function (streams, callback, params = {}) {\n      return deliverySubscribe(streams, callback, params);\n    },\n\n    /**\r\n     * Returns the known delivery websockets subscriptions\r\n     * @return {array} array of delivery websocket subscriptions\r\n     */\n    deliverySubscriptions: function () {\n      return Binance.deliverySubscriptions;\n    },\n\n    /**\r\n     * Terminates a delivery websocket\r\n     * @param {string} endpoint - the string associated with the endpoint\r\n     * @return {undefined}\r\n     */\n    deliveryTerminate: function (endpoint) {\n      if (Binance.options.verbose) Binance.options.log('Delivery WebSocket terminating:', endpoint);\n      return deliveryTerminate(endpoint);\n    },\n\n    /**\r\n     * Delivery WebSocket aggregated trades\r\n     * @param {array/string} symbols - an array or string of symbols to query\r\n     * @param {function} callback - callback function\r\n     * @return {string} the websocket endpoint\r\n     */\n    deliveryAggTradeStream: function deliveryAggTradeStream(symbols, callback) {\n      let reconnect = () => {\n        if (Binance.options.reconnect) deliveryAggTradeStream(symbols, callback);\n      };\n\n      let subscription,\n          cleanCallback = data => callback(dAggTradeConvertData(data));\n\n      if (Array.isArray(symbols)) {\n        if (!isArrayUnique(symbols)) throw Error('deliveryAggTradeStream: \"symbols\" cannot contain duplicate elements.');\n        let streams = symbols.map(symbol => symbol.toLowerCase() + '@aggTrade');\n        subscription = deliverySubscribe(streams, cleanCallback, {\n          reconnect\n        });\n      } else {\n        let symbol = symbols;\n        subscription = deliverySubscribeSingle(symbol.toLowerCase() + '@aggTrade', cleanCallback, {\n          reconnect\n        });\n      }\n\n      return subscription.endpoint;\n    },\n\n    /**\r\n     * Delivery WebSocket mark price\r\n     * @param {symbol} symbol name or false. can also be a callback\r\n     * @param {function} callback - callback function\r\n     * @param {string} speed - 1 second updates. leave blank for default 3 seconds\r\n     * @return {string} the websocket endpoint\r\n     */\n    deliveryMarkPriceStream: function dMarkPriceStream(symbol = false, callback = console.log, speed = '@1s') {\n      if (typeof symbol == 'function') {\n        callback = symbol;\n        symbol = false;\n      }\n\n      let reconnect = () => {\n        if (Binance.options.reconnect) dMarkPriceStream(symbol, callback);\n      };\n\n      const endpoint = symbol ? `${symbol.toLowerCase()}@markPrice` : '!markPrice@arr';\n      let subscription = deliverySubscribeSingle(endpoint + speed, data => callback(dMarkPriceConvertData(data)), {\n        reconnect\n      });\n      return subscription.endpoint;\n    },\n\n    /**\r\n     * Delivery WebSocket liquidations stream\r\n     * @param {symbol} symbol name or false. can also be a callback\r\n     * @param {function} callback - callback function\r\n     * @return {string} the websocket endpoint\r\n     */\n    deliveryLiquidationStream: function dLiquidationStream(symbol = false, callback = console.log) {\n      if (typeof symbol == 'function') {\n        callback = symbol;\n        symbol = false;\n      }\n\n      let reconnect = () => {\n        if (Binance.options.reconnect) dLiquidationStream(symbol, callback);\n      };\n\n      const endpoint = symbol ? `${symbol.toLowerCase()}@forceOrder` : '!forceOrder@arr';\n      let subscription = deliverySubscribeSingle(endpoint, data => callback(dLiquidationConvertData(data)), {\n        reconnect\n      });\n      return subscription.endpoint;\n    },\n\n    /**\r\n     * Delivery WebSocket prevDay ticker\r\n     * @param {symbol} symbol name or false. can also be a callback\r\n     * @param {function} callback - callback function\r\n     * @return {string} the websocket endpoint\r\n     */\n    deliveryTickerStream: function dTickerStream(symbol = false, callback = console.log) {\n      if (typeof symbol == 'function') {\n        callback = symbol;\n        symbol = false;\n      }\n\n      let reconnect = () => {\n        if (Binance.options.reconnect) dTickerStream(symbol, callback);\n      };\n\n      const endpoint = symbol ? `${symbol.toLowerCase()}@ticker` : '!ticker@arr';\n      let subscription = deliverySubscribeSingle(endpoint, data => callback(dTickerConvertData(data)), {\n        reconnect\n      });\n      return subscription.endpoint;\n    },\n\n    /**\r\n     * Delivery WebSocket miniTicker\r\n     * @param {symbol} symbol name or false. can also be a callback\r\n     * @param {function} callback - callback function\r\n     * @return {string} the websocket endpoint\r\n     */\n    deliveryMiniTickerStream: function dMiniTickerStream(symbol = false, callback = console.log) {\n      if (typeof symbol == 'function') {\n        callback = symbol;\n        symbol = false;\n      }\n\n      let reconnect = () => {\n        if (Binance.options.reconnect) dMiniTickerStream(symbol, callback);\n      };\n\n      const endpoint = symbol ? `${symbol.toLowerCase()}@miniTicker` : '!miniTicker@arr';\n      let subscription = deliverySubscribeSingle(endpoint, data => callback(dMiniTickerConvertData(data)), {\n        reconnect\n      });\n      return subscription.endpoint;\n    },\n\n    /**\r\n     * Delivery WebSocket bookTicker\r\n     * @param {symbol} symbol name or false. can also be a callback\r\n     * @param {function} callback - callback function\r\n     * @return {string} the websocket endpoint\r\n     */\n    deliveryBookTickerStream: function dBookTickerStream(symbol = false, callback = console.log) {\n      if (typeof symbol == 'function') {\n        callback = symbol;\n        symbol = false;\n      }\n\n      let reconnect = () => {\n        if (Binance.options.reconnect) dBookTickerStream(symbol, callback);\n      };\n\n      const endpoint = symbol ? `${symbol.toLowerCase()}@bookTicker` : '!bookTicker';\n      let subscription = deliverySubscribeSingle(endpoint, data => callback(dBookTickerConvertData(data)), {\n        reconnect\n      });\n      return subscription.endpoint;\n    },\n\n    /**\r\n     * Websocket delivery klines\r\n     * @param {array/string} symbols - an array or string of symbols to query\r\n     * @param {string} interval - the time interval\r\n     * @param {function} callback - callback function\r\n     * @param {int} limit - maximum results, no more than 1000\r\n     * @return {string} the websocket endpoint\r\n     */\n    deliveryChart: async function deliveryChart(symbols, interval, callback, limit = 500) {\n      let reconnect = () => {\n        if (Binance.options.reconnect) deliveryChart(symbols, interval, callback, limit);\n      };\n\n      let deliveryChartInit = symbol => {\n        if (typeof Binance.deliveryMeta[symbol] === 'undefined') Binance.deliveryMeta[symbol] = {};\n        if (typeof Binance.deliveryMeta[symbol][interval] === 'undefined') Binance.deliveryMeta[symbol][interval] = {};\n        if (typeof Binance.deliveryTicks[symbol] === 'undefined') Binance.deliveryTicks[symbol] = {};\n        if (typeof Binance.deliveryTicks[symbol][interval] === 'undefined') Binance.deliveryTicks[symbol][interval] = {};\n        if (typeof Binance.deliveryRealtime[symbol] === 'undefined') Binance.deliveryRealtime[symbol] = {};\n        if (typeof Binance.deliveryRealtime[symbol][interval] === 'undefined') Binance.deliveryRealtime[symbol][interval] = {};\n        if (typeof Binance.deliveryKlineQueue[symbol] === 'undefined') Binance.deliveryKlineQueue[symbol] = {};\n        if (typeof Binance.deliveryKlineQueue[symbol][interval] === 'undefined') Binance.deliveryKlineQueue[symbol][interval] = [];\n        Binance.deliveryMeta[symbol][interval].timestamp = 0;\n      };\n\n      let handleDeliveryKlineStream = kline => {\n        let symbol = kline.s,\n            interval = kline.k.i;\n\n        if (!Binance.deliveryMeta[symbol][interval].timestamp) {\n          if (typeof Binance.deliveryKlineQueue[symbol][interval] !== 'undefined' && kline !== null) {\n            Binance.deliveryKlineQueue[symbol][interval].push(kline);\n          }\n        } else {\n          //Binance.options.log('futures klines at ' + kline.k.t);\n          deliveryKlineHandler(symbol, kline);\n          if (callback) callback(symbol, interval, deliveryKlineConcat(symbol, interval));\n        }\n      };\n\n      let getDeliveryKlineSnapshot = async (symbol, limit = 500) => {\n        let data = await promiseRequest('v1/klines', {\n          symbol,\n          interval,\n          limit\n        }, {\n          base: fapi\n        });\n        deliveryKlineData(symbol, interval, data); //Binance.options.log('/delivery klines at ' + Binance.deliveryMeta[symbol][interval].timestamp);\n\n        if (typeof Binance.deliveryKlineQueue[symbol][interval] !== 'undefined') {\n          for (let kline of Binance.deliveryKlineQueue[symbol][interval]) deliveryKlineHandler(symbol, kline, Binance.deliveryMeta[symbol][interval].timestamp);\n\n          delete Binance.deliveryKlineQueue[symbol][interval];\n        }\n\n        if (callback) callback(symbol, interval, deliveryKlineConcat(symbol, interval));\n      };\n\n      let subscription;\n\n      if (Array.isArray(symbols)) {\n        if (!isArrayUnique(symbols)) throw Error('deliveryChart: \"symbols\" array cannot contain duplicate elements.');\n        symbols.forEach(deliveryChartInit);\n        let streams = symbols.map(symbol => `${symbol.toLowerCase()}@kline_${interval}`);\n        subscription = deliverySubscribe(streams, handleDeliveryKlineStream, reconnect);\n        symbols.forEach(element => getDeliveryKlineSnapshot(element, limit));\n      } else {\n        let symbol = symbols;\n        deliveryChartInit(symbol);\n        subscription = deliverySubscribeSingle(symbol.toLowerCase() + '@kline_' + interval, handleDeliveryKlineStream, reconnect);\n        getDeliveryKlineSnapshot(symbol, limit);\n      }\n\n      return subscription.endpoint;\n    },\n\n    /**\r\n     * Websocket delivery candlesticks\r\n     * @param {array/string} symbols - an array or string of symbols to query\r\n     * @param {string} interval - the time interval\r\n     * @param {function} callback - callback function\r\n     * @return {string} the websocket endpoint\r\n     */\n    deliveryCandlesticks: function deliveryCandlesticks(symbols, interval, callback) {\n      let reconnect = () => {\n        if (Binance.options.reconnect) deliveryCandlesticks(symbols, interval, callback);\n      };\n\n      let subscription;\n\n      if (Array.isArray(symbols)) {\n        if (!isArrayUnique(symbols)) throw Error('deliveryCandlesticks: \"symbols\" array cannot contain duplicate elements.');\n        let streams = symbols.map(symbol => symbol.toLowerCase() + '@kline_' + interval);\n        subscription = deliverySubscribe(streams, callback, {\n          reconnect\n        });\n      } else {\n        let symbol = symbols.toLowerCase();\n        subscription = deliverySubscribeSingle(symbol + '@kline_' + interval, callback, {\n          reconnect\n        });\n      }\n\n      return subscription.endpoint;\n    },\n    websockets: {\n      /**\r\n       * Userdata websockets function\r\n       * @param {function} callback - the callback function\r\n       * @param {function} execution_callback - optional execution callback\r\n       * @param {function} subscribed_callback - subscription callback\r\n       * @param {function} list_status_callback - status callback\r\n       * @return {undefined}\r\n       */\n      userData: function userData(callback, execution_callback = false, subscribed_callback = false, list_status_callback = false) {\n        let reconnect = () => {\n          if (Binance.options.reconnect) userData(callback, execution_callback, subscribed_callback);\n        };\n\n        apiRequest(base + 'v3/userDataStream', {}, function (error, response) {\n          Binance.options.listenKey = response.listenKey;\n          setTimeout(function userDataKeepAlive() {\n            // keepalive\n            try {\n              apiRequest(base + 'v3/userDataStream?listenKey=' + Binance.options.listenKey, {}, function (err) {\n                if (err) setTimeout(userDataKeepAlive, 60000); // retry in 1 minute\n                else setTimeout(userDataKeepAlive, 60 * 30 * 1000); // 30 minute keepalive\n              }, 'PUT');\n            } catch (error) {\n              setTimeout(userDataKeepAlive, 60000); // retry in 1 minute\n            }\n          }, 60 * 30 * 1000); // 30 minute keepalive\n\n          Binance.options.balance_callback = callback;\n          Binance.options.execution_callback = execution_callback;\n          Binance.options.list_status_callback = list_status_callback;\n          const subscription = subscribe(Binance.options.listenKey, userDataHandler, reconnect);\n          if (subscribed_callback) subscribed_callback(subscription.endpoint);\n        }, 'POST');\n      },\n\n      /**\r\n       * Margin Userdata websockets function\r\n       * @param {function} callback - the callback function\r\n       * @param {function} execution_callback - optional execution callback\r\n       * @param {function} subscribed_callback - subscription callback\r\n       * @param {function} list_status_callback - status callback\r\n       * @return {undefined}\r\n       */\n      userMarginData: function userMarginData(callback, execution_callback = false, subscribed_callback = false, list_status_callback = false) {\n        let reconnect = () => {\n          if (Binance.options.reconnect) userMarginData(callback, execution_callback, subscribed_callback);\n        };\n\n        apiRequest(sapi + 'v1/userDataStream', {}, function (error, response) {\n          Binance.options.listenMarginKey = response.listenKey;\n          setTimeout(function userDataKeepAlive() {\n            // keepalive\n            try {\n              apiRequest(sapi + 'v1/userDataStream?listenKey=' + Binance.options.listenMarginKey, {}, function (err) {\n                if (err) setTimeout(userDataKeepAlive, 60000); // retry in 1 minute\n                else setTimeout(userDataKeepAlive, 60 * 30 * 1000); // 30 minute keepalive\n              }, 'PUT');\n            } catch (error) {\n              setTimeout(userDataKeepAlive, 60000); // retry in 1 minute\n            }\n          }, 60 * 30 * 1000); // 30 minute keepalive\n\n          Binance.options.margin_balance_callback = callback;\n          Binance.options.margin_execution_callback = execution_callback;\n          Binance.options.margin_list_status_callback = list_status_callback;\n          const subscription = subscribe(Binance.options.listenMarginKey, userMarginDataHandler, reconnect);\n          if (subscribed_callback) subscribed_callback(subscription.endpoint);\n        }, 'POST');\n      },\n\n      /**\r\n       * Future Userdata websockets function\r\n       * @param {function} margin_call_callback\r\n       * @param {function} account_update_callback\r\n       * @param {function} order_update_callback\r\n       * @param {Function} subscribed_callback - subscription callback\r\n       */\n      userFutureData: function userFutureData(margin_call_callback, account_update_callback = undefined, order_update_callback = undefined, subscribed_callback = undefined, account_config_update_callback = undefined) {\n        const url = Binance.options.test ? fapiTest : fapi;\n\n        let reconnect = () => {\n          if (Binance.options.reconnect) userFutureData(margin_call_callback, account_update_callback, order_update_callback, subscribed_callback);\n        };\n\n        apiRequest(url + 'v1/listenKey', {}, function (error, response) {\n          Binance.options.listenFutureKey = response.listenKey;\n          setTimeout(function userDataKeepAlive() {\n            // keepalive\n            try {\n              apiRequest(url + 'v1/listenKey?listenKey=' + Binance.options.listenFutureKey, {}, function (err) {\n                if (err) setTimeout(userDataKeepAlive, 60000); // retry in 1 minute\n                else setTimeout(userDataKeepAlive, 60 * 30 * 1000); // 30 minute keepalive\n              }, 'PUT');\n            } catch (error) {\n              setTimeout(userDataKeepAlive, 60000); // retry in 1 minute\n            }\n          }, 60 * 30 * 1000); // 30 minute keepalive\n\n          Binance.options.future_margin_call_callback = margin_call_callback;\n          Binance.options.future_account_update_callback = account_update_callback;\n          Binance.options.future_account_config_update_callback = account_config_update_callback;\n          Binance.options.future_order_update_callback = order_update_callback;\n          const subscription = futuresSubscribe(Binance.options.listenFutureKey, userFutureDataHandler, {\n            reconnect\n          });\n          if (subscribed_callback) subscribed_callback(subscription.endpoint);\n        }, 'POST');\n      },\n\n      /**\r\n      * Delivery Userdata websockets function\r\n      * @param {function} margin_call_callback\r\n      * @param {function} account_update_callback\r\n      * @param {function} order_update_callback\r\n      * @param {Function} subscribed_callback - subscription callback\r\n      */\n      userDeliveryData: function userDeliveryData(margin_call_callback, account_update_callback = undefined, order_update_callback = undefined, subscribed_callback = undefined) {\n        const url = Binance.options.test ? dapiTest : dapi;\n\n        let reconnect = () => {\n          if (Binance.options.reconnect) userDeliveryData(margin_call_callback, account_update_callback, order_update_callback, subscribed_callback);\n        };\n\n        apiRequest(url + \"v1/listenKey\", {}, function (error, response) {\n          Binance.options.listenDeliveryKey = response.listenKey;\n          setTimeout(function userDataKeepAlive() {\n            // keepalive\n            try {\n              apiRequest(url + \"v1/listenKey?listenKey=\" + Binance.options.listenDeliveryKey, {}, function (err) {\n                if (err) setTimeout(userDataKeepAlive, 60000); // retry in 1 minute\n                else setTimeout(userDataKeepAlive, 60 * 30 * 1000); // 30 minute keepalive\n              }, \"PUT\");\n            } catch (error) {\n              setTimeout(userDataKeepAlive, 60000); // retry in 1 minute\n            }\n          }, 60 * 30 * 1000); // 30 minute keepalive\n\n          Binance.options.delivery_margin_call_callback = margin_call_callback;\n          Binance.options.delivery_account_update_callback = account_update_callback;\n          Binance.options.delivery_order_update_callback = order_update_callback;\n          const subscription = deliverySubscribe(Binance.options.listenDeliveryKey, userDeliveryDataHandler, {\n            reconnect\n          });\n          if (subscribed_callback) subscribed_callback(subscription.endpoint);\n        }, \"POST\");\n      },\n\n      /**\r\n       * Subscribe to a generic websocket\r\n       * @param {string} url - the websocket endpoint\r\n       * @param {function} callback - optional execution callback\r\n       * @param {boolean} reconnect - subscription callback\r\n       * @return {WebSocket} the websocket reference\r\n       */\n      subscribe: function (url, callback, reconnect = false) {\n        return subscribe(url, callback, reconnect);\n      },\n\n      /**\r\n       * Subscribe to a generic combined websocket\r\n       * @param {string} url - the websocket endpoint\r\n       * @param {function} callback - optional execution callback\r\n       * @param {boolean} reconnect - subscription callback\r\n       * @return {WebSocket} the websocket reference\r\n       */\n      subscribeCombined: function (url, callback, reconnect = false) {\n        return subscribeCombined(url, callback, reconnect);\n      },\n\n      /**\r\n       * Returns the known websockets subscriptions\r\n       * @return {array} array of web socket subscriptions\r\n       */\n      subscriptions: function () {\n        return Binance.subscriptions;\n      },\n\n      /**\r\n       * Terminates a web socket\r\n       * @param {string} endpoint - the string associated with the endpoint\r\n       * @return {undefined}\r\n       */\n      terminate: function (endpoint) {\n        if (Binance.options.verbose) Binance.options.log('WebSocket terminating:', endpoint);\n        return terminate(endpoint);\n      },\n\n      /**\r\n       * Websocket depth chart\r\n       * @param {array/string} symbols - an array or string of symbols to query\r\n       * @param {function} callback - callback function\r\n       * @return {string} the websocket endpoint\r\n       */\n      depth: function depth(symbols, callback) {\n        let reconnect = () => {\n          if (Binance.options.reconnect) depth(symbols, callback);\n        };\n\n        let subscription;\n\n        if (Array.isArray(symbols)) {\n          if (!isArrayUnique(symbols)) throw Error('depth: \"symbols\" cannot contain duplicate elements.');\n          let streams = symbols.map(function (symbol) {\n            return symbol.toLowerCase() + '@depth@100ms';\n          });\n          subscription = subscribeCombined(streams, callback, reconnect);\n        } else {\n          let symbol = symbols;\n          subscription = subscribe(symbol.toLowerCase() + '@depth@100ms', callback, reconnect);\n        }\n\n        return subscription.endpoint;\n      },\n\n      /**\r\n       * Websocket depth cache\r\n       * @param {array/string} symbols - an array or string of symbols to query\r\n       * @param {function} callback - callback function\r\n       * @param {int} limit - the number of entries\r\n       * @return {string} the websocket endpoint\r\n       */\n      depthCache: function depthCacheFunction(symbols, callback, limit = 500) {\n        let reconnect = () => {\n          if (Binance.options.reconnect) depthCacheFunction(symbols, callback, limit);\n        };\n\n        let symbolDepthInit = symbol => {\n          if (typeof Binance.depthCacheContext[symbol] === 'undefined') Binance.depthCacheContext[symbol] = {};\n          let context = Binance.depthCacheContext[symbol];\n          context.snapshotUpdateId = null;\n          context.lastEventUpdateId = null;\n          context.messageQueue = [];\n          Binance.depthCache[symbol] = {\n            bids: {},\n            asks: {}\n          };\n        };\n\n        let assignEndpointIdToContext = (symbol, endpointId) => {\n          if (Binance.depthCacheContext[symbol]) {\n            let context = Binance.depthCacheContext[symbol];\n            context.endpointId = endpointId;\n          }\n        };\n\n        let handleDepthStreamData = depth => {\n          let symbol = depth.s;\n          let context = Binance.depthCacheContext[symbol];\n\n          if (context.messageQueue && !context.snapshotUpdateId) {\n            context.messageQueue.push(depth);\n          } else {\n            try {\n              depthHandler(depth);\n            } catch (err) {\n              return terminate(context.endpointId, true);\n            }\n\n            if (callback) callback(symbol, Binance.depthCache[symbol], context);\n          }\n        };\n\n        let getSymbolDepthSnapshot = (symbol, cb) => {\n          publicRequest(base + 'v3/depth', {\n            symbol: symbol,\n            limit: limit\n          }, function (error, json) {\n            if (error) {\n              return cb(error, null);\n            } // Store symbol next use\n\n\n            json.symb = symbol;\n            cb(null, json);\n          });\n        };\n\n        let updateSymbolDepthCache = json => {\n          // Get previous store symbol\n          let symbol = json.symb; // Initialize depth cache from snapshot\n\n          Binance.depthCache[symbol] = depthData(json); // Prepare depth cache context\n\n          let context = Binance.depthCacheContext[symbol];\n          context.snapshotUpdateId = json.lastUpdateId;\n          context.messageQueue = context.messageQueue.filter(depth => depth.u > context.snapshotUpdateId); // Process any pending depth messages\n\n          for (let depth of context.messageQueue) {\n            /* Although sync errors shouldn't ever happen here, we catch and swallow them anyway\r\n             just in case. The stream handler function above will deal with broken caches. */\n            try {\n              depthHandler(depth);\n            } catch (err) {// Do nothing\n            }\n          }\n\n          delete context.messageQueue;\n          if (callback) callback(symbol, Binance.depthCache[symbol]);\n        };\n        /* If an array of symbols are sent we use a combined stream connection rather.\r\n         This is transparent to the developer, and results in a single socket connection.\r\n         This essentially eliminates \"unexpected response\" errors when subscribing to a lot of data. */\n\n\n        let subscription;\n\n        if (Array.isArray(symbols)) {\n          if (!isArrayUnique(symbols)) throw Error('depthCache: \"symbols\" cannot contain duplicate elements.');\n          symbols.forEach(symbolDepthInit);\n          let streams = symbols.map(function (symbol) {\n            return symbol.toLowerCase() + `@depth@100ms`;\n          });\n          subscription = subscribeCombined(streams, handleDepthStreamData, reconnect, function () {\n            async.mapLimit(symbols, 50, getSymbolDepthSnapshot, (err, results) => {\n              if (err) throw err;\n              results.forEach(updateSymbolDepthCache);\n            });\n          });\n          symbols.forEach(s => assignEndpointIdToContext(s, subscription.endpoint));\n        } else {\n          let symbol = symbols;\n          symbolDepthInit(symbol);\n          subscription = subscribe(symbol.toLowerCase() + `@depth@100ms`, handleDepthStreamData, reconnect, function () {\n            async.mapLimit([symbol], 1, getSymbolDepthSnapshot, (err, results) => {\n              if (err) throw err;\n              results.forEach(updateSymbolDepthCache);\n            });\n          });\n          assignEndpointIdToContext(symbol, subscription.endpoint);\n        }\n\n        return subscription.endpoint;\n      },\n\n      /**\r\n       * Clear Websocket depth cache\r\n       * @param {String|Array} symbols   - a single symbol, or an array of symbols, to clear the cache of\r\n       * @returns {void}\r\n       */\n      clearDepthCache(symbols) {\n        const symbolsArr = Array.isArray(symbols) ? symbols : [symbols];\n        symbolsArr.forEach(thisSymbol => {\n          delete Binance.depthCache[thisSymbol];\n        });\n      },\n\n      /**\r\n       * Websocket staggered depth cache\r\n       * @param {array/string} symbols - an array of symbols to query\r\n       * @param {function} callback - callback function\r\n       * @param {int} limit - the number of entries\r\n       * @param {int} stagger - ms between each depth cache\r\n       * @return {Promise} the websocket endpoint\r\n       */\n      depthCacheStaggered: function (symbols, callback, limit = 100, stagger = 200) {\n        if (!Array.isArray(symbols)) symbols = [symbols];\n        let chain = null;\n        symbols.forEach(symbol => {\n          let promise = () => new Promise(resolve => {\n            this.depthCache(symbol, callback, limit);\n            setTimeout(resolve, stagger);\n          });\n\n          chain = chain ? chain.then(promise) : promise();\n        });\n        return chain;\n      },\n\n      /**\r\n       * Websocket aggregated trades\r\n       * @param {array/string} symbols - an array or string of symbols to query\r\n       * @param {function} callback - callback function\r\n       * @return {string} the websocket endpoint\r\n       */\n      aggTrades: function trades(symbols, callback) {\n        let reconnect = () => {\n          if (Binance.options.reconnect) trades(symbols, callback);\n        };\n\n        let subscription;\n\n        if (Array.isArray(symbols)) {\n          if (!isArrayUnique(symbols)) throw Error('trades: \"symbols\" cannot contain duplicate elements.');\n          let streams = symbols.map(function (symbol) {\n            return symbol.toLowerCase() + '@aggTrade';\n          });\n          subscription = subscribeCombined(streams, callback, reconnect);\n        } else {\n          let symbol = symbols;\n          subscription = subscribe(symbol.toLowerCase() + '@aggTrade', callback, reconnect);\n        }\n\n        return subscription.endpoint;\n      },\n\n      /**\r\n      * Websocket raw trades\r\n      * @param {array/string} symbols - an array or string of symbols to query\r\n      * @param {function} callback - callback function\r\n      * @return {string} the websocket endpoint\r\n      */\n      trades: function trades(symbols, callback) {\n        let reconnect = () => {\n          if (Binance.options.reconnect) trades(symbols, callback);\n        };\n\n        let subscription;\n\n        if (Array.isArray(symbols)) {\n          if (!isArrayUnique(symbols)) throw Error('trades: \"symbols\" cannot contain duplicate elements.');\n          let streams = symbols.map(function (symbol) {\n            return symbol.toLowerCase() + '@trade';\n          });\n          subscription = subscribeCombined(streams, callback, reconnect);\n        } else {\n          let symbol = symbols;\n          subscription = subscribe(symbol.toLowerCase() + '@trade', callback, reconnect);\n        }\n\n        return subscription.endpoint;\n      },\n\n      /**\r\n       * Websocket klines\r\n       * @param {array/string} symbols - an array or string of symbols to query\r\n       * @param {string} interval - the time interval\r\n       * @param {function} callback - callback function\r\n       * @param {int} limit - maximum results, no more than 1000\r\n       * @return {string} the websocket endpoint\r\n       */\n      chart: function chart(symbols, interval, callback, limit = 500) {\n        let reconnect = () => {\n          if (Binance.options.reconnect) chart(symbols, interval, callback, limit);\n        };\n\n        let symbolChartInit = symbol => {\n          if (typeof Binance.info[symbol] === 'undefined') Binance.info[symbol] = {};\n          if (typeof Binance.info[symbol][interval] === 'undefined') Binance.info[symbol][interval] = {};\n          if (typeof Binance.ohlc[symbol] === 'undefined') Binance.ohlc[symbol] = {};\n          if (typeof Binance.ohlc[symbol][interval] === 'undefined') Binance.ohlc[symbol][interval] = {};\n          if (typeof Binance.ohlcLatest[symbol] === 'undefined') Binance.ohlcLatest[symbol] = {};\n          if (typeof Binance.ohlcLatest[symbol][interval] === 'undefined') Binance.ohlcLatest[symbol][interval] = {};\n          if (typeof Binance.klineQueue[symbol] === 'undefined') Binance.klineQueue[symbol] = {};\n          if (typeof Binance.klineQueue[symbol][interval] === 'undefined') Binance.klineQueue[symbol][interval] = [];\n          Binance.info[symbol][interval].timestamp = 0;\n        };\n\n        let handleKlineStreamData = kline => {\n          let symbol = kline.s,\n              interval = kline.k.i;\n\n          if (!Binance.info[symbol][interval].timestamp) {\n            if (typeof Binance.klineQueue[symbol][interval] !== 'undefined' && kline !== null) {\n              Binance.klineQueue[symbol][interval].push(kline);\n            }\n          } else {\n            //Binance.options.log('@klines at ' + kline.k.t);\n            klineHandler(symbol, kline);\n            if (callback) callback(symbol, interval, klineConcat(symbol, interval));\n          }\n        };\n\n        let getSymbolKlineSnapshot = (symbol, limit = 500) => {\n          publicRequest(base + 'v3/klines', {\n            symbol: symbol,\n            interval: interval,\n            limit: limit\n          }, function (error, data) {\n            klineData(symbol, interval, data); //Binance.options.log('/klines at ' + Binance.info[symbol][interval].timestamp);\n\n            if (typeof Binance.klineQueue[symbol][interval] !== 'undefined') {\n              for (let kline of Binance.klineQueue[symbol][interval]) klineHandler(symbol, kline, Binance.info[symbol][interval].timestamp);\n\n              delete Binance.klineQueue[symbol][interval];\n            }\n\n            if (callback) callback(symbol, interval, klineConcat(symbol, interval));\n          });\n        };\n\n        let subscription;\n\n        if (Array.isArray(symbols)) {\n          if (!isArrayUnique(symbols)) throw Error('chart: \"symbols\" cannot contain duplicate elements.');\n          symbols.forEach(symbolChartInit);\n          let streams = symbols.map(function (symbol) {\n            return symbol.toLowerCase() + '@kline_' + interval;\n          });\n          subscription = subscribeCombined(streams, handleKlineStreamData, reconnect);\n          symbols.forEach(element => getSymbolKlineSnapshot(element, limit));\n        } else {\n          let symbol = symbols;\n          symbolChartInit(symbol);\n          subscription = subscribe(symbol.toLowerCase() + '@kline_' + interval, handleKlineStreamData, reconnect);\n          getSymbolKlineSnapshot(symbol, limit);\n        }\n\n        return subscription.endpoint;\n      },\n\n      /**\r\n       * Websocket candle sticks\r\n       * @param {array/string} symbols - an array or string of symbols to query\r\n       * @param {string} interval - the time interval\r\n       * @param {function} callback - callback function\r\n       * @return {string} the websocket endpoint\r\n       */\n      candlesticks: function candlesticks(symbols, interval, callback) {\n        let reconnect = () => {\n          if (Binance.options.reconnect) candlesticks(symbols, interval, callback);\n        };\n        /* If an array of symbols are sent we use a combined stream connection rather.\r\n         This is transparent to the developer, and results in a single socket connection.\r\n         This essentially eliminates \"unexpected response\" errors when subscribing to a lot of data. */\n\n\n        let subscription;\n\n        if (Array.isArray(symbols)) {\n          if (!isArrayUnique(symbols)) throw Error('candlesticks: \"symbols\" cannot contain duplicate elements.');\n          let streams = symbols.map(function (symbol) {\n            return symbol.toLowerCase() + '@kline_' + interval;\n          });\n          subscription = subscribeCombined(streams, callback, reconnect);\n        } else {\n          let symbol = symbols.toLowerCase();\n          subscription = subscribe(symbol + '@kline_' + interval, callback, reconnect);\n        }\n\n        return subscription.endpoint;\n      },\n\n      /**\r\n       * Websocket mini ticker\r\n       * @param {function} callback - callback function\r\n       * @return {string} the websocket endpoint\r\n       */\n      miniTicker: function miniTicker(callback) {\n        let reconnect = () => {\n          if (Binance.options.reconnect) miniTicker(callback);\n        };\n\n        let subscription = subscribe('!miniTicker@arr', function (data) {\n          let markets = {};\n\n          for (let obj of data) {\n            markets[obj.s] = {\n              close: obj.c,\n              open: obj.o,\n              high: obj.h,\n              low: obj.l,\n              volume: obj.v,\n              quoteVolume: obj.q,\n              eventTime: obj.E\n            };\n          }\n\n          callback(markets);\n        }, reconnect);\n        return subscription.endpoint;\n      },\n\n      /**\r\n       * Spot WebSocket bookTicker (bid/ask quotes including price & amount)\r\n       * @param {symbol} symbol name or false. can also be a callback\r\n       * @param {function} callback - callback function\r\n       * @return {string} the websocket endpoint\r\n       */\n      bookTickers: function bookTickerStream(symbol = false, callback = console.log) {\n        if (typeof symbol == 'function') {\n          callback = symbol;\n          symbol = false;\n        }\n\n        let reconnect = () => {\n          if (Binance.options.reconnect) bookTickerStream(symbol, callback);\n        };\n\n        const endpoint = symbol ? `${symbol.toLowerCase()}@bookTicker` : '!bookTicker';\n        let subscription = subscribe(endpoint, data => callback(fBookTickerConvertData(data)), reconnect);\n        return subscription.endpoint;\n      },\n\n      /**\r\n       * Websocket prevday percentage\r\n       * @param {array/string} symbols - an array or string of symbols to query\r\n       * @param {function} callback - callback function\r\n       * @param {boolean} singleCallback - avoid call one callback for each symbol in data array\r\n       * @return {string} the websocket endpoint\r\n       */\n      prevDay: function prevDay(symbols, callback, singleCallback) {\n        let reconnect = () => {\n          if (Binance.options.reconnect) prevDay(symbols, callback, singleCallback);\n        };\n\n        let subscription; // Combine stream for array of symbols\n\n        if (Array.isArray(symbols)) {\n          if (!isArrayUnique(symbols)) throw Error('prevDay: \"symbols\" cannot contain duplicate elements.');\n          let streams = symbols.map(function (symbol) {\n            return symbol.toLowerCase() + '@ticker';\n          });\n          subscription = subscribeCombined(streams, function (data) {\n            prevDayStreamHandler(data, callback);\n          }, reconnect); // Raw stream for  a single symbol\n        } else if (symbols) {\n          let symbol = symbols;\n          subscription = subscribe(symbol.toLowerCase() + '@ticker', function (data) {\n            prevDayStreamHandler(data, callback);\n          }, reconnect); // Raw stream of all listed symbols\n        } else {\n          subscription = subscribe('!ticker@arr', function (data) {\n            if (singleCallback) {\n              prevDayStreamHandler(data, callback);\n            } else {\n              for (let line of data) {\n                prevDayStreamHandler(line, callback);\n              }\n            }\n          }, reconnect);\n        }\n\n        return subscription.endpoint;\n      }\n    }\n  };\n};\n\nmodule.exports = api; //https://github.com/binance-exchange/binance-official-api-docs","map":{"version":3,"sources":["C:/Users/James Price/Documents/VS Code/bixpro/node_modules/node-binance-api/node-binance-api.js"],"names":["api","Binance","options","new","target","WebSocket","require","request","crypto","file","url","JSONbig","HttpsProxyAgent","SocksProxyAgent","stringHash","async","base","wapi","sapi","fapi","dapi","fapiTest","dapiTest","fstream","fstreamSingle","fstreamSingleTest","fstreamTest","dstream","dstreamSingle","dstreamSingleTest","dstreamTest","stream","combineStream","userAgent","contentType","subscriptions","futuresSubscriptions","futuresInfo","futuresMeta","futuresTicks","futuresRealtime","futuresKlineQueue","deliverySubscriptions","deliveryInfo","deliveryMeta","deliveryTicks","deliveryRealtime","deliveryKlineQueue","depthCache","depthCacheContext","ohlcLatest","klineQueue","ohlc","default_options","recvWindow","useServerTime","reconnect","keepAlive","verbose","test","hedgeMode","localAddress","family","log","args","console","Array","prototype","slice","call","info","usedWeight","futuresLatency","lastRequest","lastURL","statusCode","orderCount1s","orderCount1m","orderCount1h","orderCount1d","timeOffset","socketHeartbeatInterval","setOptions","opt","callback","JSON","parse","readFileSync","urls","publicRequest","error","response","serverTime","Date","getTime","proxyReplacewithIp","connString","parseProxy","arr","split","host","port","isIterable","obj","Symbol","iterator","addProxy","proxy","proxyauth","auth","username","password","reqHandler","cb","body","uri","href","headers","proxyRequest","req","on","err","reqObj","data","method","key","qs","timeout","forever","reqObjPOST","form","qsStringifyOptions","arrayFormat","makeQueryString","q","Object","keys","reduce","a","k","isArray","forEach","v","push","encodeURIComponent","undefined","join","apiRequest","requireApiKey","APIKEY","source","fatalError","Error","requireApiSecret","APISECRET","marketRequest","query","signedRequest","noDataInSignature","timestamp","signature","createHmac","update","digest","order","side","symbol","quantity","price","flags","endpoint","type","includes","timeInForce","stopLimitPrice","stopLimitTimeInForce","listClientOrderId","limitClientOrderId","stopClientOrderId","newOrderRespType","newClientOrderId","icebergQty","stopPrice","msg","marginOrder","isIsolated","sideEffectType","futuresOrder","params","positionSide","promiseRequest","deliveryOrder","Promise","resolve","reject","baseURL","followAllRedirects","noop","socketHeartbeat","endpointId","ws","isAlive","readyState","OPEN","ping","terminate","handleSocketOpen","opened_callback","length","setInterval","handleSocketClose","code","reason","clearInterval","parseInt","message","handleSocketError","handleSocketHeartbeat","subscribe","httpsproxy","process","env","https_proxy","socksproxy","socks_proxy","agent","protocol","config","bind","subscribeCombined","streams","queryParams","removeAllListeners","futuresSocketHeartbeat","handleFuturesSocketOpen","openCallback","handleFuturesSocketClose","handleFuturesSocketError","handleFuturesSocketHeartbeat","futuresSubscribeSingle","id","futuresSubscribe","futuresTerminate","futuresKlineConcat","interval","output","time","last_updated","pop","isFinal","futuresKlineHandler","kline","firstTime","e","eventType","E","eventTime","ticks","o","open","h","high","l","low","c","close","volume","i","x","quoteVolume","V","takerBuyBaseVolume","Q","takerBuyQuoteVolume","n","trades","t","T","closeTime","first_updated","shift","fLiquidationConvertData","s","S","orderType","f","origAmount","p","ap","avgPrice","X","orderStatus","lastFilledQty","z","totalFilledQty","tradeTime","fTickerConvertData","friendlyData","priceChange","P","percentChange","w","averagePrice","closeQty","O","openTime","C","F","firstTradeId","L","lastTradeId","numTrades","result","fMiniTickerConvertData","fBookTickerConvertData","u","updateId","b","bestBid","B","bestBidQty","bestAsk","A","bestAskQty","fUserDataMarginConvertData","cw","crossWalletBalance","positions","positionConverter","position","ps","pa","positionAmount","mt","marginType","iw","isolatedWallet","mp","markPrice","up","unrealizedPnL","mm","maintenanceMargin","convertedPositions","fUserConfigDataAccountUpdateConvertData","transactionTime","ac","leverage","fUserDataAccountUpdateConvertData","transaction","updateData","updateConverter","m","eventReasonType","balances","ep","entryPrice","cr","accumulatedRealized","balanceConverter","balance","asset","wb","walletBalance","balanceResult","positionResult","fUserDataOrderUpdateConvertData","orderConverter","clientOrderId","originalQuantity","originalPrice","sp","executionType","orderId","orderLastFilledQuantity","orderFilledAccumulatedQuantity","lastFilledPrice","N","commissionAsset","commission","orderTradeTime","tradeId","bidsNotional","askNotional","isMakerSide","R","isReduceOnly","wt","stopPriceWorkingType","ot","originalOrderType","cp","closeAll","AP","activationPrice","callbackRate","rp","realizedProfit","fMarkPriceConvertData","indexPrice","r","fundingRate","fundingTime","fAggTradeConvertData","aggTradeId","amount","maker","total","deliverySocketHeartbeat","handleDeliverySocketOpen","handleDeliverySocketClose","handleDeliverySocketError","handleDeliverySocketHeartbeat","deliverySubscribeSingle","deliverySubscribe","deliveryTerminate","deliveryKlineConcat","deliveryKlineHandler","dLiquidationConvertData","dTickerConvertData","dMiniTickerConvertData","dBookTickerConvertData","dMarkPriceConvertData","dAggTradeConvertData","dUserDataOrderUpdateConvertData","ma","marginAsset","pP","priceProtect","userDataHandler","execution_callback","list_status_callback","balance_callback","userMarginDataHandler","margin_execution_callback","margin_list_status_callback","margin_balance_callback","userFutureDataHandler","future_margin_call_callback","future_account_update_callback","future_order_update_callback","future_account_config_update_callback","userDeliveryDataHandler","delivery_margin_call_callback","delivery_account_update_callback","delivery_order_update_callback","transferBetweenMainAndFutures","parameters","assign","prevDayConvertData","convertData","prevClose","converted","prevDayStreamHandler","priceData","prices","bookPriceData","bid","bidPrice","bids","bidQty","ask","askPrice","asks","askQty","balanceData","available","free","onOrder","locked","klineData","last_time","tick","assetVolume","buyBaseVolume","buyAssetVolume","ignored","klineConcat","klineHandler","futuresKlineData","deliveryKlineData","depthData","parseFloat","lastUpdateId","depthHandler","depth","context","updateDepthCache","skipCount","lastEventUpdateId","lastEventUpdateTime","expectedUpdateId","U","snapshotUpdateId","getDepthCache","depthVolume","cache","bidbase","askbase","bidqty","askqty","toFixed","isArrayUnique","array","Set","size","getPrecision","float","Number","isInteger","toString","roundStep","qty","stepSize","qtyString","desiredDecimals","Math","max","indexOf","decimalIndex","roundTicks","tickSize","formatter","Intl","NumberFormat","style","minimumFractionDigits","maximumFractionDigits","precision","format","percent","min","width","sum","reverse","object","range","map","sortBids","Infinity","baseValue","count","sorted","sort","cumulative","sortAsks","first","last","start","apply","setOption","value","getOption","getInfo","orderCount","getOptions","buy","sell","marketBuy","marketSell","cancel","orderid","openOrders","cancelAll","cancelOrders","json","origQty","executedQty","allOrders","limit","bookTickers","prevDay","input","exchangeInfo","dustLog","dustTransfer","assets","assetDividendRecord","systemStatus","withdraw","address","addressTag","name","withdrawHistory","depositHistory","depositAddress","accountStatus","tradeFee","assetDetail","account","aggTrades","recentTrades","historicalTrades","fromId","highstock","chart","include_volume","line","candlesticks","getMarket","endsWith","lending","futuresPing","futuresTime","then","futuresExchangeInfo","futuresPrices","out","futuresDaily","futuresOpenInterest","openInterest","futuresCandles","futuresMarkPrice","futuresTrades","futuresHistoricalTrades","futuresAggTrades","futuresForceOrders","futuresDeleverageQuantile","futuresUserTrades","futuresGetDataStream","futuresKeepDataStream","futuresCloseDataStream","futuresLiquidationOrders","futuresPositionRisk","futuresFundingRate","futuresLeverageBracket","futuresTradingStatus","futuresCommissionRate","futuresLeverage","futuresMarginType","futuresPositionMargin","futuresPositionMarginHistory","futuresIncome","futuresBalance","futuresAccount","futuresDepth","futuresQuote","futuresBuy","futuresSell","futuresMarketBuy","futuresMarketSell","futuresOrderStatus","futuresCancel","futuresCancelAll","futuresCountdownCancelAll","countdownTime","futuresOpenOrders","futuresAllOrders","futuresPositionSideDual","futuresChangePositionSideDual","dualSidePosition","futuresTransferAsset","futuresHistDataId","futuresDownloadLink","downloadId","deliveryPing","deliveryTime","deliveryExchangeInfo","deliveryPrices","deliveryDaily","deliveryOpenInterest","deliveryCandles","deliveryContinuousKlines","pair","contractType","deliveryIndexKlines","deliveryMarkPriceKlines","deliveryMarkPrice","deliveryTrades","deliveryHistoricalTrades","deliveryAggTrades","deliveryUserTrades","deliveryGetDataStream","deliveryKeepDataStream","deliveryCloseDataStream","deliveryLiquidationOrders","deliveryPositionRisk","deliveryLeverageBracket","deliveryLeverageBracketSymbols","deliveryLeverage","deliveryMarginType","deliveryPositionMargin","deliveryPositionMarginHistory","deliveryIncome","deliveryBalance","deliveryAccount","deliveryDepth","deliveryQuote","deliveryBuy","deliverySell","deliveryMarketBuy","deliveryMarketSell","deliveryOrderStatus","deliveryCancel","deliveryCancelAll","deliveryCountdownCancelAll","deliveryOpenOrders","deliveryAllOrders","deliveryPositionSideDual","deliveryChangePositionSideDual","mgOrder","mgBuy","mgSell","mgMarketBuy","mgMarketSell","mgCancel","mgAllOrders","mgOrderStatus","mgOpenOrders","mgCancelOrders","mgTransferMainToMargin","mgTransferMarginToMain","transferMainToFutures","transferFuturesToMain","transferMainToDelivery","transferDeliveryToMain","maxTransferable","mgBorrow","isolatedObj","mgRepay","mgAccount","maxBorrowable","futuresAggTradeStream","symbols","subscription","cleanCallback","toLowerCase","futuresMarkPriceStream","fMarkPriceStream","speed","futuresLiquidationStream","fLiquidationStream","futuresTickerStream","fTickerStream","futuresMiniTickerStream","fMiniTickerStream","futuresBookTickerStream","fBookTickerStream","futuresChart","futuresChartInit","handleFuturesKlineStream","getFuturesKlineSnapshot","element","futuresCandlesticks","deliveryAggTradeStream","deliveryMarkPriceStream","dMarkPriceStream","deliveryLiquidationStream","dLiquidationStream","deliveryTickerStream","dTickerStream","deliveryMiniTickerStream","dMiniTickerStream","deliveryBookTickerStream","dBookTickerStream","deliveryChart","deliveryChartInit","handleDeliveryKlineStream","getDeliveryKlineSnapshot","deliveryCandlesticks","websockets","userData","subscribed_callback","listenKey","setTimeout","userDataKeepAlive","userMarginData","listenMarginKey","userFutureData","margin_call_callback","account_update_callback","order_update_callback","account_config_update_callback","listenFutureKey","userDeliveryData","listenDeliveryKey","depthCacheFunction","symbolDepthInit","messageQueue","assignEndpointIdToContext","handleDepthStreamData","getSymbolDepthSnapshot","symb","updateSymbolDepthCache","filter","mapLimit","results","clearDepthCache","symbolsArr","thisSymbol","depthCacheStaggered","stagger","chain","promise","symbolChartInit","handleKlineStreamData","getSymbolKlineSnapshot","miniTicker","markets","bookTickerStream","singleCallback","module","exports"],"mappings":"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","sourcesContent":["/* ============================================================\r\n * node-binance-api\r\n * https://github.com/jaggedsoft/node-binance-api\r\n * ============================================================\r\n * Copyright 2017-, Jon Eyrick\r\n * Released under the MIT License\r\n * ============================================================\r\n * @module jaggedsoft/node-binance-api\r\n * @return {object} instance to class object */\r\nlet api = function Binance( options = {} ) {\r\n    if ( !new.target ) return new api( options ); // Legacy support for calling the constructor without 'new'\r\n    let Binance = this; // eslint-disable-line consistent-this\r\n    const WebSocket = require( 'ws' );\r\n    const request = require( 'request' );\r\n    const crypto = require( 'crypto' );\r\n    const file = require( 'fs' );\r\n    const url = require( 'url' );\r\n    const JSONbig = require( 'json-bigint' );\r\n    const HttpsProxyAgent = require( 'https-proxy-agent' );\r\n    const SocksProxyAgent = require( 'socks-proxy-agent' );\r\n    const stringHash = require( 'string-hash' );\r\n    const async = require( 'async' );\r\n    let base = 'https://api.binance.com/api/';\r\n    let wapi = 'https://api.binance.com/wapi/';\r\n    let sapi = 'https://api.binance.com/sapi/';\r\n    let fapi = 'https://fapi.binance.com/fapi/';\r\n    let dapi = 'https://dapi.binance.com/dapi/';\r\n    let fapiTest = 'https://testnet.binancefuture.com/fapi/';\r\n    let dapiTest = 'https://testnet.binancefuture.com/dapi/';\r\n    let fstream = 'wss://fstream.binance.com/stream?streams=';\r\n    let fstreamSingle = 'wss://fstream.binance.com/ws/';\r\n    let fstreamSingleTest = 'wss://stream.binancefuture.com/ws/';\r\n    let fstreamTest = 'wss://stream.binancefuture.com/stream?streams=';\r\n    let dstream = 'wss://dstream.binance.com/stream?streams=';\r\n    let dstreamSingle = 'wss://dstream.binance.com/ws/';\r\n    let dstreamSingleTest = 'wss://dstream.binancefuture.com/ws/';\r\n    let dstreamTest = 'wss://dstream.binancefuture.com/stream?streams=';\r\n    let stream = 'wss://stream.binance.com:9443/ws/';\r\n    let combineStream = 'wss://stream.binance.com:9443/stream?streams=';\r\n    const userAgent = 'Mozilla/4.0 (compatible; Node Binance API)';\r\n    const contentType = 'application/x-www-form-urlencoded';\r\n    Binance.subscriptions = {};\r\n    Binance.futuresSubscriptions = {};\r\n    Binance.futuresInfo = {};\r\n    Binance.futuresMeta = {};\r\n    Binance.futuresTicks = {};\r\n    Binance.futuresRealtime = {};\r\n    Binance.futuresKlineQueue = {};\r\n    Binance.deliverySubscriptions = {};\r\n    Binance.deliveryInfo = {};\r\n    Binance.deliveryMeta = {};\r\n    Binance.deliveryTicks = {};\r\n    Binance.deliveryRealtime = {};\r\n    Binance.deliveryKlineQueue = {};\r\n    Binance.depthCache = {};\r\n    Binance.depthCacheContext = {};\r\n    Binance.ohlcLatest = {};\r\n    Binance.klineQueue = {};\r\n    Binance.ohlc = {};\r\n\r\n    const default_options = {\r\n        recvWindow: 5000,\r\n        useServerTime: false,\r\n        reconnect: true,\r\n        keepAlive: true,\r\n        verbose: false,\r\n        test: false,\r\n        hedgeMode: false,\r\n        localAddress: false,\r\n        family: false,\r\n        log: function ( ...args ) {\r\n            console.log( Array.prototype.slice.call( args ) );\r\n        }\r\n    };\r\n    Binance.options = default_options;\r\n    Binance.info = {\r\n        usedWeight: 0,\r\n        futuresLatency: false,\r\n        lastRequest: false,\r\n        lastURL: false,\r\n        statusCode: 0,\r\n        orderCount1s: 0,\r\n        orderCount1m: 0,\r\n        orderCount1h: 0,\r\n        orderCount1d: 0,\r\n        timeOffset: 0\r\n    };\r\n    Binance.socketHeartbeatInterval = null;\r\n    if ( options ) setOptions( options );\r\n\r\n    function setOptions( opt = {}, callback = false ) {\r\n        if ( typeof opt === 'string' ) { // Pass json config filename\r\n            Binance.options = JSON.parse( file.readFileSync( opt ) );\r\n        } else Binance.options = opt;\r\n        if ( typeof Binance.options.recvWindow === 'undefined' ) Binance.options.recvWindow = default_options.recvWindow;\r\n        if ( typeof Binance.options.useServerTime === 'undefined' ) Binance.options.useServerTime = default_options.useServerTime;\r\n        if ( typeof Binance.options.reconnect === 'undefined' ) Binance.options.reconnect = default_options.reconnect;\r\n        if ( typeof Binance.options.test === 'undefined' ) Binance.options.test = default_options.test;\r\n        if ( typeof Binance.options.hedgeMode === 'undefined' ) Binance.options.hedgeMode = default_options.hedgeMode;\r\n        if ( typeof Binance.options.log === 'undefined' ) Binance.options.log = default_options.log;\r\n        if ( typeof Binance.options.verbose === 'undefined' ) Binance.options.verbose = default_options.verbose;\r\n        if ( typeof Binance.options.keepAlive === 'undefined' ) Binance.options.keepAlive = default_options.keepAlive;\r\n        if ( typeof Binance.options.localAddress === 'undefined' ) Binance.options.localAddress = default_options.localAddress;\r\n        if ( typeof Binance.options.family === 'undefined' ) Binance.options.family = default_options.family;\r\n        if ( typeof Binance.options.urls !== 'undefined' ) {\r\n            const { urls } = Binance.options;\r\n            if ( typeof urls.base === 'string' ) base = urls.base;\r\n            if ( typeof urls.wapi === 'string' ) wapi = urls.wapi;\r\n            if ( typeof urls.sapi === 'string' ) sapi = urls.sapi;\r\n            if ( typeof urls.fapi === 'string' ) fapi = urls.fapi;\r\n            if ( typeof urls.fapiTest === 'string' ) fapiTest = urls.fapiTest;\r\n            if ( typeof urls.stream === 'string' ) stream = urls.stream;\r\n            if ( typeof urls.combineStream === 'string' ) combineStream = urls.combineStream;\r\n            if ( typeof urls.fstream === 'string' ) fstream = urls.fstream;\r\n            if ( typeof urls.fstreamSingle === 'string' ) fstreamSingle = urls.fstreamSingle;\r\n            if ( typeof urls.fstreamTest === 'string' ) fstreamTest = urls.fstreamTest;\r\n            if ( typeof urls.fstreamSingleTest === 'string' ) fstreamSingleTest = urls.fstreamSingleTest;\r\n            if ( typeof urls.dstream === 'string' ) dstream = urls.dstream;\r\n            if ( typeof urls.dstreamSingle === 'string' ) dstreamSingle = urls.dstreamSingle;\r\n            if ( typeof urls.dstreamTest === 'string' ) dstreamTest = urls.dstreamTest;\r\n            if ( typeof urls.dstreamSingleTest === 'string' ) dstreamSingleTest = urls.dstreamSingleTest;\r\n        }\r\n        if ( Binance.options.useServerTime ) {\r\n            publicRequest( base + 'v3/time', {}, function ( error, response ) {\r\n                Binance.info.timeOffset = response.serverTime - new Date().getTime();\r\n                //Binance.options.log(\"server time set: \", response.serverTime, Binance.info.timeOffset);\r\n                if ( callback ) callback();\r\n            } );\r\n        } else if ( callback ) callback();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Replaces socks connection uri hostname with IP address\r\n     * @param {string} connString - socks connection string\r\n     * @return {string} modified string with ip address\r\n     */\r\n    const proxyReplacewithIp = connString => {\r\n        return connString;\r\n    }\r\n\r\n    /**\r\n     * Returns an array in the form of [host, port]\r\n     * @param {string} connString - connection string\r\n     * @return {array} array of host and port\r\n     */\r\n    const parseProxy = connString => {\r\n        let arr = connString.split( '/' );\r\n        let host = arr[2].split( ':' )[0];\r\n        let port = arr[2].split( ':' )[1];\r\n        return [ arr[0], host, port ];\r\n    }\r\n\r\n    /**\r\n     * Checks to see of the object is iterable\r\n     * @param {object} obj - The object check\r\n     * @return {boolean} true or false is iterable\r\n     */\r\n    const isIterable = obj => {\r\n        if ( obj === null ) return false;\r\n        return typeof obj[Symbol.iterator] === 'function';\r\n    }\r\n\r\n    const addProxy = opt => {\r\n        if ( Binance.options.proxy ) {\r\n            const proxyauth = Binance.options.proxy.auth ? `${ Binance.options.proxy.auth.username }:${ Binance.options.proxy.auth.password }@` : '';\r\n            opt.proxy = `http://${ proxyauth }${ Binance.options.proxy.host }:${ Binance.options.proxy.port }`;\r\n        }\r\n        return opt;\r\n    }\r\n\r\n    const reqHandler = cb => ( error, response, body ) => {\r\n        Binance.info.lastRequest = new Date().getTime();\r\n        if ( response ) {\r\n            Binance.info.statusCode = response.statusCode || 0;\r\n            if ( response.request ) Binance.info.lastURL = response.request.uri.href;\r\n            if ( response.headers ) {\r\n                Binance.info.usedWeight = response.headers['x-mbx-used-weight-1m'] || 0;\r\n                Binance.info.orderCount1s = response.headers['x-mbx-order-count-1s'] || 0;\r\n                Binance.info.orderCount1m = response.headers['x-mbx-order-count-1m'] || 0;\r\n                Binance.info.orderCount1h = response.headers['x-mbx-order-count-1h'] || 0;\r\n                Binance.info.orderCount1d = response.headers['x-mbx-order-count-1d'] || 0;\r\n            }\r\n        }\r\n        if ( !cb ) return;\r\n        if ( error ) return cb( error, {} );\r\n        if ( response && response.statusCode !== 200 ) return cb( response, {} );\r\n        return cb( null, JSONbig.parse( body ) );\r\n    }\r\n\r\n    const proxyRequest = ( opt, cb ) => {\r\n        const req = request( addProxy( opt ), reqHandler( cb ) ).on('error', (err) => { cb( err, {} ) });\r\n        return req;\r\n    }\r\n\r\n    const reqObj = ( url, data = {}, method = 'GET', key ) => ( {\r\n        url: url,\r\n        qs: data,\r\n        method: method,\r\n        family: Binance.options.family,\r\n        localAddress: Binance.options.localAddress,\r\n        timeout: Binance.options.recvWindow,\r\n        forever: Binance.options.keepAlive,\r\n        headers: {\r\n            'User-Agent': userAgent,\r\n            'Content-type': contentType,\r\n            'X-MBX-APIKEY': key || ''\r\n        }\r\n    } )\r\n    const reqObjPOST = ( url, data = {}, method = 'POST', key ) => ( {\r\n        url: url,\r\n        form: data,\r\n        method: method,\r\n        family: Binance.options.family,\r\n        localAddress: Binance.options.localAddress,\r\n        timeout: Binance.options.recvWindow,\r\n        forever: Binance.options.keepAlive,\r\n        qsStringifyOptions: {\r\n            arrayFormat: 'repeat'\r\n        },\r\n        headers: {\r\n            'User-Agent': userAgent,\r\n            'Content-type': contentType,\r\n            'X-MBX-APIKEY': key || ''\r\n        }\r\n    } )\r\n    /**\r\n     * Create a http request to the public API\r\n     * @param {string} url - The http endpoint\r\n     * @param {object} data - The data to send\r\n     * @param {function} callback - The callback method to call\r\n     * @param {string} method - the http method\r\n     * @return {undefined}\r\n     */\r\n    const publicRequest = ( url, data = {}, callback, method = 'GET' ) => {\r\n        let opt = reqObj( url, data, method );\r\n        proxyRequest( opt, callback );\r\n    };\r\n\r\n    // XXX: This one works with array (e.g. for dust.transfer)\r\n    // XXX: I _guess_ we could use replace this function with the `qs` module\r\n    const makeQueryString = q =>\r\n        Object.keys( q )\r\n            .reduce( ( a, k ) => {\r\n                if ( Array.isArray( q[k] ) ) {\r\n                    q[k].forEach( v => {\r\n                        a.push( k + \"=\" + encodeURIComponent( v ) )\r\n                    } )\r\n                } else if ( q[k] !== undefined ) {\r\n                    a.push( k + \"=\" + encodeURIComponent( q[k] ) );\r\n                }\r\n                return a;\r\n            }, [] )\r\n            .join( \"&\" );\r\n\r\n    /**\r\n     * Create a http request to the public API\r\n     * @param {string} url - The http endpoint\r\n     * @param {object} data - The data to send\r\n     * @param {function} callback - The callback method to call\r\n     * @param {string} method - the http method\r\n     * @return {undefined}\r\n     */\r\n    const apiRequest = ( url, data = {}, callback, method = 'GET' ) => {\r\n        requireApiKey( 'apiRequest' );\r\n        let opt = reqObj(\r\n            url,\r\n            data,\r\n            method,\r\n            Binance.options.APIKEY\r\n        );\r\n        proxyRequest( opt, callback );\r\n    };\r\n\r\n    // Check if API key is empty or invalid\r\n    const requireApiKey = function( source = 'requireApiKey', fatalError = true ) {\r\n        if ( !Binance.options.APIKEY ) {\r\n            if ( fatalError ) throw Error( `${ source }: Invalid API Key!` );\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // Check if API secret is present\r\n    const requireApiSecret = function( source = 'requireApiSecret', fatalError = true ) {\r\n        if ( !Binance.options.APIKEY ) {\r\n            if ( fatalError ) throw Error( `${ source }: Invalid API Key!` );\r\n            return false;\r\n        }\r\n        if ( !Binance.options.APISECRET ) {\r\n            if ( fatalError ) throw Error( `${ source }: Invalid API Secret!` );\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Make market request\r\n     * @param {string} url - The http endpoint\r\n     * @param {object} data - The data to send\r\n     * @param {function} callback - The callback method to call\r\n     * @param {string} method - the http method\r\n     * @return {undefined}\r\n     */\r\n    const marketRequest = ( url, data = {}, callback, method = 'GET' ) => {\r\n        requireApiKey( 'marketRequest' );\r\n        let query = makeQueryString( data );\r\n        let opt = reqObj(\r\n            url + ( query ? '?' + query : '' ),\r\n            data,\r\n            method,\r\n            Binance.options.APIKEY\r\n        );\r\n        proxyRequest( opt, callback );\r\n    };\r\n\r\n    /**\r\n     * Create a signed http request\r\n     * @param {string} url - The http endpoint\r\n     * @param {object} data - The data to send\r\n     * @param {function} callback - The callback method to call\r\n     * @param {string} method - the http method\r\n     * @param {boolean} noDataInSignature - Prevents data from being added to signature\r\n     * @return {undefined}\r\n     */\r\n    const signedRequest = ( url, data = {}, callback, method = 'GET', noDataInSignature = false ) => {\r\n        requireApiSecret( 'signedRequest' );\r\n        data.timestamp = new Date().getTime() + Binance.info.timeOffset;\r\n        if ( typeof data.recvWindow === 'undefined' ) data.recvWindow = Binance.options.recvWindow;\r\n        let query = method === 'POST' && noDataInSignature ? '' : makeQueryString( data );\r\n        let signature = crypto.createHmac( 'sha256', Binance.options.APISECRET ).update( query ).digest( 'hex' ); // set the HMAC hash header\r\n        if ( method === 'POST' ) {\r\n            let opt = reqObjPOST(\r\n                url,\r\n                data,\r\n                method,\r\n                Binance.options.APIKEY\r\n            );\r\n            opt.form.signature = signature;\r\n            proxyRequest( opt, callback );\r\n        } else {\r\n            let opt = reqObj(\r\n                url + '?' + query + '&signature=' + signature,\r\n                data,\r\n                method,\r\n                Binance.options.APIKEY\r\n            );\r\n            proxyRequest( opt, callback );\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Create a signed spot order\r\n     * @param {string} side - BUY or SELL\r\n     * @param {string} symbol - The symbol to buy or sell\r\n     * @param {string} quantity - The quantity to buy or sell\r\n     * @param {string} price - The price per unit to transact each unit at\r\n     * @param {object} flags - additional order settings\r\n     * @param {function} callback - the callback function\r\n     * @return {undefined}\r\n     */\r\n    const order = ( side, symbol, quantity, price, flags = {}, callback = false ) => {\r\n        let endpoint = flags.type === 'OCO' ? 'v3/order/oco' : 'v3/order';\r\n        if ( Binance.options.test ) endpoint += '/test';\r\n        let opt = {\r\n            symbol: symbol,\r\n            side: side,\r\n            type: 'LIMIT',\r\n            quantity: quantity\r\n        };\r\n        if ( typeof flags.type !== 'undefined' ) opt.type = flags.type;\r\n        if ( opt.type.includes( 'LIMIT' ) ) {\r\n            opt.price = price;\r\n            if ( opt.type !== 'LIMIT_MAKER' ) {\r\n                opt.timeInForce = 'GTC';\r\n            }\r\n        }\r\n        if ( opt.type === 'OCO' ) {\r\n            opt.price = price;\r\n            opt.stopLimitPrice = flags.stopLimitPrice;\r\n            opt.stopLimitTimeInForce = 'GTC';\r\n            delete opt.type;\r\n            if ( typeof flags.listClientOrderId !== 'undefined' ) opt.listClientOrderId = flags.listClientOrderId;\r\n            if ( typeof flags.limitClientOrderId !== 'undefined' ) opt.limitClientOrderId = flags.limitClientOrderId;\r\n            if ( typeof flags.stopClientOrderId !== 'undefined' ) opt.stopClientOrderId = flags.stopClientOrderId;\r\n        }\r\n        if ( typeof flags.timeInForce !== 'undefined' ) opt.timeInForce = flags.timeInForce;\r\n        if ( typeof flags.newOrderRespType !== 'undefined' ) opt.newOrderRespType = flags.newOrderRespType;\r\n        if ( typeof flags.newClientOrderId !== 'undefined' ) opt.newClientOrderId = flags.newClientOrderId;\r\n\r\n        /*\r\n         * STOP_LOSS\r\n         * STOP_LOSS_LIMIT\r\n         * TAKE_PROFIT\r\n         * TAKE_PROFIT_LIMIT\r\n         * LIMIT_MAKER\r\n         */\r\n        if ( typeof flags.icebergQty !== 'undefined' ) opt.icebergQty = flags.icebergQty;\r\n        if ( typeof flags.stopPrice !== 'undefined' ) {\r\n            opt.stopPrice = flags.stopPrice;\r\n            if ( opt.type === 'LIMIT' ) throw Error( 'stopPrice: Must set \"type\" to one of the following: STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, TAKE_PROFIT_LIMIT' );\r\n        }\r\n        signedRequest( base + endpoint, opt, ( error, response ) => {\r\n            if ( !response ) {\r\n                if ( callback ) callback( error, response );\r\n                else Binance.options.log( 'Order() error:', error );\r\n                return;\r\n            }\r\n            if ( typeof response.msg !== 'undefined' && response.msg === 'Filter failure: MIN_NOTIONAL' ) {\r\n                Binance.options.log( 'Order quantity too small. See exchangeInfo() for minimum amounts' );\r\n            }\r\n            if ( callback ) callback( error, response );\r\n            else Binance.options.log( side + '(' + symbol + ',' + quantity + ',' + price + ') ', response );\r\n        }, 'POST' );\r\n    };\r\n\r\n    /**\r\n     * Create a signed margin order\r\n     * @param {string} side - BUY or SELL\r\n     * @param {string} symbol - The symbol to buy or sell\r\n     * @param {string} quantity - The quantity to buy or sell\r\n     * @param {string} price - The price per unit to transact each unit at\r\n     * @param {object} flags - additional order settings\r\n     * @param {function} callback - the callback function\r\n     * @return {undefined}\r\n     */\r\n    const marginOrder = ( side, symbol, quantity, price, flags = {}, callback = false ) => {\r\n        let endpoint = 'v1/margin/order';\r\n        if ( Binance.options.test ) endpoint += '/test';\r\n        let opt = {\r\n            symbol: symbol,\r\n            side: side,\r\n            type: 'LIMIT',\r\n            quantity: quantity\r\n        };\r\n        if ( typeof flags.type !== 'undefined' ) opt.type = flags.type;\r\n        if (typeof flags.isIsolated !== 'undefined') opt.isIsolated = flags.isIsolated;\r\n        if ( opt.type.includes( 'LIMIT' ) ) {\r\n            opt.price = price;\r\n            if ( opt.type !== 'LIMIT_MAKER' ) {\r\n                opt.timeInForce = 'GTC';\r\n            }\r\n        }\r\n\r\n        if ( typeof flags.timeInForce !== 'undefined' ) opt.timeInForce = flags.timeInForce;\r\n        if ( typeof flags.newOrderRespType !== 'undefined' ) opt.newOrderRespType = flags.newOrderRespType;\r\n        if ( typeof flags.newClientOrderId !== 'undefined' ) opt.newClientOrderId = flags.newClientOrderId;\r\n        if ( typeof flags.sideEffectType !== 'undefined' ) opt.sideEffectType = flags.sideEffectType;\r\n\r\n        /*\r\n         * STOP_LOSS\r\n         * STOP_LOSS_LIMIT\r\n         * TAKE_PROFIT\r\n         * TAKE_PROFIT_LIMIT\r\n         */\r\n        if ( typeof flags.icebergQty !== 'undefined' ) opt.icebergQty = flags.icebergQty;\r\n        if ( typeof flags.stopPrice !== 'undefined' ) {\r\n            opt.stopPrice = flags.stopPrice;\r\n            if ( opt.type === 'LIMIT' ) throw Error( 'stopPrice: Must set \"type\" to one of the following: STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, TAKE_PROFIT_LIMIT' );\r\n        }\r\n        signedRequest( sapi + endpoint, opt, function ( error, response ) {\r\n            if ( !response ) {\r\n                if ( callback ) callback( error, response );\r\n                else Binance.options.log( 'Order() error:', error );\r\n                return;\r\n            }\r\n            if ( typeof response.msg !== 'undefined' && response.msg === 'Filter failure: MIN_NOTIONAL' ) {\r\n                Binance.options.log( 'Order quantity too small. See exchangeInfo() for minimum amounts' );\r\n            }\r\n            if ( callback ) callback( error, response );\r\n            else Binance.options.log( side + '(' + symbol + ',' + quantity + ',' + price + ') ', response );\r\n        }, 'POST' );\r\n    };\r\n\r\n    // Futures internal functions\r\n    const futuresOrder = async ( side, symbol, quantity, price = false, params = {} ) => {\r\n        params.symbol = symbol;\r\n        params.side = side;\r\n        if ( quantity ) params.quantity = quantity;\r\n        // if in the binance futures setting Hedged mode is active, positionSide parameter is mandatory\r\n        if( typeof params.positionSide === 'undefined' && Binance.options.hedgeMode ){\r\n            params.positionSide = side === 'BUY' ? 'LONG' : 'SHORT';\r\n        }\r\n        // LIMIT STOP MARKET STOP_MARKET TAKE_PROFIT TAKE_PROFIT_MARKET\r\n        // reduceOnly stopPrice\r\n        if ( price ) {\r\n            params.price = price;\r\n            if ( typeof params.type === 'undefined' ) params.type = 'LIMIT';\r\n        } else {\r\n            if ( typeof params.type === 'undefined' ) params.type = 'MARKET';\r\n        }\r\n        if ( !params.timeInForce && ( params.type.includes( 'LIMIT' ) || params.type === 'STOP' || params.type === 'TAKE_PROFIT' ) ) {\r\n            params.timeInForce = 'GTX'; // Post only by default. Use GTC for limit orders.\r\n        }\r\n        return promiseRequest( 'v1/order', params, { base:fapi, type:'TRADE', method:'POST' } );\r\n    };\r\n    const deliveryOrder = async ( side, symbol, quantity, price = false, params = {} ) => {\r\n        params.symbol = symbol;\r\n        params.side = side;\r\n        params.quantity = quantity;\r\n        // if in the binance futures setting Hedged mode is active, positionSide parameter is mandatory\r\n        if( Binance.options.hedgeMode ){\r\n            params.positionSide = side === 'BUY' ? 'LONG' : 'SHORT';\r\n        }\r\n        // LIMIT STOP MARKET STOP_MARKET TAKE_PROFIT TAKE_PROFIT_MARKET\r\n        // reduceOnly stopPrice\r\n        if ( price ) {\r\n            params.price = price;\r\n            if ( typeof params.type === 'undefined' ) params.type = 'LIMIT';\r\n        } else {\r\n            if ( typeof params.type === 'undefined' ) params.type = 'MARKET';\r\n        }\r\n        if ( !params.timeInForce && ( params.type.includes( 'LIMIT' ) || params.type === 'STOP' || params.type === 'TAKE_PROFIT' ) ) {\r\n            params.timeInForce = 'GTX'; // Post only by default. Use GTC for limit orders.\r\n        }\r\n        return promiseRequest( 'v1/order', params, { base:dapi, type:'TRADE', method:'POST' } );\r\n    };\r\n    const promiseRequest = async ( url, data = {}, flags = {} ) => {\r\n        return new Promise( ( resolve, reject ) => {\r\n            let query = '', headers = {\r\n                'User-Agent': userAgent,\r\n                'Content-type': 'application/x-www-form-urlencoded'\r\n            };\r\n            if ( typeof flags.method === 'undefined' ) flags.method = 'GET'; // GET POST PUT DELETE\r\n            if ( typeof flags.type === 'undefined' ) flags.type = false; // TRADE, SIGNED, MARKET_DATA, USER_DATA, USER_STREAM\r\n            else {\r\n                if ( typeof data.recvWindow === 'undefined' ) data.recvWindow = Binance.options.recvWindow;\r\n                requireApiKey( 'promiseRequest' );\r\n                headers['X-MBX-APIKEY'] = Binance.options.APIKEY;\r\n            }\r\n            let baseURL = typeof flags.base === 'undefined' ? base : flags.base;\r\n            if ( Binance.options.test && baseURL === fapi ) baseURL = fapiTest;\r\n            if ( Binance.options.test && baseURL === dapi ) baseURL = dapiTest;\r\n            let opt = {\r\n                headers,\r\n                url: baseURL + url,\r\n                method: flags.method,\r\n                timeout: Binance.options.recvWindow,\r\n                followAllRedirects: true\r\n            };\r\n            if ( flags.type === 'SIGNED' || flags.type === 'TRADE' || flags.type === 'USER_DATA' ) {\r\n                if ( !requireApiSecret( 'promiseRequest' ) ) return reject( 'promiseRequest: Invalid API Secret!' );\r\n                data.timestamp = new Date().getTime() + Binance.info.timeOffset;\r\n                query = makeQueryString( data );\r\n                data.signature = crypto.createHmac( 'sha256', Binance.options.APISECRET ).update( query ).digest( 'hex' ); // HMAC hash header\r\n                opt.url = `${ baseURL }${ url }?${ query }&signature=${ data.signature }`;\r\n            }\r\n            opt.qs = data;\r\n            /*if ( flags.method === 'POST' ) {\r\n                opt.form = data;\r\n            } else {\r\n                opt.qs = data;\r\n            }*/\r\n            try {\r\n                request( addProxy( opt ), ( error, response, body ) => {\r\n                    if ( error ) return reject( error );\r\n                    try {\r\n                        Binance.info.lastRequest = new Date().getTime();\r\n                        if ( response ) {\r\n                            Binance.info.statusCode = response.statusCode || 0;\r\n                            if ( response.request ) Binance.info.lastURL = response.request.uri.href;\r\n                            if ( response.headers ) {\r\n                                Binance.info.usedWeight = response.headers['x-mbx-used-weight-1m'] || 0;\r\n                                Binance.info.futuresLatency = response.headers['x-response-time'] || 0;\r\n                            }\r\n                        }\r\n                        if ( !error && response.statusCode == 200 ) return resolve( JSONbig.parse( body ) );\r\n                        if ( typeof response.body !== 'undefined' ) {\r\n                            return resolve( JSONbig.parse( response.body ) );\r\n                        }\r\n                        return reject( response );\r\n                    } catch ( err ) {\r\n                        return reject( `promiseRequest error #${ response.statusCode }` );\r\n                    }\r\n                } ).on( 'error', reject );\r\n            } catch ( err ) {\r\n                return reject( err );\r\n            }\r\n        } );\r\n    };\r\n\r\n    /**\r\n     * No-operation function\r\n     * @return {undefined}\r\n     */\r\n    const noop = () => { }; // Do nothing.\r\n\r\n    /**\r\n     * Reworked Tuitio's heartbeat code into a shared single interval tick\r\n     * @return {undefined}\r\n     */\r\n    const socketHeartbeat = () => {\r\n        /* Sockets removed from `subscriptions` during a manual terminate()\r\n         will no longer be at risk of having functions called on them */\r\n        for ( let endpointId in Binance.subscriptions ) {\r\n            const ws = Binance.subscriptions[endpointId];\r\n            if ( ws.isAlive ) {\r\n                ws.isAlive = false;\r\n                if ( ws.readyState === WebSocket.OPEN ) ws.ping( noop );\r\n            } else {\r\n                if ( Binance.options.verbose ) Binance.options.log( 'Terminating inactive/broken WebSocket: ' + ws.endpoint );\r\n                if ( ws.readyState === WebSocket.OPEN ) ws.terminate();\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Called when socket is opened, subscriptions are registered for later reference\r\n     * @param {function} opened_callback - a callback function\r\n     * @return {undefined}\r\n     */\r\n    const handleSocketOpen = function ( opened_callback ) {\r\n        this.isAlive = true;\r\n        if ( Object.keys( Binance.subscriptions ).length === 0 ) {\r\n            Binance.socketHeartbeatInterval = setInterval( socketHeartbeat, 30000 );\r\n        }\r\n        Binance.subscriptions[this.endpoint] = this;\r\n        if ( typeof opened_callback === 'function' ) opened_callback( this.endpoint );\r\n    };\r\n\r\n    /**\r\n     * Called when socket is closed, subscriptions are de-registered for later reference\r\n     * @param {boolean} reconnect - true or false to reconnect the socket\r\n     * @param {string} code - code associated with the socket\r\n     * @param {string} reason - string with the response\r\n     * @return {undefined}\r\n     */\r\n    const handleSocketClose = function ( reconnect, code, reason ) {\r\n        delete Binance.subscriptions[this.endpoint];\r\n        if ( Binance.subscriptions && Object.keys( Binance.subscriptions ).length === 0 ) {\r\n            clearInterval( Binance.socketHeartbeatInterval );\r\n        }\r\n        Binance.options.log( 'WebSocket closed: ' + this.endpoint +\r\n          ( code ? ' (' + code + ')' : '' ) +\r\n          ( reason ? ' ' + reason : '' ) );\r\n        if ( Binance.options.reconnect && this.reconnect && reconnect ) {\r\n            if ( this.endpoint && parseInt( this.endpoint.length, 10 ) === 60 ) Binance.options.log( 'Account data WebSocket reconnecting...' );\r\n            else Binance.options.log( 'WebSocket reconnecting: ' + this.endpoint + '...' );\r\n            try {\r\n                reconnect();\r\n            } catch ( error ) {\r\n                Binance.options.log( 'WebSocket reconnect error: ' + error.message );\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Called when socket errors\r\n     * @param {object} error - error object message\r\n     * @return {undefined}\r\n     */\r\n    const handleSocketError = function ( error ) {\r\n        /* Errors ultimately result in a `close` event.\r\n         see: https://github.com/websockets/ws/blob/828194044bf247af852b31c49e2800d557fedeff/lib/websocket.js#L126 */\r\n        Binance.options.log( 'WebSocket error: ' + this.endpoint +\r\n          ( error.code ? ' (' + error.code + ')' : '' ) +\r\n          ( error.message ? ' ' + error.message : '' ) );\r\n    };\r\n\r\n    /**\r\n     * Called on each socket heartbeat\r\n     * @return {undefined}\r\n     */\r\n    const handleSocketHeartbeat = function () {\r\n        this.isAlive = true;\r\n    };\r\n\r\n    /**\r\n     * Used to subscribe to a single websocket endpoint\r\n     * @param {string} endpoint - endpoint to connect to\r\n     * @param {function} callback - the function to call when information is received\r\n     * @param {boolean} reconnect - whether to reconnect on disconnect\r\n     * @param {object} opened_callback - the function to call when opened\r\n     * @return {WebSocket} - websocket reference\r\n     */\r\n    const subscribe = function ( endpoint, callback, reconnect = false, opened_callback = false ) {\r\n        let httpsproxy = process.env.https_proxy || false;\r\n        let socksproxy = process.env.socks_proxy || false;\r\n        let ws = false;\r\n\r\n        if ( socksproxy !== false ) {\r\n            socksproxy = proxyReplacewithIp( socksproxy );\r\n            if ( Binance.options.verbose ) Binance.options.log( 'using socks proxy server ' + socksproxy );\r\n            let agent = new SocksProxyAgent( {\r\n                protocol: parseProxy( socksproxy )[0],\r\n                host: parseProxy( socksproxy )[1],\r\n                port: parseProxy( socksproxy )[2]\r\n            } );\r\n            ws = new WebSocket( stream + endpoint, { agent: agent } );\r\n        } else if ( httpsproxy !== false ) {\r\n            let config = url.parse( httpsproxy );\r\n            let agent = new HttpsProxyAgent( config );\r\n            if ( Binance.options.verbose ) Binance.options.log( 'using proxy server ' + agent );\r\n            ws = new WebSocket( stream + endpoint, { agent: agent } );\r\n        } else {\r\n            ws = new WebSocket( stream + endpoint );\r\n        }\r\n\r\n        if ( Binance.options.verbose ) Binance.options.log( 'Subscribed to ' + endpoint );\r\n        ws.reconnect = Binance.options.reconnect;\r\n        ws.endpoint = endpoint;\r\n        ws.isAlive = false;\r\n        ws.on( 'open', handleSocketOpen.bind( ws, opened_callback ) );\r\n        ws.on( 'pong', handleSocketHeartbeat );\r\n        ws.on( 'error', handleSocketError );\r\n        ws.on( 'close', handleSocketClose.bind( ws, reconnect ) );\r\n        ws.on( 'message', data => {\r\n            try {\r\n                callback( JSON.parse( data ) );\r\n            } catch ( error ) {\r\n                Binance.options.log( 'Parse error: ' + error.message );\r\n            }\r\n        } );\r\n        return ws;\r\n    };\r\n\r\n    /**\r\n     * Used to subscribe to a combined websocket endpoint\r\n     * @param {string} streams - streams to connect to\r\n     * @param {function} callback - the function to call when information is received\r\n     * @param {boolean} reconnect - whether to reconnect on disconnect\r\n     * @param {object} opened_callback - the function to call when opened\r\n     * @return {WebSocket} - websocket reference\r\n     */\r\n    const subscribeCombined = function ( streams, callback, reconnect = false, opened_callback = false ) {\r\n        let httpsproxy = process.env.https_proxy || false;\r\n        let socksproxy = process.env.socks_proxy || false;\r\n        const queryParams = streams.join( '/' );\r\n        let ws = false;\r\n        if ( socksproxy !== false ) {\r\n            socksproxy = proxyReplacewithIp( socksproxy );\r\n            if ( Binance.options.verbose ) Binance.options.log( 'using socks proxy server ' + socksproxy );\r\n            let agent = new SocksProxyAgent( {\r\n                protocol: parseProxy( socksproxy )[0],\r\n                host: parseProxy( socksproxy )[1],\r\n                port: parseProxy( socksproxy )[2]\r\n            } );\r\n            ws = new WebSocket( combineStream + queryParams, { agent: agent } );\r\n        } else if ( httpsproxy !== false ) {\r\n            if ( Binance.options.verbose ) Binance.options.log( 'using proxy server ' + httpsproxy );\r\n            let config = url.parse( httpsproxy );\r\n            let agent = new HttpsProxyAgent( config );\r\n            ws = new WebSocket( combineStream + queryParams, { agent: agent } );\r\n        } else {\r\n            ws = new WebSocket( combineStream + queryParams );\r\n        }\r\n\r\n        ws.reconnect = Binance.options.reconnect;\r\n        ws.endpoint = stringHash( queryParams );\r\n        ws.isAlive = false;\r\n        if ( Binance.options.verbose ) {\r\n            Binance.options.log( 'CombinedStream: Subscribed to [' + ws.endpoint + '] ' + queryParams );\r\n        }\r\n        ws.on( 'open', handleSocketOpen.bind( ws, opened_callback ) );\r\n        ws.on( 'pong', handleSocketHeartbeat );\r\n        ws.on( 'error', handleSocketError );\r\n        ws.on( 'close', handleSocketClose.bind( ws, reconnect ) );\r\n        ws.on( 'message', data => {\r\n            try {\r\n                callback( JSON.parse( data ).data );\r\n            } catch ( error ) {\r\n                Binance.options.log( 'CombinedStream: Parse error: ' + error.message );\r\n            }\r\n        } );\r\n        return ws;\r\n    };\r\n\r\n    /**\r\n     * Used to terminate a web socket\r\n     * @param {string} endpoint - endpoint identifier associated with the web socket\r\n     * @param {boolean} reconnect - auto reconnect after termination\r\n     * @return {undefined}\r\n     */\r\n    const terminate = function ( endpoint, reconnect = false ) {\r\n        let ws = Binance.subscriptions[endpoint];\r\n        if ( !ws ) return;\r\n        ws.removeAllListeners( 'message' );\r\n        ws.reconnect = reconnect;\r\n        ws.terminate();\r\n    }\r\n\r\n\r\n    /**\r\n     * Futures heartbeat code with a shared single interval tick\r\n     * @return {undefined}\r\n     */\r\n    const futuresSocketHeartbeat = () => {\r\n        /* Sockets removed from subscriptions during a manual terminate()\r\n         will no longer be at risk of having functions called on them */\r\n        for ( let endpointId in Binance.futuresSubscriptions ) {\r\n            const ws = Binance.futuresSubscriptions[endpointId];\r\n            if ( ws.isAlive ) {\r\n                ws.isAlive = false;\r\n                if ( ws.readyState === WebSocket.OPEN ) ws.ping( noop );\r\n            } else {\r\n                if ( Binance.options.verbose ) Binance.options.log( `Terminating zombie futures WebSocket: ${ ws.endpoint }` );\r\n                if ( ws.readyState === WebSocket.OPEN ) ws.terminate();\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Called when a futures socket is opened, subscriptions are registered for later reference\r\n     * @param {function} openCallback - a callback function\r\n     * @return {undefined}\r\n     */\r\n    const handleFuturesSocketOpen = function ( openCallback ) {\r\n        this.isAlive = true;\r\n        if ( Object.keys( Binance.futuresSubscriptions ).length === 0 ) {\r\n            Binance.socketHeartbeatInterval = setInterval( futuresSocketHeartbeat, 30000 );\r\n        }\r\n        Binance.futuresSubscriptions[this.endpoint] = this;\r\n        if ( typeof openCallback === 'function' ) openCallback( this.endpoint );\r\n    };\r\n\r\n    /**\r\n     * Called when futures websocket is closed, subscriptions are de-registered for later reference\r\n     * @param {boolean} reconnect - true or false to reconnect the socket\r\n     * @param {string} code - code associated with the socket\r\n     * @param {string} reason - string with the response\r\n     * @return {undefined}\r\n     */\r\n    const handleFuturesSocketClose = function ( reconnect, code, reason ) {\r\n        delete Binance.futuresSubscriptions[this.endpoint];\r\n        if ( Binance.futuresSubscriptions && Object.keys( Binance.futuresSubscriptions ).length === 0 ) {\r\n            clearInterval( Binance.socketHeartbeatInterval );\r\n        }\r\n        Binance.options.log( 'Futures WebSocket closed: ' + this.endpoint +\r\n          ( code ? ' (' + code + ')' : '' ) +\r\n          ( reason ? ' ' + reason : '' ) );\r\n        if ( Binance.options.reconnect && this.reconnect && reconnect ) {\r\n            if ( this.endpoint && parseInt( this.endpoint.length, 10 ) === 60 ) Binance.options.log( 'Futures account data WebSocket reconnecting...' );\r\n            else Binance.options.log( 'Futures WebSocket reconnecting: ' + this.endpoint + '...' );\r\n            try {\r\n                reconnect();\r\n            } catch ( error ) {\r\n                Binance.options.log( 'Futures WebSocket reconnect error: ' + error.message );\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Called when a futures websocket errors\r\n     * @param {object} error - error object message\r\n     * @return {undefined}\r\n     */\r\n    const handleFuturesSocketError = function ( error ) {\r\n        Binance.options.log( 'Futures WebSocket error: ' + this.endpoint +\r\n          ( error.code ? ' (' + error.code + ')' : '' ) +\r\n          ( error.message ? ' ' + error.message : '' ) );\r\n    };\r\n\r\n    /**\r\n     * Called on each futures socket heartbeat\r\n     * @return {undefined}\r\n     */\r\n    const handleFuturesSocketHeartbeat = function () {\r\n        this.isAlive = true;\r\n    };\r\n\r\n    /**\r\n     * Used to subscribe to a single futures websocket endpoint\r\n     * @param {string} endpoint - endpoint to connect to\r\n     * @param {function} callback - the function to call when information is received\r\n     * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}\r\n     * @return {WebSocket} - websocket reference\r\n     */\r\n    const futuresSubscribeSingle = function ( endpoint, callback, params = {} ) {\r\n        if ( typeof params === 'boolean' ) params = { reconnect: params };\r\n        if ( !params.reconnect ) params.reconnect = false;\r\n        if ( !params.openCallback ) params.openCallback = false;\r\n        if ( !params.id ) params.id = false;\r\n        let httpsproxy = process.env.https_proxy || false;\r\n        let socksproxy = process.env.socks_proxy || false;\r\n        let ws = false;\r\n\r\n        if ( socksproxy !== false ) {\r\n            socksproxy = proxyReplacewithIp( socksproxy );\r\n            if ( Binance.options.verbose ) Binance.options.log( `futuresSubscribeSingle: using socks proxy server: ${ socksproxy }` );\r\n            let agent = new SocksProxyAgent( {\r\n                protocol: parseProxy( socksproxy )[0],\r\n                host: parseProxy( socksproxy )[1],\r\n                port: parseProxy( socksproxy )[2]\r\n            } );\r\n            ws = new WebSocket( ( Binance.options.test ? fstreamSingleTest : fstreamSingle ) + endpoint, { agent } );\r\n        } else if ( httpsproxy !== false ) {\r\n            if ( Binance.options.verbose ) Binance.options.log( `futuresSubscribeSingle: using proxy server: ${ agent }` );\r\n            let config = url.parse( httpsproxy );\r\n            let agent = new HttpsProxyAgent( config );\r\n            ws = new WebSocket( ( Binance.options.test ? fstreamSingleTest : fstreamSingle ) + endpoint, { agent } );\r\n        } else {\r\n            ws = new WebSocket( ( Binance.options.test ? fstreamSingleTest : fstreamSingle ) + endpoint );\r\n        }\r\n\r\n        if ( Binance.options.verbose ) Binance.options.log( 'futuresSubscribeSingle: Subscribed to ' + endpoint );\r\n        ws.reconnect = Binance.options.reconnect;\r\n        ws.endpoint = endpoint;\r\n        ws.isAlive = false;\r\n        ws.on( 'open', handleFuturesSocketOpen.bind( ws, params.openCallback ) );\r\n        ws.on( 'pong', handleFuturesSocketHeartbeat );\r\n        ws.on( 'error', handleFuturesSocketError );\r\n        ws.on( 'close', handleFuturesSocketClose.bind( ws, params.reconnect ) );\r\n        ws.on( 'message', data => {\r\n            try {\r\n                callback( JSON.parse( data ) );\r\n            } catch ( error ) {\r\n                Binance.options.log( 'Parse error: ' + error.message );\r\n            }\r\n        } );\r\n        return ws;\r\n    };\r\n\r\n    /**\r\n     * Used to subscribe to a combined futures websocket endpoint\r\n     * @param {string} streams - streams to connect to\r\n     * @param {function} callback - the function to call when information is received\r\n     * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}\r\n     * @return {WebSocket} - websocket reference\r\n     */\r\n    const futuresSubscribe = function ( streams, callback, params = {} ) {\r\n        if ( typeof streams === 'string' ) return futuresSubscribeSingle( streams, callback, params );\r\n        if ( typeof params === 'boolean' ) params = { reconnect: params };\r\n        if ( !params.reconnect ) params.reconnect = false;\r\n        if ( !params.openCallback ) params.openCallback = false;\r\n        if ( !params.id ) params.id = false;\r\n        let httpsproxy = process.env.https_proxy || false;\r\n        let socksproxy = process.env.socks_proxy || false;\r\n        const queryParams = streams.join( '/' );\r\n        let ws = false;\r\n        if ( socksproxy !== false ) {\r\n            socksproxy = proxyReplacewithIp( socksproxy );\r\n            if ( Binance.options.verbose ) Binance.options.log( `futuresSubscribe: using socks proxy server ${ socksproxy }` );\r\n            let agent = new SocksProxyAgent( {\r\n                protocol: parseProxy( socksproxy )[0],\r\n                host: parseProxy( socksproxy )[1],\r\n                port: parseProxy( socksproxy )[2]\r\n            } );\r\n            ws = new WebSocket( ( Binance.options.test ? fstreamTest : fstream ) + queryParams, { agent } );\r\n        } else if ( httpsproxy !== false ) {\r\n            if ( Binance.options.verbose ) Binance.options.log( `futuresSubscribe: using proxy server ${ httpsproxy }` );\r\n            let config = url.parse( httpsproxy );\r\n            let agent = new HttpsProxyAgent( config );\r\n            ws = new WebSocket( ( Binance.options.test ? fstreamTest : fstream ) + queryParams, { agent } );\r\n        } else {\r\n            ws = new WebSocket( ( Binance.options.test ? fstreamTest : fstream ) + queryParams );\r\n        }\r\n\r\n        ws.reconnect = Binance.options.reconnect;\r\n        ws.endpoint = stringHash( queryParams );\r\n        ws.isAlive = false;\r\n        if ( Binance.options.verbose ) {\r\n            Binance.options.log( `futuresSubscribe: Subscribed to [${ ws.endpoint }] ${ queryParams }` );\r\n        }\r\n        ws.on( 'open', handleFuturesSocketOpen.bind( ws, params.openCallback ) );\r\n        ws.on( 'pong', handleFuturesSocketHeartbeat );\r\n        ws.on( 'error', handleFuturesSocketError );\r\n        ws.on( 'close', handleFuturesSocketClose.bind( ws, params.reconnect ) );\r\n        ws.on( 'message', data => {\r\n            try {\r\n                callback( JSON.parse( data ).data );\r\n            } catch ( error ) {\r\n                Binance.options.log( `futuresSubscribe: Parse error: ${ error.message }` );\r\n            }\r\n        } );\r\n        return ws;\r\n    };\r\n\r\n    /**\r\n     * Used to terminate a futures websocket\r\n     * @param {string} endpoint - endpoint identifier associated with the web socket\r\n     * @param {boolean} reconnect - auto reconnect after termination\r\n     * @return {undefined}\r\n     */\r\n    const futuresTerminate = function ( endpoint, reconnect = false ) {\r\n        let ws = Binance.futuresSubscriptions[endpoint];\r\n        if ( !ws ) return;\r\n        ws.removeAllListeners( 'message' );\r\n        ws.reconnect = reconnect;\r\n        ws.terminate();\r\n    }\r\n\r\n    /**\r\n     * Combines all futures OHLC data with the latest update\r\n     * @param {string} symbol - the symbol\r\n     * @param {string} interval - time interval\r\n     * @return {array} - interval data for given symbol\r\n     */\r\n    const futuresKlineConcat = ( symbol, interval ) => {\r\n        let output = Binance.futuresTicks[symbol][interval];\r\n        if ( typeof Binance.futuresRealtime[symbol][interval].time === 'undefined' ) return output;\r\n        const time = Binance.futuresRealtime[symbol][interval].time;\r\n        const last_updated = Object.keys( Binance.futuresTicks[symbol][interval] ).pop();\r\n        if ( time >= last_updated ) {\r\n            output[time] = Binance.futuresRealtime[symbol][interval];\r\n            //delete output[time].time;\r\n            output[last_updated].isFinal = true;\r\n            output[time].isFinal = false;\r\n        }\r\n        return output;\r\n    };\r\n\r\n    /**\r\n     * Used for websocket futures @kline\r\n     * @param {string} symbol - the symbol\r\n     * @param {object} kline - object with kline info\r\n     * @param {string} firstTime - time filter\r\n     * @return {undefined}\r\n     */\r\n    const futuresKlineHandler = ( symbol, kline, firstTime = 0 ) => {\r\n        // eslint-disable-next-line no-unused-vars\r\n        let { e: eventType, E: eventTime, k: ticks } = kline;\r\n        // eslint-disable-next-line no-unused-vars\r\n        let { o: open, h: high, l: low, c: close, v: volume, i: interval, x: isFinal, q: quoteVolume, V: takerBuyBaseVolume, Q: takerBuyQuoteVolume, n: trades, t: time, T:closeTime } = ticks;\r\n        if ( time <= firstTime ) return;\r\n        if ( !isFinal ) {\r\n            // if ( typeof Binance.futuresRealtime[symbol][interval].time !== 'undefined' ) {\r\n            //     if ( Binance.futuresRealtime[symbol][interval].time > time ) return;\r\n            // }\r\n            Binance.futuresRealtime[symbol][interval] = { time, closeTime, open, high, low, close, volume, quoteVolume, takerBuyBaseVolume, takerBuyQuoteVolume, trades, isFinal };\r\n            return;\r\n        }\r\n        const first_updated = Object.keys( Binance.futuresTicks[symbol][interval] ).shift();\r\n        if ( first_updated ) delete Binance.futuresTicks[symbol][interval][first_updated];\r\n        Binance.futuresTicks[symbol][interval][time] = { time, closeTime, open, high, low, close, volume, quoteVolume, takerBuyBaseVolume, takerBuyQuoteVolume, trades, isFinal:false };\r\n    };\r\n\r\n    /**\r\n     * Converts the futures liquidation stream data into a friendly object\r\n     * @param {object} data - liquidation data callback data type\r\n     * @return {object} - user friendly data type\r\n     */\r\n    const fLiquidationConvertData = data => {\r\n        let eventType = data.e, eventTime = data.E;\r\n        let {\r\n            s: symbol,\r\n            S: side,\r\n            o: orderType,\r\n            f: timeInForce,\r\n            q: origAmount,\r\n            p: price,\r\n            ap: avgPrice,\r\n            X: orderStatus,\r\n            l: lastFilledQty,\r\n            z: totalFilledQty,\r\n            T: tradeTime\r\n        } = data.o;\r\n        return { symbol, side, orderType, timeInForce, origAmount, price, avgPrice, orderStatus, lastFilledQty, totalFilledQty, eventType, tradeTime, eventTime };\r\n    };\r\n\r\n    /**\r\n     * Converts the futures ticker stream data into a friendly object\r\n     * @param {object} data - user data callback data type\r\n     * @return {object} - user friendly data type\r\n     */\r\n    const fTickerConvertData = data => {\r\n        let friendlyData = data => {\r\n            let {\r\n                e: eventType,\r\n                E: eventTime,\r\n                s: symbol,\r\n                p: priceChange,\r\n                P: percentChange,\r\n                w: averagePrice,\r\n                c: close,\r\n                Q: closeQty,\r\n                o: open,\r\n                h: high,\r\n                l: low,\r\n                v: volume,\r\n                q: quoteVolume,\r\n                O: openTime,\r\n                C: closeTime,\r\n                F: firstTradeId,\r\n                L: lastTradeId,\r\n                n: numTrades\r\n            } = data;\r\n            return {\r\n                eventType,\r\n                eventTime,\r\n                symbol,\r\n                priceChange,\r\n                percentChange,\r\n                averagePrice,\r\n                close,\r\n                closeQty,\r\n                open,\r\n                high,\r\n                low,\r\n                volume,\r\n                quoteVolume,\r\n                openTime,\r\n                closeTime,\r\n                firstTradeId,\r\n                lastTradeId,\r\n                numTrades\r\n            };\r\n        }\r\n        if ( Array.isArray( data ) ) {\r\n            const result = [];\r\n            for ( let obj of data ) {\r\n                result.push( friendlyData( obj ) );\r\n            }\r\n            return result;\r\n        }\r\n        return friendlyData( data );\r\n    }\r\n\r\n    /**\r\n     * Converts the futures miniTicker stream data into a friendly object\r\n     * @param {object} data - user data callback data type\r\n     * @return {object} - user friendly data type\r\n     */\r\n    const fMiniTickerConvertData = data => {\r\n        let friendlyData = data => {\r\n            let {\r\n                e: eventType,\r\n                E: eventTime,\r\n                s: symbol,\r\n                c: close,\r\n                o: open,\r\n                h: high,\r\n                l: low,\r\n                v: volume,\r\n                q: quoteVolume\r\n            } = data;\r\n            return {\r\n                eventType,\r\n                eventTime,\r\n                symbol,\r\n                close,\r\n                open,\r\n                high,\r\n                low,\r\n                volume,\r\n                quoteVolume\r\n            };\r\n        }\r\n        if ( Array.isArray( data ) ) {\r\n            const result = [];\r\n            for ( let obj of data ) {\r\n                result.push( friendlyData( obj ) );\r\n            }\r\n            return result;\r\n        }\r\n        return friendlyData( data );\r\n    }\r\n\r\n    /**\r\n     * Converts the futures bookTicker stream data into a friendly object\r\n     * @param {object} data - user data callback data type\r\n     * @return {object} - user friendly data type\r\n     */\r\n    const fBookTickerConvertData = data => {\r\n        let {\r\n            u: updateId,\r\n            s: symbol,\r\n            b: bestBid,\r\n            B: bestBidQty,\r\n            a: bestAsk,\r\n            A: bestAskQty\r\n        } = data;\r\n        return {\r\n            updateId,\r\n            symbol,\r\n            bestBid,\r\n            bestBidQty,\r\n            bestAsk,\r\n            bestAskQty\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Converts the futures UserData stream MARGIN_CALL data into a friendly object\r\n     * @param {object} data - user data callback data type\r\n     * @return {object} - user friendly data type\r\n     */\r\n    const fUserDataMarginConvertData = data => {\r\n        let {\r\n            e: eventType,\r\n            E: eventTime,\r\n            cw: crossWalletBalance, // only pushed with crossed position margin call\r\n            p: positions\r\n        } = data;\r\n        let positionConverter = position => {\r\n            let {\r\n                s: symbol,\r\n                ps: positionSide,\r\n                pa: positionAmount,\r\n                mt: marginType,\r\n                iw: isolatedWallet, // if isolated position\r\n                mp: markPrice,\r\n                up: unrealizedPnL,\r\n                mm: maintenanceMargin // maintenance margin required\r\n            } = position;\r\n            return {\r\n                symbol,\r\n                positionSide,\r\n                positionAmount,\r\n                marginType,\r\n                isolatedWallet,\r\n                markPrice,\r\n                unrealizedPnL,\r\n                maintenanceMargin\r\n            }\r\n        };\r\n        const convertedPositions = [];\r\n        for ( let position of positions ) {\r\n            convertedPositions.push( positionConverter( position ) );\r\n        }\r\n        positions = convertedPositions;\r\n        return {\r\n            eventType,\r\n            eventTime,\r\n            crossWalletBalance,\r\n            positions\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Converts the futures UserData stream ACCOUNT_CONFIG_UPDATE into a friendly object\r\n     * @param {object} data - user config callback data type\r\n     * @return {object} - user friendly data type\r\n     */\r\n    const fUserConfigDataAccountUpdateConvertData = data => {\r\n        return {\r\n            eventType: data.e,\r\n            eventTime: data.E,\r\n            transactionTime: data.T,\r\n            ac: {\r\n                symbol: data.ac.s,\r\n                leverage: data.ac.l\r\n            }\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Converts the futures UserData stream ACCOUNT_UPDATE data into a friendly object\r\n     * @param {object} data - user data callback data type\r\n     * @return {object} - user friendly data type\r\n     */\r\n    const fUserDataAccountUpdateConvertData = data => {\r\n        let {\r\n            e: eventType,\r\n            E: eventTime,\r\n            T: transaction,\r\n            a: updateData\r\n        } = data;\r\n        let updateConverter = updateData => {\r\n            let {\r\n                m: eventReasonType,\r\n                B: balances,\r\n                P: positions\r\n            } = updateData;\r\n            let positionConverter = position => {\r\n                let {\r\n                    s: symbol,\r\n                    pa: positionAmount,\r\n                    ep: entryPrice,\r\n                    cr: accumulatedRealized, // (Pre-fee) Accumulated Realized\r\n                    up: unrealizedPnL,\r\n                    mt: marginType,\r\n                    iw: isolatedWallet, // if isolated position\r\n                    ps: positionSide\r\n                } = position;\r\n                return {\r\n                    symbol,\r\n                    positionAmount,\r\n                    entryPrice,\r\n                    accumulatedRealized,\r\n                    unrealizedPnL,\r\n                    marginType,\r\n                    isolatedWallet,\r\n                    positionSide\r\n                };\r\n            };\r\n            let balanceConverter = balance => {\r\n                let {\r\n                    a: asset,\r\n                    wb: walletBalance,\r\n                    cw: crossWalletBalance\r\n                } = balance;\r\n                return {\r\n                    asset,\r\n                    walletBalance,\r\n                    crossWalletBalance\r\n                }\r\n            };\r\n\r\n            const balanceResult = [];\r\n            const positionResult = [];\r\n\r\n            for ( let balance of balances ) {\r\n                balanceResult.push( balanceConverter( balance ) );\r\n            }\r\n            for ( let position of positions ) {\r\n                positionResult.push( positionConverter( position ) );\r\n            }\r\n\r\n            balances = balanceResult;\r\n            positions = positionResult;\r\n            return {\r\n                eventReasonType,\r\n                balances,\r\n                positions\r\n            };\r\n        };\r\n        updateData = updateConverter( updateData );\r\n        return {\r\n            eventType,\r\n            eventTime,\r\n            transaction,\r\n            updateData\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Converts the futures UserData stream ORDER_TRADE_UPDATE data into a friendly object\r\n     * @param {object} data - user data callback data type\r\n     * @return {object} - user friendly data type\r\n     */\r\n    const fUserDataOrderUpdateConvertData = data => {\r\n        let {\r\n            e: eventType,\r\n            E: eventTime,\r\n            T: transaction, // transaction time\r\n            o: order\r\n        } = data;\r\n\r\n        let orderConverter = order => {\r\n            let {\r\n                s: symbol,\r\n                c: clientOrderId,\r\n                // special client order id:\r\n                // starts with \"autoclose-\": liquidation order\r\n                // \"adl_autoclose\": ADL auto close order\r\n                S: side,\r\n                o: orderType,\r\n                f: timeInForce,\r\n                q: originalQuantity,\r\n                p: originalPrice,\r\n                ap: averagePrice,\r\n                sp: stopPrice, // please ignore with TRAILING_STOP_MARKET order,\r\n                x: executionType,\r\n                X: orderStatus,\r\n                i: orderId,\r\n                l: orderLastFilledQuantity,\r\n                z: orderFilledAccumulatedQuantity,\r\n                L: lastFilledPrice,\r\n                N: commissionAsset, // will not push if no commission\r\n                n: commission, // will not push if no commission\r\n                T: orderTradeTime,\r\n                t: tradeId,\r\n                b: bidsNotional,\r\n                a: askNotional,\r\n                m: isMakerSide, // is this trade maker side\r\n                R: isReduceOnly, // is this reduce only\r\n                wt: stopPriceWorkingType,\r\n                ot: originalOrderType,\r\n                ps: positionSide,\r\n                cp: closeAll, // if close-all, pushed with conditional order\r\n                AP: activationPrice, // only pushed with TRAILING_STOP_MARKET order\r\n                cr: callbackRate, // only pushed with TRAILING_STOP_MARKET order\r\n                rp: realizedProfit\r\n            } = order;\r\n            return {\r\n                symbol,\r\n                clientOrderId,\r\n                side,\r\n                orderType,\r\n                timeInForce,\r\n                originalQuantity,\r\n                originalPrice,\r\n                averagePrice,\r\n                stopPrice,\r\n                executionType,\r\n                orderStatus,\r\n                orderId,\r\n                orderLastFilledQuantity,\r\n                orderFilledAccumulatedQuantity,\r\n                lastFilledPrice,\r\n                commissionAsset,\r\n                commission,\r\n                orderTradeTime,\r\n                tradeId,\r\n                bidsNotional,\r\n                askNotional,\r\n                isMakerSide,\r\n                isReduceOnly,\r\n                stopPriceWorkingType,\r\n                originalOrderType,\r\n                positionSide,\r\n                closeAll,\r\n                activationPrice,\r\n                callbackRate,\r\n                realizedProfit\r\n            };\r\n        };\r\n        order = orderConverter( order );\r\n        return {\r\n            eventType,\r\n            eventTime,\r\n            transaction,\r\n            order\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Converts the futures markPrice stream data into a friendly object\r\n     * @param {object} data - user data callback data type\r\n     * @return {object} - user friendly data type\r\n     */\r\n    const fMarkPriceConvertData = data => {\r\n        let friendlyData = data => {\r\n            let {\r\n                e: eventType,\r\n                E: eventTime,\r\n                s: symbol,\r\n                p: markPrice,\r\n                i: indexPrice,\r\n                r: fundingRate,\r\n                T: fundingTime\r\n            } = data;\r\n            return {\r\n                eventType,\r\n                eventTime,\r\n                symbol,\r\n                markPrice,\r\n                indexPrice,\r\n                fundingRate,\r\n                fundingTime\r\n            };\r\n        }\r\n        if ( Array.isArray( data ) ) {\r\n            const result = [];\r\n            for ( let obj of data ) {\r\n                result.push( friendlyData( obj ) );\r\n            }\r\n            return result;\r\n        }\r\n        return friendlyData( data );\r\n    }\r\n\r\n    /**\r\n     * Converts the futures aggTrade stream data into a friendly object\r\n     * @param {object} data - user data callback data type\r\n     * @return {object} - user friendly data type\r\n     */\r\n    const fAggTradeConvertData = data => {\r\n        let friendlyData = data => {\r\n            let {\r\n                e: eventType,\r\n                E: eventTime,\r\n                s: symbol,\r\n                a: aggTradeId,\r\n                p: price,\r\n                q: amount,\r\n                f: firstTradeId,\r\n                l: lastTradeId,\r\n                T: timestamp,\r\n                m: maker\r\n            } = data;\r\n            return {\r\n                eventType,\r\n                eventTime,\r\n                symbol,\r\n                aggTradeId,\r\n                price,\r\n                amount,\r\n                total: price * amount,\r\n                firstTradeId,\r\n                lastTradeId,\r\n                timestamp,\r\n                maker\r\n            };\r\n        }\r\n        if ( Array.isArray( data ) ) {\r\n            const result = [];\r\n            for ( let obj of data ) {\r\n                result.push( friendlyData( obj ) );\r\n            }\r\n            return result;\r\n        }\r\n        return friendlyData( data );\r\n    }\r\n\r\n    /**\r\n     * Delivery heartbeat code with a shared single interval tick\r\n     * @return {undefined}\r\n     */\r\n    const deliverySocketHeartbeat = () => {\r\n        /* Sockets removed from subscriptions during a manual terminate()\r\n         will no longer be at risk of having functions called on them */\r\n        for ( let endpointId in Binance.deliverySubscriptions ) {\r\n            const ws = Binance.deliverySubscriptions[endpointId];\r\n            if ( ws.isAlive ) {\r\n                ws.isAlive = false;\r\n                if ( ws.readyState === WebSocket.OPEN ) ws.ping( noop );\r\n            } else {\r\n                if ( Binance.options.verbose ) Binance.options.log( `Terminating zombie delivery WebSocket: ${ ws.endpoint }` );\r\n                if ( ws.readyState === WebSocket.OPEN ) ws.terminate();\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Called when a delivery socket is opened, subscriptions are registered for later reference\r\n     * @param {function} openCallback - a callback function\r\n     * @return {undefined}\r\n     */\r\n    const handleDeliverySocketOpen = function ( openCallback ) {\r\n        this.isAlive = true;\r\n        if ( Object.keys( Binance.deliverySubscriptions ).length === 0 ) {\r\n            Binance.socketHeartbeatInterval = setInterval( deliverySocketHeartbeat, 30000 );\r\n        }\r\n        Binance.deliverySubscriptions[this.endpoint] = this;\r\n        if ( typeof openCallback === 'function' ) openCallback( this.endpoint );\r\n    };\r\n\r\n    /**\r\n     * Called when delivery websocket is closed, subscriptions are de-registered for later reference\r\n     * @param {boolean} reconnect - true or false to reconnect the socket\r\n     * @param {string} code - code associated with the socket\r\n     * @param {string} reason - string with the response\r\n     * @return {undefined}\r\n     */\r\n    const handleDeliverySocketClose = function ( reconnect, code, reason ) {\r\n        delete Binance.deliverySubscriptions[this.endpoint];\r\n        if ( Binance.deliverySubscriptions && Object.keys( Binance.deliverySubscriptions ).length === 0 ) {\r\n            clearInterval( Binance.socketHeartbeatInterval );\r\n        }\r\n        Binance.options.log( 'Delivery WebSocket closed: ' + this.endpoint +\r\n          ( code ? ' (' + code + ')' : '' ) +\r\n          ( reason ? ' ' + reason : '' ) );\r\n        if ( Binance.options.reconnect && this.reconnect && reconnect ) {\r\n            if ( this.endpoint && parseInt( this.endpoint.length, 10 ) === 60 ) Binance.options.log( 'Delivery account data WebSocket reconnecting...' );\r\n            else Binance.options.log( 'Delivery WebSocket reconnecting: ' + this.endpoint + '...' );\r\n            try {\r\n                reconnect();\r\n            } catch ( error ) {\r\n                Binance.options.log( 'Delivery WebSocket reconnect error: ' + error.message );\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Called when a delivery websocket errors\r\n     * @param {object} error - error object message\r\n     * @return {undefined}\r\n     */\r\n    const handleDeliverySocketError = function ( error ) {\r\n        Binance.options.log( 'Delivery WebSocket error: ' + this.endpoint +\r\n          ( error.code ? ' (' + error.code + ')' : '' ) +\r\n          ( error.message ? ' ' + error.message : '' ) );\r\n    };\r\n\r\n    /**\r\n     * Called on each delivery socket heartbeat\r\n     * @return {undefined}\r\n     */\r\n    const handleDeliverySocketHeartbeat = function () {\r\n        this.isAlive = true;\r\n    };\r\n\r\n    /**\r\n     * Used to subscribe to a single delivery websocket endpoint\r\n     * @param {string} endpoint - endpoint to connect to\r\n     * @param {function} callback - the function to call when information is received\r\n     * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}\r\n     * @return {WebSocket} - websocket reference\r\n     */\r\n    const deliverySubscribeSingle = function ( endpoint, callback, params = {} ) {\r\n        if ( typeof params === 'boolean' ) params = { reconnect: params };\r\n        if ( !params.reconnect ) params.reconnect = false;\r\n        if ( !params.openCallback ) params.openCallback = false;\r\n        if ( !params.id ) params.id = false;\r\n        let httpsproxy = process.env.https_proxy || false;\r\n        let socksproxy = process.env.socks_proxy || false;\r\n        let ws = false;\r\n        if ( socksproxy !== false ) {\r\n            socksproxy = proxyReplacewithIp( socksproxy );\r\n            if ( Binance.options.verbose ) Binance.options.log( `deliverySubscribeSingle: using socks proxy server: ${ socksproxy }` );\r\n            let agent = new SocksProxyAgent( {\r\n                protocol: parseProxy( socksproxy )[0],\r\n                host: parseProxy( socksproxy )[1],\r\n                port: parseProxy( socksproxy )[2]\r\n            } );\r\n            ws = new WebSocket( ( Binance.options.test ? dstreamSingleTest : dstreamSingle ) + endpoint, { agent } );\r\n        } else if ( httpsproxy !== false ) {\r\n            if ( Binance.options.verbose ) Binance.options.log( `deliverySubscribeSingle: using proxy server: ${ agent }` );\r\n            let config = url.parse( httpsproxy );\r\n            let agent = new HttpsProxyAgent( config );\r\n            ws = new WebSocket( ( Binance.options.test ? dstreamSingleTest : dstreamSingle ) + endpoint, { agent } );\r\n        } else {\r\n            ws = new WebSocket( ( Binance.options.test ? dstreamSingleTest : dstreamSingle ) + endpoint );\r\n        }\r\n\r\n        if ( Binance.options.verbose ) Binance.options.log( 'deliverySubscribeSingle: Subscribed to ' + endpoint );\r\n        ws.reconnect = Binance.options.reconnect;\r\n        ws.endpoint = endpoint;\r\n        ws.isAlive = false;\r\n        ws.on( 'open', handleDeliverySocketOpen.bind( ws, params.openCallback ) );\r\n        ws.on( 'pong', handleDeliverySocketHeartbeat );\r\n        ws.on( 'error', handleDeliverySocketError );\r\n        ws.on( 'close', handleDeliverySocketClose.bind( ws, params.reconnect ) );\r\n        ws.on( 'message', data => {\r\n            try {\r\n                callback( JSON.parse( data ) );\r\n            } catch ( error ) {\r\n                Binance.options.log( 'Parse error: ' + error.message );\r\n            }\r\n        } );\r\n        return ws;\r\n    };\r\n\r\n    /**\r\n     * Used to subscribe to a combined delivery websocket endpoint\r\n     * @param {string} streams - streams to connect to\r\n     * @param {function} callback - the function to call when information is received\r\n     * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}\r\n     * @return {WebSocket} - websocket reference\r\n     */\r\n    const deliverySubscribe = function ( streams, callback, params = {} ) {\r\n        if ( typeof streams === 'string' ) return deliverySubscribeSingle( streams, callback, params );\r\n        if ( typeof params === 'boolean' ) params = { reconnect: params };\r\n        if ( !params.reconnect ) params.reconnect = false;\r\n        if ( !params.openCallback ) params.openCallback = false;\r\n        if ( !params.id ) params.id = false;\r\n        let httpsproxy = process.env.https_proxy || false;\r\n        let socksproxy = process.env.socks_proxy || false;\r\n        const queryParams = streams.join( '/' );\r\n        let ws = false;\r\n        if ( socksproxy !== false ) {\r\n            socksproxy = proxyReplacewithIp( socksproxy );\r\n            if ( Binance.options.verbose ) Binance.options.log( `deliverySubscribe: using socks proxy server ${ socksproxy }` );\r\n            let agent = new SocksProxyAgent( {\r\n                protocol: parseProxy( socksproxy )[0],\r\n                host: parseProxy( socksproxy )[1],\r\n                port: parseProxy( socksproxy )[2]\r\n            } );\r\n            ws = new WebSocket( ( Binance.options.test ? dstreamTest : dstream ) + queryParams, { agent } );\r\n        } else if ( httpsproxy !== false ) {\r\n            if ( Binance.options.verbose ) Binance.options.log( `deliverySubscribe: using proxy server ${ httpsproxy }` );\r\n            let config = url.parse( httpsproxy );\r\n            let agent = new HttpsProxyAgent( config );\r\n            ws = new WebSocket( ( Binance.options.test ? dstreamTest : dstream ) + queryParams, { agent } );\r\n        } else {\r\n            ws = new WebSocket( ( Binance.options.test ? dstreamTest : dstream ) + queryParams );\r\n        }\r\n\r\n        ws.reconnect = Binance.options.reconnect;\r\n        ws.endpoint = stringHash( queryParams );\r\n        ws.isAlive = false;\r\n        if ( Binance.options.verbose ) {\r\n            Binance.options.log( `deliverySubscribe: Subscribed to [${ ws.endpoint }] ${ queryParams }` );\r\n        }\r\n        ws.on( 'open', handleDeliverySocketOpen.bind( ws, params.openCallback ) );\r\n        ws.on( 'pong', handleDeliverySocketHeartbeat );\r\n        ws.on( 'error', handleDeliverySocketError );\r\n        ws.on( 'close', handleDeliverySocketClose.bind( ws, params.reconnect ) );\r\n        ws.on( 'message', data => {\r\n            try {\r\n                callback( JSON.parse( data ).data );\r\n            } catch ( error ) {\r\n                Binance.options.log( `deliverySubscribe: Parse error: ${ error.message }` );\r\n            }\r\n        } );\r\n        return ws;\r\n    };\r\n\r\n    /**\r\n     * Used to terminate a delivery websocket\r\n     * @param {string} endpoint - endpoint identifier associated with the web socket\r\n     * @param {boolean} reconnect - auto reconnect after termination\r\n     * @return {undefined}\r\n     */\r\n    const deliveryTerminate = function ( endpoint, reconnect = false ) {\r\n        let ws = Binance.deliverySubscriptions[endpoint];\r\n        if ( !ws ) return;\r\n        ws.removeAllListeners( 'message' );\r\n        ws.reconnect = reconnect;\r\n        ws.terminate();\r\n    }\r\n\r\n    /**\r\n     * Combines all delivery OHLC data with the latest update\r\n     * @param {string} symbol - the symbol\r\n     * @param {string} interval - time interval\r\n     * @return {array} - interval data for given symbol\r\n     */\r\n    const deliveryKlineConcat = ( symbol, interval ) => {\r\n        let output = Binance.deliveryTicks[symbol][interval];\r\n        if ( typeof Binance.deliveryRealtime[symbol][interval].time === 'undefined' ) return output;\r\n        const time = Binance.deliveryRealtime[symbol][interval].time;\r\n        const last_updated = Object.keys( Binance.deliveryTicks[symbol][interval] ).pop();\r\n        if ( time >= last_updated ) {\r\n            output[time] = Binance.deliveryRealtime[symbol][interval];\r\n            //delete output[time].time;\r\n            output[last_updated].isFinal = true;\r\n            output[time].isFinal = false;\r\n        }\r\n        return output;\r\n    };\r\n\r\n    /**\r\n     * Used for websocket delivery @kline\r\n     * @param {string} symbol - the symbol\r\n     * @param {object} kline - object with kline info\r\n     * @param {string} firstTime - time filter\r\n     * @return {undefined}\r\n     */\r\n    const deliveryKlineHandler = ( symbol, kline, firstTime = 0 ) => {\r\n        // eslint-disable-next-line no-unused-vars\r\n        let { e: eventType, E: eventTime, k: ticks } = kline;\r\n        // eslint-disable-next-line no-unused-vars\r\n        let { o: open, h: high, l: low, c: close, v: volume, i: interval, x: isFinal, q: quoteVolume, V: takerBuyBaseVolume, Q: takerBuyQuoteVolume, n: trades, t: time, T:closeTime } = ticks;\r\n        if ( time <= firstTime ) return;\r\n        if ( !isFinal ) {\r\n            // if ( typeof Binance.futuresRealtime[symbol][interval].time !== 'undefined' ) {\r\n            //     if ( Binance.futuresRealtime[symbol][interval].time > time ) return;\r\n            // }\r\n            Binance.deliveryRealtime[symbol][interval] = { time, closeTime, open, high, low, close, volume, quoteVolume, takerBuyBaseVolume, takerBuyQuoteVolume, trades, isFinal };\r\n            return;\r\n        }\r\n        const first_updated = Object.keys( Binance.deliveryTicks[symbol][interval] ).shift();\r\n        if ( first_updated ) delete Binance.deliveryTicks[symbol][interval][first_updated];\r\n        Binance.deliveryTicks[symbol][interval][time] = { time, closeTime, open, high, low, close, volume, quoteVolume, takerBuyBaseVolume, takerBuyQuoteVolume, trades, isFinal:false };\r\n    };\r\n\r\n    /**\r\n     * Converts the delivery liquidation stream data into a friendly object\r\n     * @param {object} data - liquidation data callback data type\r\n     * @return {object} - user friendly data type\r\n     */\r\n    const dLiquidationConvertData = data => {\r\n        let eventType = data.e, eventTime = data.E;\r\n        let {\r\n            s: symbol,\r\n            S: side,\r\n            o: orderType,\r\n            f: timeInForce,\r\n            q: origAmount,\r\n            p: price,\r\n            ap: avgPrice,\r\n            X: orderStatus,\r\n            l: lastFilledQty,\r\n            z: totalFilledQty,\r\n            T: tradeTime\r\n        } = data.o;\r\n        return { symbol, side, orderType, timeInForce, origAmount, price, avgPrice, orderStatus, lastFilledQty, totalFilledQty, eventType, tradeTime, eventTime };\r\n    };\r\n\r\n    /**\r\n     * Converts the delivery ticker stream data into a friendly object\r\n     * @param {object} data - user data callback data type\r\n     * @return {object} - user friendly data type\r\n     */\r\n    const dTickerConvertData = data => {\r\n        let friendlyData = data => {\r\n            let {\r\n                e: eventType,\r\n                E: eventTime,\r\n                s: symbol,\r\n                p: priceChange,\r\n                P: percentChange,\r\n                w: averagePrice,\r\n                c: close,\r\n                Q: closeQty,\r\n                o: open,\r\n                h: high,\r\n                l: low,\r\n                v: volume,\r\n                q: quoteVolume,\r\n                O: openTime,\r\n                C: closeTime,\r\n                F: firstTradeId,\r\n                L: lastTradeId,\r\n                n: numTrades\r\n            } = data;\r\n            return {\r\n                eventType,\r\n                eventTime,\r\n                symbol,\r\n                priceChange,\r\n                percentChange,\r\n                averagePrice,\r\n                close,\r\n                closeQty,\r\n                open,\r\n                high,\r\n                low,\r\n                volume,\r\n                quoteVolume,\r\n                openTime,\r\n                closeTime,\r\n                firstTradeId,\r\n                lastTradeId,\r\n                numTrades\r\n            };\r\n        }\r\n        if ( Array.isArray( data ) ) {\r\n            const result = [];\r\n            for ( let obj of data ) {\r\n                result.push( friendlyData( obj ) );\r\n            }\r\n            return result;\r\n        }\r\n        return friendlyData( data );\r\n    }\r\n\r\n    /**\r\n     * Converts the delivery miniTicker stream data into a friendly object\r\n     * @param {object} data - user data callback data type\r\n     * @return {object} - user friendly data type\r\n     */\r\n    const dMiniTickerConvertData = data => {\r\n        let friendlyData = data => {\r\n            let {\r\n                e: eventType,\r\n                E: eventTime,\r\n                s: symbol,\r\n                c: close,\r\n                o: open,\r\n                h: high,\r\n                l: low,\r\n                v: volume,\r\n                q: quoteVolume\r\n            } = data;\r\n            return {\r\n                eventType,\r\n                eventTime,\r\n                symbol,\r\n                close,\r\n                open,\r\n                high,\r\n                low,\r\n                volume,\r\n                quoteVolume\r\n            };\r\n        }\r\n        if ( Array.isArray( data ) ) {\r\n            const result = [];\r\n            for ( let obj of data ) {\r\n                result.push( friendlyData( obj ) );\r\n            }\r\n            return result;\r\n        }\r\n        return friendlyData( data );\r\n    }\r\n\r\n    /**\r\n     * Converts the delivery bookTicker stream data into a friendly object\r\n     * @param {object} data - user data callback data type\r\n     * @return {object} - user friendly data type\r\n     */\r\n    const dBookTickerConvertData = data => {\r\n        let {\r\n            u: updateId,\r\n            s: symbol,\r\n            b: bestBid,\r\n            B: bestBidQty,\r\n            a: bestAsk,\r\n            A: bestAskQty\r\n        } = data;\r\n        return {\r\n            updateId,\r\n            symbol,\r\n            bestBid,\r\n            bestBidQty,\r\n            bestAsk,\r\n            bestAskQty\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Converts the delivery markPrice stream data into a friendly object\r\n     * @param {object} data - user data callback data type\r\n     * @return {object} - user friendly data type\r\n     */\r\n    const dMarkPriceConvertData = data => {\r\n        let friendlyData = data => {\r\n            let {\r\n                e: eventType,\r\n                E: eventTime,\r\n                s: symbol,\r\n                p: markPrice,\r\n                r: fundingRate,\r\n                T: fundingTime\r\n            } = data;\r\n            return {\r\n                eventType,\r\n                eventTime,\r\n                symbol,\r\n                markPrice,\r\n                fundingRate,\r\n                fundingTime\r\n            };\r\n        }\r\n        if ( Array.isArray( data ) ) {\r\n            const result = [];\r\n            for ( let obj of data ) {\r\n                result.push( friendlyData( obj ) );\r\n            }\r\n            return result;\r\n        }\r\n        return friendlyData( data );\r\n    }\r\n\r\n    /**\r\n     * Converts the delivery aggTrade stream data into a friendly object\r\n     * @param {object} data - user data callback data type\r\n     * @return {object} - user friendly data type\r\n     */\r\n    const dAggTradeConvertData = data => {\r\n        let friendlyData = data => {\r\n            let {\r\n                e: eventType,\r\n                E: eventTime,\r\n                s: symbol,\r\n                a: aggTradeId,\r\n                p: price,\r\n                q: amount,\r\n                f: firstTradeId,\r\n                l: lastTradeId,\r\n                T: timestamp,\r\n                m: maker\r\n            } = data;\r\n            return {\r\n                eventType,\r\n                eventTime,\r\n                symbol,\r\n                aggTradeId,\r\n                price,\r\n                amount,\r\n                total: price * amount,\r\n                firstTradeId,\r\n                lastTradeId,\r\n                timestamp,\r\n                maker\r\n            };\r\n        }\r\n        if ( Array.isArray( data ) ) {\r\n            const result = [];\r\n            for ( let obj of data ) {\r\n                result.push( friendlyData( obj ) );\r\n            }\r\n            return result;\r\n        }\r\n        return friendlyData( data );\r\n    }\r\n\r\n    /**\r\n   * Converts the delivery UserData stream ORDER_TRADE_UPDATE data into a friendly object\r\n   * @param {object} data - user data callback data type\r\n   * @return {object} - user friendly data type\r\n   */\r\n    const dUserDataOrderUpdateConvertData = ( data ) => {\r\n        let {\r\n            e: eventType,\r\n            E: eventTime,\r\n            T: transaction, // transaction time\r\n            o: order,\r\n        } = data;\r\n\r\n        let orderConverter = ( order ) => {\r\n            let {\r\n                s: symbol,\r\n                c: clientOrderId,\r\n                // special client order id:\r\n                // starts with \"autoclose-\": liquidation order\r\n                // \"adl_autoclose\": ADL auto close order\r\n                S: side,\r\n                o: orderType,\r\n                f: timeInForce,\r\n                q: originalQuantity,\r\n                p: originalPrice,\r\n                ap: averagePrice,\r\n                sp: stopPrice, // please ignore with TRAILING_STOP_MARKET order,\r\n                x: executionType,\r\n                X: orderStatus,\r\n                i: orderId,\r\n                l: orderLastFilledQuantity,\r\n                z: orderFilledAccumulatedQuantity,\r\n                L: lastFilledPrice,\r\n                ma: marginAsset,\r\n                N: commissionAsset, // will not push if no commission\r\n                n: commission, // will not push if no commission\r\n                T: orderTradeTime,\r\n                t: tradeId,\r\n                rp: realizedProfit,\r\n                b: bidsNotional,\r\n                a: askNotional,\r\n                m: isMakerSide, // is this trade maker side\r\n                R: isReduceOnly, // is this reduce only\r\n                wt: stopPriceWorkingType,\r\n                ot: originalOrderType,\r\n                ps: positionSide,\r\n                cp: closeAll, // if close-all, pushed with conditional order\r\n                AP: activationPrice, // only pushed with TRAILING_STOP_MARKET order\r\n                cr: callbackRate, // only pushed with TRAILING_STOP_MARKET order\r\n                pP: priceProtect, // If conditional order trigger is protected\r\n            } = order;\r\n            return {\r\n                symbol,\r\n                clientOrderId,\r\n                side,\r\n                orderType,\r\n                timeInForce,\r\n                originalQuantity,\r\n                originalPrice,\r\n                averagePrice,\r\n                stopPrice,\r\n                executionType,\r\n                orderStatus,\r\n                orderId,\r\n                orderLastFilledQuantity,\r\n                orderFilledAccumulatedQuantity,\r\n                lastFilledPrice,\r\n                marginAsset,\r\n                commissionAsset,\r\n                commission,\r\n                orderTradeTime,\r\n                tradeId,\r\n                bidsNotional,\r\n                askNotional,\r\n                isMakerSide,\r\n                isReduceOnly,\r\n                stopPriceWorkingType,\r\n                originalOrderType,\r\n                positionSide,\r\n                closeAll,\r\n                activationPrice,\r\n                callbackRate,\r\n                realizedProfit,\r\n                priceProtect,\r\n            };\r\n        };\r\n        order = orderConverter( order );\r\n        return {\r\n            eventType,\r\n            eventTime,\r\n            transaction,\r\n            order,\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Used as part of the user data websockets callback\r\n     * @param {object} data - user data callback data type\r\n     * @return {undefined}\r\n     */\r\n    const userDataHandler = data => {\r\n        let type = data.e;\r\n        if ( type === 'outboundAccountInfo' ) {\r\n            // XXX: Deprecated in 2020-09-08\r\n        } else if ( type === 'executionReport' ) {\r\n            if ( Binance.options.execution_callback ) Binance.options.execution_callback( data );\r\n        } else if ( type === 'listStatus' ) {\r\n            if ( Binance.options.list_status_callback ) Binance.options.list_status_callback( data );\r\n        } else if ( type === 'outboundAccountPosition' ) {\r\n            Binance.options.balance_callback( data );\r\n        } else {\r\n            Binance.options.log( 'Unexpected userData: ' + type );\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Used as part of the user data websockets callback\r\n     * @param {object} data - user data callback data type\r\n     * @return {undefined}\r\n     */\r\n    const userMarginDataHandler = data => {\r\n        let type = data.e;\r\n        if ( type === 'outboundAccountInfo' ) {\r\n            // XXX: Deprecated in 2020-09-08\r\n        } else if ( type === 'executionReport' ) {\r\n            if ( Binance.options.margin_execution_callback ) Binance.options.margin_execution_callback( data );\r\n        } else if ( type === 'listStatus' ) {\r\n            if ( Binance.options.margin_list_status_callback ) Binance.options.margin_list_status_callback( data );\r\n        } else if ( type === 'outboundAccountPosition' ) {\r\n            Binance.options.margin_balance_callback( data );\r\n        } else {\r\n            Binance.options.log( 'Unexpected userMarginData: ' + type );\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Used as part of the user data websockets callback\r\n     * @param {object} data - user data callback data type\r\n     * @return {undefined}\r\n     */\r\n    const userFutureDataHandler = data => {\r\n        let type = data.e;\r\n        if ( type === 'MARGIN_CALL' ) {\r\n            Binance.options.future_margin_call_callback( fUserDataMarginConvertData( data ) );\r\n        } else if ( type === 'ACCOUNT_UPDATE' ) {\r\n            if ( Binance.options.future_account_update_callback ) {\r\n                Binance.options.future_account_update_callback( fUserDataAccountUpdateConvertData( data ) );\r\n            }\r\n        } else if ( type === 'ORDER_TRADE_UPDATE' ) {\r\n            if ( Binance.options.future_order_update_callback ) {\r\n                Binance.options.future_order_update_callback( fUserDataOrderUpdateConvertData( data ) );\r\n            }\r\n        } else if ( type === 'ACCOUNT_CONFIG_UPDATE' ) {\r\n            if ( Binance.options.future_account_config_update_callback ) {\r\n                Binance.options.future_account_config_update_callback( fUserConfigDataAccountUpdateConvertData( data ) );\r\n            }\r\n        } else {\r\n            Binance.options.log( 'Unexpected userFutureData: ' + type );\r\n        }\r\n    };\r\n\r\n    /**\r\n   * Used as part of the user data websockets callback\r\n   * @param {object} data - user data callback data type\r\n   * @return {undefined}\r\n   */\r\n    const userDeliveryDataHandler = ( data ) => {\r\n        let type = data.e;\r\n        if ( type === \"MARGIN_CALL\" ) {\r\n            Binance.options.delivery_margin_call_callback(\r\n                fUserDataMarginConvertData( data )\r\n            );\r\n        } else if ( type === \"ACCOUNT_UPDATE\" ) {\r\n            if ( Binance.options.delivery_account_update_callback ) {\r\n                Binance.options.delivery_account_update_callback(\r\n                    fUserDataAccountUpdateConvertData( data )\r\n                );\r\n            }\r\n        } else if ( type === \"ORDER_TRADE_UPDATE\" ) {\r\n            if ( Binance.options.delivery_order_update_callback ) {\r\n                Binance.options.delivery_order_update_callback(\r\n                    dUserDataOrderUpdateConvertData( data )\r\n                );\r\n            }\r\n        } else {\r\n            Binance.options.log( \"Unexpected userDeliveryData: \" + type );\r\n        }\r\n    };\r\n\r\n    /**\r\n   * Transfer between main account and futures/delivery accounts\r\n   * @param {string} asset - the asset\r\n   * @param {number} amount - the asset\r\n   * @param {function} callback - the callback function\r\n   * @param {object} options - additional options\r\n   * @return {undefined}\r\n   */\r\n    const transferBetweenMainAndFutures = function (\r\n        asset,\r\n        amount,\r\n        type,\r\n        callback\r\n    ) {\r\n        let parameters = Object.assign( {\r\n            asset,\r\n            amount,\r\n            type,\r\n        } );\r\n        if ( !callback ) {\r\n            return new Promise( ( resolve, reject ) => {\r\n                signedRequest(\r\n                    sapi + \"v1/futures/transfer\",\r\n                    parameters,\r\n                    function ( error, data ) {\r\n                        if ( error ) return reject( error );\r\n                        return resolve( data );\r\n                    },\r\n                    \"POST\"\r\n                );\r\n            } );\r\n        }\r\n        signedRequest(\r\n            sapi + \"v1/futures/transfer\",\r\n            parameters,\r\n            function ( error, data ) {\r\n                if ( callback ) return callback( error, data );\r\n            },\r\n            \"POST\"\r\n        );\r\n    };\r\n\r\n    /**\r\n     * Converts the previous day stream into friendly object\r\n     * @param {object} data - user data callback data type\r\n     * @return {object} - user friendly data type\r\n     */\r\n    const prevDayConvertData = data => {\r\n        let convertData = data => {\r\n            let {\r\n                e: eventType,\r\n                E: eventTime,\r\n                s: symbol,\r\n                p: priceChange,\r\n                P: percentChange,\r\n                w: averagePrice,\r\n                x: prevClose,\r\n                c: close,\r\n                Q: closeQty,\r\n                b: bestBid,\r\n                B: bestBidQty,\r\n                a: bestAsk,\r\n                A: bestAskQty,\r\n                o: open,\r\n                h: high,\r\n                l: low,\r\n                v: volume,\r\n                q: quoteVolume,\r\n                O: openTime,\r\n                C: closeTime,\r\n                F: firstTradeId,\r\n                L: lastTradeId,\r\n                n: numTrades\r\n            } = data;\r\n            return {\r\n                eventType,\r\n                eventTime,\r\n                symbol,\r\n                priceChange,\r\n                percentChange,\r\n                averagePrice,\r\n                prevClose,\r\n                close,\r\n                closeQty,\r\n                bestBid,\r\n                bestBidQty,\r\n                bestAsk,\r\n                bestAskQty,\r\n                open,\r\n                high,\r\n                low,\r\n                volume,\r\n                quoteVolume,\r\n                openTime,\r\n                closeTime,\r\n                firstTradeId,\r\n                lastTradeId,\r\n                numTrades\r\n            };\r\n        }\r\n        if ( Array.isArray( data ) ) {\r\n            const result = [];\r\n            for ( let obj of data ) {\r\n                let converted = convertData( obj );\r\n                result.push( converted );\r\n            }\r\n            return result;\r\n            // eslint-disable-next-line no-else-return\r\n        } else {\r\n            return convertData( data );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses the previous day stream and calls the user callback with friendly object\r\n     * @param {object} data - user data callback data type\r\n     * @param {function} callback - user data callback data type\r\n     * @return {undefined}\r\n     */\r\n    const prevDayStreamHandler = ( data, callback ) => {\r\n        const converted = prevDayConvertData( data );\r\n        callback( null, converted );\r\n    };\r\n\r\n    /**\r\n     * Gets the price of a given symbol or symbols\r\n     * @param {array} data - array of symbols\r\n     * @return {array} - symbols with their current prices\r\n     */\r\n    const priceData = ( data ) => {\r\n        const prices = {};\r\n        if ( Array.isArray( data ) ) {\r\n            for ( let obj of data ) {\r\n                prices[obj.symbol] = obj.price;\r\n            }\r\n        } else { // Single price returned\r\n            prices[data.symbol] = data.price;\r\n        }\r\n        return prices;\r\n    };\r\n\r\n    /**\r\n     * Used by bookTickers to format the bids and asks given given symbols\r\n     * @param {array} data - array of symbols\r\n     * @return {object} - symbols with their bids and asks data\r\n     */\r\n    const bookPriceData = data => {\r\n        let prices = {};\r\n        for ( let obj of data ) {\r\n            prices[obj.symbol] = {\r\n                bid: obj.bidPrice,\r\n                bids: obj.bidQty,\r\n                ask: obj.askPrice,\r\n                asks: obj.askQty\r\n            };\r\n        }\r\n        return prices;\r\n    };\r\n\r\n    /**\r\n     * Used by balance to get the balance data\r\n     * @param {array} data - account info object\r\n     * @return {object} - balances hel with available, onorder amounts\r\n     */\r\n    const balanceData = data => {\r\n        let balances = {};\r\n        if ( typeof data === 'undefined' ) return {};\r\n        if ( typeof data.balances === 'undefined' ) {\r\n            Binance.options.log( 'balanceData error', data );\r\n            return {};\r\n        }\r\n        for ( let obj of data.balances ) {\r\n            balances[obj.asset] = { available: obj.free, onOrder: obj.locked };\r\n        }\r\n        return balances;\r\n    };\r\n\r\n    /**\r\n     * Used by web sockets depth and populates OHLC and info\r\n     * @param {string} symbol - symbol to get candlestick info\r\n     * @param {string} interval - time interval, 1m, 3m, 5m ....\r\n     * @param {array} ticks - tick array\r\n     * @return {undefined}\r\n     */\r\n    const klineData = ( symbol, interval, ticks ) => { // Used for /depth\r\n        let last_time = 0;\r\n        if ( isIterable( ticks ) ) {\r\n            for ( let tick of ticks ) {\r\n                // eslint-disable-next-line no-unused-vars\r\n                let [ time, open, high, low, close, volume, closeTime, assetVolume, trades, buyBaseVolume, buyAssetVolume, ignored ] = tick;\r\n                Binance.ohlc[symbol][interval][time] = { open: open, high: high, low: low, close: close, volume: volume };\r\n                last_time = time;\r\n            }\r\n\r\n            Binance.info[symbol][interval].timestamp = last_time;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Combines all OHLC data with latest update\r\n     * @param {string} symbol - the symbol\r\n     * @param {string} interval - time interval, 1m, 3m, 5m ....\r\n     * @return {array} - interval data for given symbol\r\n     */\r\n    const klineConcat = ( symbol, interval ) => {\r\n        let output = Binance.ohlc[symbol][interval];\r\n        if ( typeof Binance.ohlcLatest[symbol][interval].time === 'undefined' ) return output;\r\n        const time = Binance.ohlcLatest[symbol][interval].time;\r\n        const last_updated = Object.keys( Binance.ohlc[symbol][interval] ).pop();\r\n        if ( time >= last_updated ) {\r\n            output[time] = Binance.ohlcLatest[symbol][interval];\r\n            delete output[time].time;\r\n            output[time].isFinal = false;\r\n        }\r\n        return output;\r\n    };\r\n\r\n    /**\r\n     * Used for websocket @kline\r\n     * @param {string} symbol - the symbol\r\n     * @param {object} kline - object with kline info\r\n     * @param {string} firstTime - time filter\r\n     * @return {undefined}\r\n     */\r\n    const klineHandler = ( symbol, kline, firstTime = 0 ) => {\r\n        // TODO: add Taker buy base asset volume\r\n        // eslint-disable-next-line no-unused-vars\r\n        let { e: eventType, E: eventTime, k: ticks } = kline;\r\n        // eslint-disable-next-line no-unused-vars\r\n        let { o: open, h: high, l: low, c: close, v: volume, i: interval, x: isFinal, q: quoteVolume, t: time } = ticks; //n:trades, V:buyVolume, Q:quoteBuyVolume\r\n        if ( time <= firstTime ) return;\r\n        if ( !isFinal ) {\r\n            if ( typeof Binance.ohlcLatest[symbol][interval].time !== 'undefined' ) {\r\n                if ( Binance.ohlcLatest[symbol][interval].time > time ) return;\r\n            }\r\n            Binance.ohlcLatest[symbol][interval] = { open: open, high: high, low: low, close: close, volume: volume, time: time };\r\n            return;\r\n        }\r\n        // Delete an element from the beginning so we don't run out of memory\r\n        const first_updated = Object.keys( Binance.ohlc[symbol][interval] ).shift();\r\n        if ( first_updated ) delete Binance.ohlc[symbol][interval][first_updated];\r\n        Binance.ohlc[symbol][interval][time] = { open: open, high: high, low: low, close: close, volume: volume };\r\n    };\r\n\r\n\r\n    /**\r\n     * Used by futures websockets chart cache\r\n     * @param {string} symbol - symbol to get candlestick info\r\n     * @param {string} interval - time interval, 1m, 3m, 5m ....\r\n     * @param {array} ticks - tick array\r\n     * @return {undefined}\r\n     */\r\n    const futuresKlineData = ( symbol, interval, ticks ) => {\r\n        let last_time = 0;\r\n        if ( isIterable( ticks ) ) {\r\n            for ( let tick of ticks ) {\r\n                // eslint-disable-next-line no-unused-vars\r\n                let [ time, open, high, low, close, volume, closeTime, quoteVolume, trades, takerBuyBaseVolume, takerBuyQuoteVolume, ignored ] = tick;\r\n                Binance.futuresTicks[symbol][interval][time] = { time, closeTime, open, high, low, close, volume, quoteVolume, takerBuyBaseVolume, takerBuyQuoteVolume, trades };\r\n                last_time = time;\r\n            }\r\n            Binance.futuresMeta[symbol][interval].timestamp = last_time;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Used by delivery websockets chart cache\r\n     * @param {string} symbol - symbol to get candlestick info\r\n     * @param {string} interval - time interval, 1m, 3m, 5m ....\r\n     * @param {array} ticks - tick array\r\n     * @return {undefined}\r\n     */\r\n    const deliveryKlineData = ( symbol, interval, ticks ) => {\r\n        let last_time = 0;\r\n        if ( isIterable( ticks ) ) {\r\n            for ( let tick of ticks ) {\r\n                // eslint-disable-next-line no-unused-vars\r\n                let [ time, open, high, low, close, volume, closeTime, quoteVolume, trades, takerBuyBaseVolume, takerBuyQuoteVolume, ignored ] = tick;\r\n                Binance.deliveryTicks[symbol][interval][time] = { time, closeTime, open, high, low, close, volume, quoteVolume, takerBuyBaseVolume, takerBuyQuoteVolume, trades };\r\n                last_time = time;\r\n            }\r\n            Binance.deliveryMeta[symbol][interval].timestamp = last_time;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Used for /depth endpoint\r\n     * @param {object} data - containing the bids and asks\r\n     * @return {undefined}\r\n     */\r\n    const depthData = data => {\r\n        if ( !data ) return { bids: [], asks: [] };\r\n        let bids = {}, asks = {}, obj;\r\n        if ( typeof data.bids !== 'undefined' ) {\r\n            for ( obj of data.bids ) {\r\n                bids[obj[0]] = parseFloat( obj[1] );\r\n            }\r\n        }\r\n        if ( typeof data.asks !== 'undefined' ) {\r\n            for ( obj of data.asks ) {\r\n                asks[obj[0]] = parseFloat( obj[1] );\r\n            }\r\n        }\r\n        return { lastUpdateId: data.lastUpdateId, bids: bids, asks: asks };\r\n    }\r\n\r\n    /**\r\n     * Used for /depth endpoint\r\n     * @param {object} depth - information\r\n     * @return {undefined}\r\n     */\r\n    const depthHandler = depth => {\r\n        let symbol = depth.s, obj;\r\n        let context = Binance.depthCacheContext[symbol];\r\n        let updateDepthCache = () => {\r\n            Binance.depthCache[symbol].eventTime = depth.E;\r\n            for ( obj of depth.b ) { //bids\r\n                if ( obj[1] === '0.00000000' ) {\r\n                    delete Binance.depthCache[symbol].bids[obj[0]];\r\n                } else {\r\n                    Binance.depthCache[symbol].bids[obj[0]] = parseFloat( obj[1] );\r\n                }\r\n            }\r\n            for ( obj of depth.a ) { //asks\r\n                if ( obj[1] === '0.00000000' ) {\r\n                    delete Binance.depthCache[symbol].asks[obj[0]];\r\n                } else {\r\n                    Binance.depthCache[symbol].asks[obj[0]] = parseFloat( obj[1] );\r\n                }\r\n            }\r\n            context.skipCount = 0;\r\n            context.lastEventUpdateId = depth.u;\r\n            context.lastEventUpdateTime = depth.E;\r\n        };\r\n\r\n        // This now conforms 100% to the Binance docs constraints on managing a local order book\r\n        if ( context.lastEventUpdateId ) {\r\n            const expectedUpdateId = context.lastEventUpdateId + 1;\r\n            if ( depth.U <= expectedUpdateId ) {\r\n                updateDepthCache();\r\n            } else {\r\n                let msg = 'depthHandler: [' + symbol + '] The depth cache is out of sync.';\r\n                msg += ' Symptom: Unexpected Update ID. Expected \"' + expectedUpdateId + '\", got \"' + depth.U + '\"';\r\n                if ( Binance.options.verbose ) Binance.options.log( msg );\r\n                throw new Error( msg );\r\n            }\r\n        } else if ( depth.U > context.snapshotUpdateId + 1 ) {\r\n            /* In this case we have a gap between the data of the stream and the snapshot.\r\n             This is an out of sync error, and the connection must be torn down and reconnected. */\r\n            let msg = 'depthHandler: [' + symbol + '] The depth cache is out of sync.';\r\n            msg += ' Symptom: Gap between snapshot and first stream data.';\r\n            if ( Binance.options.verbose ) Binance.options.log( msg );\r\n            throw new Error( msg );\r\n        } else if ( depth.u < context.snapshotUpdateId + 1 ) {\r\n            /* In this case we've received data that we've already had since the snapshot.\r\n             This isn't really an issue, and we can just update the cache again, or ignore it entirely. */\r\n\r\n            // do nothing\r\n        } else {\r\n            // This is our first legal update from the stream data\r\n            updateDepthCache();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Gets depth cache for given symbol\r\n     * @param {string} symbol - the symbol to fetch\r\n     * @return {object} - the depth cache object\r\n     */\r\n    const getDepthCache = symbol => {\r\n        if ( typeof Binance.depthCache[symbol] === 'undefined' ) return { bids: {}, asks: {} };\r\n        return Binance.depthCache[symbol];\r\n    };\r\n\r\n    /**\r\n     * Calculate Buy/Sell volume from DepthCache\r\n     * @param {string} symbol - the symbol to fetch\r\n     * @return {object} - the depth volume cache object\r\n     */\r\n    const depthVolume = symbol => {\r\n        let cache = getDepthCache( symbol ), quantity, price;\r\n        let bidbase = 0, askbase = 0, bidqty = 0, askqty = 0;\r\n        for ( price in cache.bids ) {\r\n            quantity = cache.bids[price];\r\n            bidbase += parseFloat( ( quantity * parseFloat( price ) ).toFixed( 8 ) );\r\n            bidqty += quantity;\r\n        }\r\n        for ( price in cache.asks ) {\r\n            quantity = cache.asks[price];\r\n            askbase += parseFloat( ( quantity * parseFloat( price ) ).toFixed( 8 ) );\r\n            askqty += quantity;\r\n        }\r\n        return { bids: bidbase, asks: askbase, bidQty: bidqty, askQty: askqty };\r\n    };\r\n\r\n    /**\r\n     * Checks whether or not an array contains any duplicate elements\r\n     * @param {array} array - the array to check\r\n     * @return {boolean} - true or false\r\n     */\r\n    const isArrayUnique = array => {\r\n        return new Set( array ).size === array.length;\r\n    };\r\n    return {\r\n        /**\r\n        * Gets depth cache for given symbol\r\n        * @param {symbol} symbol - get depch cache for this symbol\r\n        * @return {object} - object\r\n        */\r\n        depthCache: symbol => {\r\n            return getDepthCache( symbol );\r\n        },\r\n\r\n        /**\r\n        * Gets depth volume for given symbol\r\n        * @param {symbol} symbol - get depch volume for this symbol\r\n        * @return {object} - object\r\n        */\r\n        depthVolume: symbol => {\r\n            return depthVolume( symbol );\r\n        },\r\n\r\n        /**\r\n        * Count decimal places\r\n        * @param {float} float - get the price precision point\r\n        * @return {int} - number of place\r\n        */\r\n        getPrecision: function ( float ) {\r\n            if ( !float || Number.isInteger( float ) ) return 0;\r\n            return float.toString().split( '.' )[1].length || 0;\r\n        },\r\n\r\n        /**\r\n        * rounds number with given step\r\n        * @param {float} qty - quantity to round\r\n        * @param {float} stepSize - stepSize as specified by exchangeInfo\r\n        * @return {float} - number\r\n        */\r\n        roundStep: function ( qty, stepSize ) {\r\n            // Integers do not require rounding\r\n            if ( Number.isInteger( qty ) ) return qty;\r\n            const qtyString = qty.toFixed( 16 );\r\n            const desiredDecimals = Math.max( stepSize.indexOf( '1' ) - 1, 0 );\r\n            const decimalIndex = qtyString.indexOf( '.' );\r\n            return parseFloat( qtyString.slice( 0, decimalIndex + desiredDecimals + 1 ) );\r\n        },\r\n\r\n        /**\r\n        * rounds price to required precision\r\n        * @param {float} price - price to round\r\n        * @param {float} tickSize - tickSize as specified by exchangeInfo\r\n        * @return {float} - number\r\n        */\r\n        roundTicks: function ( price, tickSize ) {\r\n            const formatter = new Intl.NumberFormat( 'en-US', { style: 'decimal', minimumFractionDigits: 0, maximumFractionDigits: 8 } );\r\n            const precision = formatter.format( tickSize ).split( '.' )[1].length || 0;\r\n            if ( typeof price === 'string' ) price = parseFloat( price );\r\n            return price.toFixed( precision );\r\n        },\r\n\r\n        /**\r\n        * Gets percentage of given numbers\r\n        * @param {float} min - the smaller number\r\n        * @param {float} max - the bigger number\r\n        * @param {int} width - percentage width\r\n        * @return {float} - percentage\r\n        */\r\n        percent: function ( min, max, width = 100 ) {\r\n            return ( min * 0.01 ) / ( max * 0.01 ) * width;\r\n        },\r\n\r\n        /**\r\n        * Gets the sum of an array of numbers\r\n        * @param {array} array - the number to add\r\n        * @return {float} - sum\r\n        */\r\n        sum: function ( array ) {\r\n            return array.reduce( ( a, b ) => a + b, 0 );\r\n        },\r\n\r\n        /**\r\n        * Reverses the keys of an object\r\n        * @param {object} object - the object\r\n        * @return {object} - the object\r\n        */\r\n        reverse: function ( object ) {\r\n            let range = Object.keys( object ).reverse(), output = {};\r\n            for ( let price of range ) {\r\n                output[price] = object[price];\r\n            }\r\n            return output;\r\n        },\r\n\r\n        /**\r\n        * Converts an object to an array\r\n        * @param {object} obj - the object\r\n        * @return {array} - the array\r\n        */\r\n        array: function( obj ) {\r\n            return Object.keys( obj ).map( function ( key ) {\r\n                return [ Number( key ), obj[key] ];\r\n            } );\r\n        },\r\n\r\n        /**\r\n        * Sorts bids\r\n        * @param {string} symbol - the object\r\n        * @param {int} max - the max number of bids\r\n        * @param {string} baseValue - the object\r\n        * @return {object} - the object\r\n        */\r\n        sortBids: function ( symbol, max = Infinity, baseValue = false ) {\r\n            let object = {}, count = 0, cache;\r\n            if ( typeof symbol === 'object' ) cache = symbol;\r\n            else cache = getDepthCache( symbol ).bids;\r\n            const sorted = Object.keys( cache ).sort( ( a, b ) => parseFloat( b ) - parseFloat( a ) );\r\n            let cumulative = 0;\r\n            for ( let price of sorted ) {\r\n                if ( !baseValue ) object[price] = cache[price];\r\n                else if ( baseValue === 'cumulative' ) {\r\n                    cumulative += cache[price];\r\n                    object[price] = cumulative;\r\n                } else object[price] = parseFloat( ( cache[price] * parseFloat( price ) ).toFixed( 8 ) );\r\n                if ( ++count >= max ) break;\r\n            }\r\n            return object;\r\n        },\r\n\r\n        /**\r\n        * Sorts asks\r\n        * @param {string} symbol - the object\r\n        * @param {int} max - the max number of bids\r\n        * @param {string} baseValue - the object\r\n        * @return {object} - the object\r\n        */\r\n        sortAsks: function ( symbol, max = Infinity, baseValue = false ) {\r\n            let object = {}, count = 0, cache;\r\n            if ( typeof symbol === 'object' ) cache = symbol;\r\n            else cache = getDepthCache( symbol ).asks;\r\n            const sorted = Object.keys( cache ).sort( ( a, b ) => parseFloat( a ) - parseFloat( b ) );\r\n            let cumulative = 0;\r\n            for ( let price of sorted ) {\r\n                if ( !baseValue ) object[price] = cache[price];\r\n                else if ( baseValue === 'cumulative' ) {\r\n                    cumulative += cache[price];\r\n                    object[price] = cumulative;\r\n                } else object[price] = parseFloat( ( cache[price] * parseFloat( price ) ).toFixed( 8 ) );\r\n                if ( ++count >= max ) break;\r\n            }\r\n            return object;\r\n        },\r\n\r\n        /**\r\n        * Returns the first property of an object\r\n        * @param {object} object - the object to get the first member\r\n        * @return {string} - the object key\r\n        */\r\n        first: function ( object ) {\r\n            return Object.keys( object ).shift();\r\n        },\r\n\r\n        /**\r\n        * Returns the last property of an object\r\n        * @param {object} object - the object to get the first member\r\n        * @return {string} - the object key\r\n        */\r\n        last: function ( object ) {\r\n            return Object.keys( object ).pop();\r\n        },\r\n\r\n        /**\r\n        * Returns an array of properties starting at start\r\n        * @param {object} object - the object to get the properties form\r\n        * @param {int} start - the starting index\r\n        * @return {array} - the array of entires\r\n        */\r\n        slice: function ( object, start = 0 ) {\r\n            return Object.keys( object ).slice( start );\r\n        },\r\n\r\n        /**\r\n        * Gets the minimum key form object\r\n        * @param {object} object - the object to get the properties form\r\n        * @return {string} - the minimum key\r\n        */\r\n        min: function ( object ) {\r\n            return Math.min.apply( Math, Object.keys( object ) );\r\n        },\r\n\r\n        /**\r\n        * Gets the maximum key form object\r\n        * @param {object} object - the object to get the properties form\r\n        * @return {string} - the minimum key\r\n        */\r\n        max: function ( object ) {\r\n            return Math.max.apply( Math, Object.keys( object ) );\r\n        },\r\n\r\n        /**\r\n        * Sets an option given a key and value\r\n        * @param {string} key - the key to set\r\n        * @param {object} value - the value of the key\r\n        * @return {undefined}\r\n        */\r\n        setOption: function ( key, value ) {\r\n            Binance.options[key] = value;\r\n        },\r\n\r\n        /**\r\n        * Gets an option given a key\r\n        * @param {string} key - the key to set\r\n        * @return {undefined}\r\n        */\r\n        getOption: key => Binance.options[key],\r\n\r\n        /**\r\n        * Returns the entire info object\r\n        * @return {object} - the info object\r\n        */\r\n        getInfo: () => Binance.info,\r\n\r\n        /**\r\n        * Returns the used weight from the last request\r\n        * @return {object} - 1m weight used\r\n        */\r\n        usedWeight: () => Binance.info.usedWeight,\r\n\r\n        /**\r\n        * Returns the status code from the last http response\r\n        * @return {object} - status code\r\n        */\r\n        statusCode: () => Binance.info.statusCode,\r\n\r\n        /**\r\n        * Returns the ping time from the last futures request\r\n        * @return {object} - latency/ping (2ms)\r\n        */\r\n        futuresLatency: () => Binance.info.futuresLatency,\r\n\r\n        /**\r\n        * Returns the complete URL from the last request\r\n        * @return {object} - http address including query string\r\n        */\r\n        lastURL: () => Binance.info.lastURL,\r\n\r\n        /**\r\n        * Returns the order count from the last request\r\n        * @return {object} - orders allowed per 1m\r\n        */\r\n        orderCount: () => Binance.info.orderCount1m,\r\n\r\n        /**\r\n        * Returns the entire options object\r\n        * @return {object} - the options object\r\n        */\r\n        getOptions: () => Binance.options,\r\n\r\n        /**\r\n        * Gets an option given a key\r\n        * @param {object} opt - the object with the class configuration\r\n        * @param {function} callback - the callback function\r\n        * @return {undefined}\r\n        */\r\n        options: setOptions,\r\n\r\n        /**\r\n        * Creates an order\r\n        * @param {string} side - BUY or SELL\r\n        * @param {string} symbol - the symbol to buy\r\n        * @param {numeric} quantity - the quantity required\r\n        * @param {numeric} price - the price to pay for each unit\r\n        * @param {object} flags - aadditionalbuy order flags\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        order: function ( side, symbol, quantity, price, flags = {}, callback = false ) {\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    order( side, symbol, quantity, price, flags, callback );\r\n                } )\r\n            } else {\r\n                order( side, symbol, quantity, price, flags, callback );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Creates a buy order\r\n        * @param {string} symbol - the symbol to buy\r\n        * @param {numeric} quantity - the quantity required\r\n        * @param {numeric} price - the price to pay for each unit\r\n        * @param {object} flags - additional buy order flags\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        buy: function( symbol, quantity, price, flags = {}, callback = false ) {\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    order( 'BUY', symbol, quantity, price, flags, callback );\r\n                } )\r\n            } else {\r\n                order( 'BUY', symbol, quantity, price, flags, callback );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Creates a sell order\r\n        * @param {string} symbol - the symbol to sell\r\n        * @param {numeric} quantity - the quantity required\r\n        * @param {numeric} price - the price to sell each unit for\r\n        * @param {object} flags - additional order flags\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        sell: function ( symbol, quantity, price, flags = {}, callback = false ) {\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    order( 'SELL', symbol, quantity, price, flags, callback );\r\n                } )\r\n            } else {\r\n                order( 'SELL', symbol, quantity, price, flags, callback );\r\n            }\r\n\r\n        },\r\n\r\n        /**\r\n        * Creates a market buy order\r\n        * @param {string} symbol - the symbol to buy\r\n        * @param {numeric} quantity - the quantity required\r\n        * @param {object} flags - additional buy order flags\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        marketBuy: function ( symbol, quantity, flags = { type: 'MARKET' }, callback = false ) {\r\n            if ( typeof flags === 'function' ) { // Accept callback as third parameter\r\n                callback = flags;\r\n                flags = { type: 'MARKET' };\r\n            }\r\n            if ( typeof flags.type === 'undefined' ) flags.type = 'MARKET';\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    order( 'BUY', symbol, quantity, 0, flags, callback );\r\n                } )\r\n            } else {\r\n                order( 'BUY', symbol, quantity, 0, flags, callback );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Creates a market sell order\r\n        * @param {string} symbol - the symbol to sell\r\n        * @param {numeric} quantity - the quantity required\r\n        * @param {object} flags - additional sell order flags\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n       marketSell: function ( symbol, quantity, flags = { type: 'MARKET' }, callback = false ) {\r\n            if ( typeof flags === 'function' ) { // Accept callback as third parameter\r\n                callback = flags;\r\n                flags = { type: 'MARKET' };\r\n            }\r\n            if ( typeof flags.type === 'undefined' ) flags.type = 'MARKET';\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    order( 'SELL', symbol, quantity, 0, flags, callback );\r\n                } )\r\n            } else {\r\n                order( 'SELL', symbol, quantity, 0, flags, callback );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Cancels an order\r\n        * @param {string} symbol - the symbol to cancel\r\n        * @param {string} orderid - the orderid to cancel\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        cancel: function ( symbol, orderid, callback = false ) {\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    signedRequest( base + 'v3/order', { symbol: symbol, orderId: orderid }, function ( error, data ) {\r\n                        return callback.call( this, error, data, symbol );\r\n                    }, 'DELETE' );\r\n                } )\r\n            } else {\r\n                signedRequest( base + 'v3/order', { symbol: symbol, orderId: orderid }, function ( error, data ) {\r\n                    return callback.call( this, error, data, symbol );\r\n                }, 'DELETE' );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Gets the status of an order\r\n        * @param {string} symbol - the symbol to check\r\n        * @param {string} orderid - the orderid to check\r\n        * @param {function} callback - the callback function\r\n        * @param {object} flags - any additional flags\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        orderStatus: function ( symbol, orderid, callback, flags = {} ) {\r\n            let parameters = Object.assign( { symbol: symbol, orderId: orderid }, flags );\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    signedRequest( base + 'v3/order', parameters, function ( error, data ) {\r\n                        return callback.call( this, error, data, symbol );\r\n                    } );\r\n                } )\r\n            } else {\r\n                signedRequest( base + 'v3/order', parameters, function ( error, data ) {\r\n                    return callback.call( this, error, data, symbol );\r\n                } );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Gets open orders\r\n        * @param {string} symbol - the symbol to get\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        openOrders: function ( symbol, callback ) {\r\n            let parameters = symbol ? { symbol: symbol } : {};\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    signedRequest( base + 'v3/openOrders', parameters, function ( error, data ) {\r\n                        return callback.call( this, error, data, symbol );\r\n                    } );\r\n                } )\r\n            } else {\r\n                signedRequest( base + 'v3/openOrders', parameters, function ( error, data ) {\r\n                    return callback.call( this, error, data, symbol );\r\n                } );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Cancels all orders of a given symbol\r\n        * @param {string} symbol - the symbol to cancel all orders for\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        cancelAll: function ( symbol, callback = false ) {\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    signedRequest( base + 'v3/openOrders', { symbol }, callback, 'DELETE' );\r\n                } )\r\n            } else {\r\n                signedRequest( base + 'v3/openOrders', { symbol }, callback, 'DELETE' );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Cancels all orders of a given symbol\r\n        * @param {string} symbol - the symbol to cancel all orders for\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        cancelOrders: function ( symbol, callback = false ) {\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    signedRequest( base + 'v3/openOrders', { symbol }, function ( error, json ) {\r\n                        if ( json.length === 0 ) {\r\n                            return callback.call( this, 'No orders present for this symbol', {}, symbol );\r\n                        }\r\n                        for ( let obj of json ) {\r\n                            let quantity = obj.origQty - obj.executedQty;\r\n                            Binance.options.log( 'cancel order: ' + obj.side + ' ' + symbol + ' ' + quantity + ' @ ' + obj.price + ' #' + obj.orderId );\r\n                            signedRequest( base + 'v3/order', { symbol, orderId: obj.orderId }, function ( error, data ) {\r\n                                return callback.call( this, error, data, symbol );\r\n                            }, 'DELETE' );\r\n                        }\r\n                    } );\r\n                } )\r\n            } else {\r\n                signedRequest( base + 'v3/openOrders', { symbol: symbol }, function ( error, json ) {\r\n                    if ( json.length === 0 ) {\r\n                        return callback.call( this, 'No orders present for this symbol', {}, symbol );\r\n                    }\r\n                    for ( let obj of json ) {\r\n                        let quantity = obj.origQty - obj.executedQty;\r\n                        Binance.options.log( 'cancel order: ' + obj.side + ' ' + symbol + ' ' + quantity + ' @ ' + obj.price + ' #' + obj.orderId );\r\n                        signedRequest( base + 'v3/order', { symbol: symbol, orderId: obj.orderId }, function ( error, data ) {\r\n                            return callback.call( this, error, data, symbol );\r\n                        }, 'DELETE' );\r\n                    }\r\n                } );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Gets all order of a given symbol\r\n        * @param {string} symbol - the symbol\r\n        * @param {function} callback - the callback function (can also accept options)\r\n        * @param {object} options - additional options\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        allOrders: function ( symbol, callback, options = {} ) {\r\n            let parameters = Object.assign( { symbol }, options );\r\n            if ( typeof callback == 'object' ) { // Allow second parameter to be options\r\n                options = callback;\r\n                callback = false;\r\n            }\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    signedRequest( base + 'v3/allOrders', parameters, function ( error, data ) {\r\n                        return callback.call( this, error, data, symbol );\r\n                    } );\r\n                } )\r\n            } else {\r\n                signedRequest( base + 'v3/allOrders', parameters, function ( error, data ) {\r\n                    return callback.call( this, error, data, symbol );\r\n                } );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Gets the depth information for a given symbol\r\n        * @param {string} symbol - the symbol\r\n        * @param {function} callback - the callback function\r\n        * @param {int} limit - limit the number of returned orders\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        depth: function ( symbol, callback, limit = 100 ) {\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    publicRequest( base + 'v3/depth', { symbol: symbol, limit: limit }, function ( error, data ) {\r\n                        return callback.call( this, error, depthData( data ), symbol );\r\n                    } );\r\n                } )\r\n            } else {\r\n                publicRequest( base + 'v3/depth', { symbol: symbol, limit: limit }, function ( error, data ) {\r\n                    return callback.call( this, error, depthData( data ), symbol );\r\n                } );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Gets the average prices of a given symbol\r\n        * @param {string} symbol - the symbol\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        avgPrice: function ( symbol, callback = false ) {\r\n            let opt = {\r\n                url: base + 'v3/avgPrice?symbol=' + symbol,\r\n                timeout: Binance.options.recvWindow\r\n            };\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    request( addProxy( opt ), ( error, response, body ) => {\r\n                        if ( error ) return reject( error );\r\n                        if ( response.statusCode !== 200 ) return reject( response );\r\n                        let result = {};\r\n                        result[symbol] = JSON.parse( response.body ).price;\r\n                        return resolve( result );\r\n                    } ).on( 'error', reject );\r\n                } );\r\n            }\r\n            request( addProxy( opt ), ( error, response, body ) => {\r\n                if ( error ) return callback( error );\r\n                if ( response.statusCode !== 200 ) return callback( response );\r\n                let result = {};\r\n                result[symbol] = JSON.parse( response.body ).price;\r\n                return callback( null, result );\r\n            } ).on( 'error', callback );\r\n        },\r\n\r\n        /**\r\n        * Gets the prices of a given symbol(s)\r\n        * @param {string} symbol - the symbol\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        prices: function ( symbol, callback = false ) {\r\n            const params = typeof symbol === 'string' ? '?symbol=' + symbol : '';\r\n            if ( typeof symbol === 'function' ) callback = symbol; // backwards compatibility\r\n\r\n            let opt = {\r\n                url: base + 'v3/ticker/price' + params,\r\n                timeout: Binance.options.recvWindow\r\n            };\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    request( addProxy( opt ), ( error, response, body ) => {\r\n                        if ( error ) return reject( error );\r\n                        if ( response.statusCode !== 200 ) return reject( response );\r\n                        return resolve( priceData( JSON.parse( body ) ) );\r\n                    } ).on( 'error', reject );\r\n                } );\r\n            }\r\n            request( addProxy( opt ), ( error, response, body ) => {\r\n                if ( error ) return callback( error );\r\n                if ( response.statusCode !== 200 ) return callback( response );\r\n                return callback( null, priceData( JSON.parse( body ) ) );\r\n            } ).on( 'error', callback );\r\n        },\r\n\r\n        /**\r\n        * Gets the book tickers of given symbol(s)\r\n        * @param {string} symbol - the symbol\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        bookTickers: function ( symbol, callback ) {\r\n            const params = typeof symbol === 'string' ? '?symbol=' + symbol : '';\r\n            if ( typeof symbol === 'function' ) callback = symbol; // backwards compatibility\r\n            let opt = {\r\n                url: base + 'v3/ticker/bookTicker' + params,\r\n                timeout: Binance.options.recvWindow\r\n            };\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    request( addProxy( opt ), function ( error, response, body ) {\r\n                        if ( error ) return reject( error );\r\n                        if ( response.statusCode !== 200 ) return reject( response );\r\n                        const result = symbol ? JSON.parse( body ) : bookPriceData( JSON.parse( body ) );\r\n                        return resolve( result );\r\n                    } ).on( 'error', reject );\r\n                } );\r\n            }\r\n            request( addProxy( opt ), ( error, response, body ) => {\r\n                if ( error ) return callback( error );\r\n                if ( response.statusCode !== 200 ) return callback( response );\r\n                const result = symbol ? JSON.parse( body ) : bookPriceData( JSON.parse( body ) );\r\n                return callback( null, result );\r\n            } ).on( 'error', callback );\r\n        },\r\n\r\n        /**\r\n        * Gets the prevday percentage change\r\n        * @param {string} symbol - the symbol or symbols\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        prevDay: function ( symbol, callback ) {\r\n            let input = symbol ? { symbol: symbol } : {};\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    publicRequest( base + 'v3/ticker/24hr', input, ( error, data ) => {\r\n                        return callback.call( this, error, data, symbol );\r\n                    } );\r\n                } )\r\n            } else {\r\n                publicRequest( base + 'v3/ticker/24hr', input, ( error, data ) => {\r\n                    return callback.call( this, error, data, symbol );\r\n                } );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Gets the the exchange info\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        exchangeInfo: function ( callback ) {\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    publicRequest( base + 'v3/exchangeInfo', {}, callback );\r\n                } )\r\n            } else {\r\n                publicRequest( base + 'v3/exchangeInfo', {}, callback );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Gets the dust log for user\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        dustLog: function ( callback ) {\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    signedRequest( wapi + '/v3/userAssetDribbletLog.html', {}, callback );\r\n                } )\r\n            } else {\r\n                signedRequest( wapi + '/v3/userAssetDribbletLog.html', {}, callback );\r\n            }\r\n        },\r\n\r\n        dustTransfer: function ( assets, callback ) {\r\n            signedRequest( sapi + 'v1/asset/dust', { asset: assets }, callback, 'POST' );\r\n        },\r\n\r\n        assetDividendRecord: function ( callback, params = {} ) {\r\n            signedRequest( sapi + 'v1/asset/assetDividend', params, callback );\r\n        },\r\n\r\n        /**\r\n        * Gets the the system status\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        systemStatus: function ( callback ) {\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    publicRequest( wapi + 'v3/systemStatus.html', {}, callback );\r\n                } )\r\n            } else {\r\n                publicRequest( wapi + 'v3/systemStatus.html', {}, callback );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Withdraws asset to given wallet id\r\n        * @param {string} asset - the asset symbol\r\n        * @param {string} address - the wallet to transfer it to\r\n        * @param {number} amount - the amount to transfer\r\n        * @param {string} addressTag - and addtional address tag\r\n        * @param {function} callback - the callback function\r\n        * @param {string} name - the name to save the address as. Set falsy to prevent Binance saving to address book\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        withdraw: function ( asset, address, amount, addressTag = false, callback = false, name = false ) {\r\n            let params = { asset, address, amount };\r\n            if ( name ) params.name = name;\r\n            if ( addressTag ) params.addressTag = addressTag;\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    signedRequest( wapi + 'v3/withdraw.html', params, callback, 'POST' );\r\n                } )\r\n            } else {\r\n                signedRequest( wapi + 'v3/withdraw.html', params, callback, 'POST' );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Get the Withdraws history for a given asset\r\n        * @param {function} callback - the callback function\r\n        * @param {object} params - supports limit and fromId parameters\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        withdrawHistory: function ( callback, params = {} ) {\r\n            if ( typeof params === 'string' ) params = { asset: params };\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    signedRequest( wapi + 'v3/withdrawHistory.html', params, callback );\r\n                } )\r\n            } else {\r\n                signedRequest( wapi + 'v3/withdrawHistory.html', params, callback );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Get the deposit history\r\n        * @param {function} callback - the callback function\r\n        * @param {object} params - additional params\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        depositHistory: function ( callback, params = {} ) {\r\n            if ( typeof params === 'string' ) params = { asset: params }; // Support 'asset' (string) or optional parameters (object)\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    signedRequest( wapi + 'v3/depositHistory.html', params, callback );\r\n                } )\r\n            } else {\r\n                signedRequest( wapi + 'v3/depositHistory.html', params, callback );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Get the deposit history for given asset\r\n        * @param {string} asset - the asset\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        depositAddress: function ( asset, callback ) {\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    signedRequest( wapi + 'v3/depositAddress.html', { asset: asset }, callback );\r\n                } )\r\n            } else {\r\n                signedRequest( wapi + 'v3/depositAddress.html', { asset: asset }, callback );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Get the account status\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        accountStatus: function ( callback ) {\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    signedRequest( wapi + 'v3/accountStatus.html', {}, callback );\r\n                } )\r\n            } else {\r\n                signedRequest( wapi + 'v3/accountStatus.html', {}, callback );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Get the trade fee\r\n        * @param {function} callback - the callback function\r\n        * @param {string} symbol (optional)\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        tradeFee: function ( callback, symbol = false ) {\r\n            let params = symbol ? { symbol: symbol } : {};\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    signedRequest( wapi + 'v3/tradeFee.html', params, callback );\r\n                } )\r\n            } else {\r\n                signedRequest( wapi + 'v3/tradeFee.html', params, callback );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Fetch asset detail (minWithdrawAmount, depositStatus, withdrawFee, withdrawStatus, depositTip)\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        assetDetail: function ( callback ) {\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    signedRequest( wapi + 'v3/assetDetail.html', {}, callback );\r\n                } )\r\n            } else {\r\n                signedRequest( wapi + 'v3/assetDetail.html', {}, callback );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Get the account\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        account: function ( callback ) {\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    signedRequest( base + 'v3/account', {}, callback );\r\n                } )\r\n            } else {\r\n                signedRequest( base + 'v3/account', {}, callback );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Get the balance data\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        balance: function ( callback ) {\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    signedRequest( base + 'v3/account', {}, function ( error, data ) {\r\n                        callback( error, balanceData( data ) );\r\n                    } );\r\n                } )\r\n            } else {\r\n                signedRequest( base + 'v3/account', {}, function ( error, data ) {\r\n                    callback( error, balanceData( data ) );\r\n                } );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Get trades for a given symbol\r\n        * @param {string} symbol - the symbol\r\n        * @param {function} callback - the callback function\r\n        * @param {object} options - additional options\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        trades: ( symbol, callback, options = {} ) => {\r\n            let parameters = Object.assign( { symbol: symbol }, options );\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    signedRequest( base + 'v3/myTrades', parameters, function ( error, data ) {\r\n                        return callback.call( this, error, data, symbol );\r\n                    } );\r\n                } )\r\n            } else {\r\n                signedRequest( base + 'v3/myTrades', parameters, function ( error, data ) {\r\n                    return callback.call( this, error, data, symbol );\r\n                } );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Tell api to use the server time to offset time indexes\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        useServerTime: ( callback = false ) => {\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    publicRequest( base + 'v3/time', {}, function ( error, response ) {\r\n                        if ( !error ) {\r\n                            Binance.info.timeOffset = response.serverTime - new Date().getTime();\r\n                            //Binance.options.log(\"server time set: \", response.serverTime, Binance.info.timeOffset);\r\n                        }\r\n                        callback( error, response );\r\n                    } );\r\n                } )\r\n            } else {\r\n                publicRequest( base + 'v3/time', {}, function ( error, response ) {\r\n                    if ( !error ) {\r\n                        Binance.info.timeOffset = response.serverTime - new Date().getTime();\r\n                        //Binance.options.log(\"server time set: \", response.serverTime, Binance.info.timeOffset);\r\n                    }\r\n                    callback( error, response );\r\n                } );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Get Binance server time\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        time: function ( callback ) {\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    publicRequest( base + 'v3/time', {}, callback );\r\n                } )\r\n            } else {\r\n                publicRequest( base + 'v3/time', {}, callback );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Get agg trades for given symbol\r\n        * @param {string} symbol - the symbol\r\n        * @param {object} options - additional optoins\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        aggTrades: function ( symbol, options = {}, callback = false ) { //fromId startTime endTime limit\r\n            let parameters = Object.assign( { symbol }, options );\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    publicRequest( base + 'v3/aggTrades', parameters, callback );\r\n                } )\r\n            } else {\r\n                publicRequest( base + 'v3/aggTrades', parameters, callback );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Get the recent trades\r\n        * @param {string} symbol - the symbol\r\n        * @param {function} callback - the callback function\r\n        * @param {int} limit - limit the number of items returned\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        recentTrades: function ( symbol, callback, limit = 500 ) {\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    marketRequest( base + 'v1/trades', { symbol: symbol, limit: limit }, callback );\r\n                } )\r\n            } else {\r\n                marketRequest( base + 'v1/trades', { symbol: symbol, limit: limit }, callback );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Get the historical trade info\r\n        * @param {string} symbol - the symbol\r\n        * @param {function} callback - the callback function\r\n        * @param {int} limit - limit the number of items returned\r\n        * @param {int} fromId - from this id\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        historicalTrades: function ( symbol, callback, limit = 500, fromId = false ) {\r\n            let parameters = { symbol: symbol, limit: limit };\r\n            if ( fromId ) parameters.fromId = fromId;\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    marketRequest( base + 'v3/historicalTrades', parameters, callback );\r\n                } )\r\n            } else {\r\n                marketRequest( base + 'v3/historicalTrades', parameters, callback );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Convert chart data to highstock array [timestamp,open,high,low,close]\r\n        * @param {object} chart - the chart\r\n        * @param {boolean} include_volume - to include the volume or not\r\n        * @return {array} - an array\r\n        */\r\n        highstock: function ( chart, include_volume = false ) {\r\n            let array = [];\r\n            for ( let timestamp in chart ) {\r\n                let obj = chart[timestamp];\r\n                let line = [\r\n                    Number( timestamp ),\r\n                    parseFloat( obj.open ),\r\n                    parseFloat( obj.high ),\r\n                    parseFloat( obj.low ),\r\n                    parseFloat( obj.close )\r\n                ];\r\n                if ( include_volume ) line.push( parseFloat( obj.volume ) );\r\n                array.push( line );\r\n            }\r\n            return array;\r\n        },\r\n\r\n        /**\r\n        * Populates OHLC information\r\n        * @param {object} chart - the chart\r\n        * @return {object} - object with candle information\r\n        */\r\n        ohlc: function ( chart ) {\r\n            let open = [], high = [], low = [], close = [], volume = [];\r\n            for ( let timestamp in chart ) { //Binance.ohlc[symbol][interval]\r\n                let obj = chart[timestamp];\r\n                open.push( parseFloat( obj.open ) );\r\n                high.push( parseFloat( obj.high ) );\r\n                low.push( parseFloat( obj.low ) );\r\n                close.push( parseFloat( obj.close ) );\r\n                volume.push( parseFloat( obj.volume ) );\r\n            }\r\n            return { open: open, high: high, low: low, close: close, volume: volume };\r\n        },\r\n\r\n        /**\r\n        * Gets the candles information for a given symbol\r\n        * intervals: 1m,3m,5m,15m,30m,1h,2h,4h,6h,8h,12h,1d,3d,1w,1M\r\n        * @param {string} symbol - the symbol\r\n        * @param {function} interval - the callback function\r\n        * @param {function} callback - the callback function\r\n        * @param {object} options - additional options\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        candlesticks: function ( symbol, interval = '5m', callback = false, options = { limit: 500 } ) {\r\n            let params = Object.assign( { symbol: symbol, interval: interval }, options );\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    publicRequest( base + 'v3/klines', params, function ( error, data ) {\r\n                        return callback.call( this, error, data, symbol );\r\n                    } );\r\n                } )\r\n            } else {\r\n                publicRequest( base + 'v3/klines', params, function ( error, data ) {\r\n                    return callback.call( this, error, data, symbol );\r\n                } );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Queries the public api\r\n        * @param {string} url - the public api endpoint\r\n        * @param {object} data - the data to send\r\n        * @param {function} callback - the callback function\r\n        * @param {string} method - the http method\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        publicRequest: function ( url, data, callback, method = 'GET' ) {\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    publicRequest( url, data, callback, method );\r\n                } )\r\n            } else {\r\n                publicRequest( url, data, callback, method );\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Queries the futures API by default\r\n         * @param {string} url - the signed api endpoint\r\n         * @param {object} data - the data to send\r\n         * @param {object} flags - type of request, authentication method and endpoint url\r\n         */\r\n        promiseRequest: function ( url, data = {}, flags = {} ) {\r\n            return promiseRequest( url, data, flags );\r\n        },\r\n\r\n        /**\r\n        * Queries the signed api\r\n        * @param {string} url - the signed api endpoint\r\n        * @param {object} data - the data to send\r\n        * @param {function} callback - the callback function\r\n        * @param {string} method - the http method\r\n        * @param {boolean} noDataInSignature - Prevents data from being added to signature\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        signedRequest: function ( url, data, callback, method = 'GET', noDataInSignature = false ) {\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    signedRequest( url, data, callback, method, noDataInSignature );\r\n                } )\r\n            } else {\r\n                signedRequest( url, data, callback, method, noDataInSignature );\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Gets the market asset of given symbol\r\n        * @param {string} symbol - the public api endpoint\r\n        * @return {undefined}\r\n        */\r\n        getMarket: function ( symbol ) {\r\n            if ( symbol.endsWith( 'BTC' ) ) return 'BTC';\r\n            else if ( symbol.endsWith( 'ETH' ) ) return 'ETH';\r\n            else if ( symbol.endsWith( 'BNB' ) ) return 'BNB';\r\n            else if ( symbol.endsWith( 'XRP' ) ) return 'XRP';\r\n            else if ( symbol.endsWith( 'PAX' ) ) return 'PAX';\r\n            else if ( symbol.endsWith( 'USDT' ) ) return 'USDT';\r\n            else if ( symbol.endsWith( 'USDC' ) ) return 'USDC';\r\n            else if ( symbol.endsWith( 'USDS' ) ) return 'USDS';\r\n            else if ( symbol.endsWith( 'TUSD' ) ) return 'TUSD';\r\n        },\r\n\r\n        /**\r\n        * Get the account binance lending information\r\n        * @param {function} callback - the callback function\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        lending: async ( params = {} ) => {\r\n            return promiseRequest( 'v1/lending/union/account', params, { base:sapi, type:'SIGNED' } );\r\n        },\r\n\r\n        //** Futures methods */\r\n        futuresPing: async ( params = {} ) => {\r\n            return promiseRequest( 'v1/ping', params, { base:fapi } );\r\n        },\r\n\r\n        futuresTime: async ( params = {} ) => {\r\n            return promiseRequest( 'v1/time', params, { base:fapi } ).then( r => r.serverTime );\r\n        },\r\n\r\n        futuresExchangeInfo: async () => {\r\n            return promiseRequest( 'v1/exchangeInfo', {}, { base:fapi } );\r\n        },\r\n\r\n        futuresPrices: async ( params = {} ) => {\r\n            let data = await promiseRequest( 'v1/ticker/price', params, { base:fapi } );\r\n            return data.reduce( ( out, i ) => ( ( out[i.symbol] =  i.price ), out ), {} );\r\n        },\r\n\r\n        futuresDaily: async ( symbol = false, params = {} ) => {\r\n            if ( symbol ) params.symbol = symbol;\r\n            let data = await promiseRequest( 'v1/ticker/24hr', params, { base:fapi } );\r\n            return symbol ? data : data.reduce( ( out, i ) => ( ( out[i.symbol] = i ), out ), {} );\r\n        },\r\n\r\n        futuresOpenInterest: async ( symbol ) => {\r\n            return promiseRequest( 'v1/openInterest', { symbol }, { base:fapi } ).then( r => r.openInterest );\r\n        },\r\n\r\n        futuresCandles: async ( symbol, interval = \"30m\", params = {} ) => {\r\n            params.symbol = symbol;\r\n            params.interval = interval;\r\n            return promiseRequest( 'v1/klines', params, { base:fapi } );\r\n        },\r\n\r\n        futuresMarkPrice: async ( symbol = false ) => {\r\n            return promiseRequest( 'v1/premiumIndex', symbol ? { symbol } : {}, { base:fapi } );\r\n        },\r\n\r\n        futuresTrades: async ( symbol, params = {} ) => {\r\n            params.symbol = symbol;\r\n            return promiseRequest( 'v1/trades', params, { base:fapi } );\r\n        },\r\n\r\n        futuresHistoricalTrades: async ( symbol, params = {} ) => {\r\n            params.symbol = symbol;\r\n            return promiseRequest( 'v1/historicalTrades', params, { base:fapi, type:'MARKET_DATA' } );\r\n        },\r\n\r\n        futuresAggTrades: async ( symbol, params = {} ) => {\r\n            params.symbol = symbol;\r\n            return promiseRequest( 'v1/aggTrades', params, { base:fapi } );\r\n        },\r\n\r\n        futuresForceOrders: async ( params = {} ) => {\r\n            return promiseRequest( 'v1/forceOrders', params, { base:fapi, type:'SIGNED' } );\r\n        },\r\n\r\n        futuresDeleverageQuantile: async ( params = {} ) => {\r\n            return promiseRequest( 'v1/adlQuantile', params, { base:fapi, type:'SIGNED' } );\r\n        },\r\n\r\n        futuresUserTrades: async ( symbol, params = {} ) => {\r\n            params.symbol = symbol;\r\n            return promiseRequest( 'v1/userTrades', params, { base:fapi, type:'SIGNED' } );\r\n        },\r\n\r\n        futuresGetDataStream: async ( params = {} ) => {\r\n            //A User Data Stream listenKey is valid for 60 minutes after creation. setInterval\r\n            return promiseRequest( 'v1/listenKey', params, { base:fapi, type:'SIGNED', method:'POST' } );\r\n        },\r\n\r\n        futuresKeepDataStream: async ( params = {} ) => {\r\n            return promiseRequest( 'v1/listenKey', params, { base:fapi, type:'SIGNED', method:'PUT' } );\r\n        },\r\n\r\n        futuresCloseDataStream: async ( params = {} ) => {\r\n            return promiseRequest( 'v1/listenKey', params, { base:fapi, type:'SIGNED', method:'DELETE' } );\r\n        },\r\n\r\n        futuresLiquidationOrders: async ( symbol = false, params = {} ) => {\r\n            if ( symbol ) params.symbol = symbol;\r\n            return promiseRequest( 'v1/allForceOrders', params, { base:fapi } );\r\n        },\r\n\r\n        futuresPositionRisk: async ( params = {} ) => {\r\n            return promiseRequest( 'v2/positionRisk', params, { base:fapi, type:'SIGNED' } );\r\n        },\r\n\r\n        futuresFundingRate: async ( symbol, params = {} ) => {\r\n            params.symbol = symbol;\r\n            return promiseRequest( 'v1/fundingRate', params, { base:fapi } );\r\n        },\r\n\r\n        futuresLeverageBracket: async ( symbol = false, params = {} ) => {\r\n            if ( symbol ) params.symbol = symbol;\r\n            return promiseRequest( 'v1/leverageBracket', params, { base:fapi, type:'USER_DATA' } );\r\n        },\r\n\r\n        futuresTradingStatus: async ( symbol = false, params = {} ) => {\r\n            if ( symbol ) params.symbol = symbol;\r\n            return promiseRequest( 'v1/apiTradingStatus', params, { base:fapi, type:'USER_DATA' } );\r\n        },\r\n\r\n        futuresCommissionRate: async ( symbol = false, params = {} ) => {\r\n            if ( symbol ) params.symbol = symbol;\r\n            return promiseRequest( 'v1/commissionRate', params, { base:fapi, type:'USER_DATA' } );\r\n        },\r\n\r\n        // leverage 1 to 125\r\n        futuresLeverage: async ( symbol, leverage, params = {} ) => {\r\n            params.symbol = symbol;\r\n            params.leverage = leverage;\r\n            return promiseRequest( 'v1/leverage', params, { base:fapi, method:'POST', type:'SIGNED' } );\r\n        },\r\n\r\n        // ISOLATED, CROSSED\r\n        futuresMarginType: async ( symbol, marginType, params = {} ) => {\r\n            params.symbol = symbol;\r\n            params.marginType = marginType;\r\n            return promiseRequest( 'v1/marginType', params, { base:fapi, method:'POST', type:'SIGNED' } );\r\n        },\r\n\r\n        // type: 1: Add postion margin2: Reduce postion margin\r\n        futuresPositionMargin: async ( symbol, amount, type = 1, params = {} ) => {\r\n            params.symbol = symbol;\r\n            params.amount = amount;\r\n            params.type = type;\r\n            return promiseRequest( 'v1/positionMargin', params, { base:fapi, method:'POST', type:'SIGNED' } );\r\n        },\r\n\r\n        futuresPositionMarginHistory: async ( symbol, params = {} ) => {\r\n            params.symbol = symbol;\r\n            return promiseRequest( 'v1/positionMargin/history', params, { base:fapi, type:'SIGNED' } );\r\n        },\r\n\r\n        futuresIncome: async ( params = {} ) => {\r\n            return promiseRequest( 'v1/income', params, { base:fapi, type:'SIGNED' } );\r\n        },\r\n\r\n        futuresBalance: async ( params = {} ) => {\r\n            return promiseRequest( 'v2/balance', params, { base:fapi, type:'SIGNED' } );\r\n        },\r\n\r\n        futuresAccount: async ( params = {} ) => {\r\n            return promiseRequest( 'v2/account', params, { base:fapi, type:'SIGNED' } );\r\n        },\r\n\r\n        futuresDepth: async ( symbol, params = {} ) => {\r\n            params.symbol = symbol;\r\n            return promiseRequest( 'v1/depth', params, { base:fapi } );\r\n        },\r\n\r\n        futuresQuote: async ( symbol = false, params = {} ) => {\r\n            if ( symbol ) params.symbol = symbol;\r\n            //let data = await promiseRequest( 'v1/ticker/bookTicker', params, {base:fapi} );\r\n            //return data.reduce((out, i) => ((out[i.symbol] = i), out), {}),\r\n            let data = await promiseRequest( 'v1/ticker/bookTicker', params, { base:fapi } );\r\n            return symbol ? data : data.reduce( ( out, i ) => ( ( out[i.symbol] = i ), out ), {} );\r\n        },\r\n\r\n        futuresBuy: async ( symbol, quantity, price, params = {} ) => {\r\n            return futuresOrder( 'BUY', symbol, quantity, price, params );\r\n        },\r\n\r\n        futuresSell: async ( symbol, quantity, price, params = {} ) => {\r\n            return futuresOrder( 'SELL', symbol, quantity, price, params );\r\n        },\r\n\r\n        futuresMarketBuy: async ( symbol, quantity, params = {} ) => {\r\n            return futuresOrder( 'BUY', symbol, quantity, false, params );\r\n        },\r\n\r\n        futuresMarketSell: async ( symbol, quantity, params = {} ) => {\r\n            return futuresOrder( 'SELL', symbol, quantity, false, params );\r\n        },\r\n\r\n        futuresOrder, // side symbol quantity [price] [params]\r\n\r\n        futuresOrderStatus: async ( symbol, params = {} ) => { // Either orderId or origClientOrderId must be sent\r\n            params.symbol = symbol;\r\n            return promiseRequest( 'v1/order', params, { base:fapi, type:'SIGNED' } );\r\n        },\r\n\r\n        futuresCancel: async ( symbol, params = {} ) => { // Either orderId or origClientOrderId must be sent\r\n            params.symbol = symbol;\r\n            return promiseRequest( 'v1/order', params, { base:fapi, type:'SIGNED', method:'DELETE' } );\r\n        },\r\n\r\n        futuresCancelAll: async ( symbol, params = {} ) => {\r\n            params.symbol = symbol;\r\n            return promiseRequest( 'v1/allOpenOrders', params, { base:fapi, type:'SIGNED', method:'DELETE' } );\r\n        },\r\n\r\n        futuresCountdownCancelAll: async ( symbol, countdownTime = 0, params = {} ) => {\r\n            params.symbol = symbol;\r\n            params.countdownTime = countdownTime;\r\n            return promiseRequest( 'v1/countdownCancelAll', params, { base:fapi, type:'SIGNED', method:'POST' } );\r\n        },\r\n\r\n        futuresOpenOrders: async ( symbol = false, params = {} ) => {\r\n            if ( symbol ) params.symbol = symbol;\r\n            return promiseRequest( 'v1/openOrders', params, { base:fapi, type:'SIGNED' } );\r\n        },\r\n\r\n        futuresAllOrders: async ( symbol = false, params = {} ) => { // Get all account orders; active, canceled, or filled.\r\n            if ( symbol ) params.symbol = symbol;\r\n            return promiseRequest( 'v1/allOrders', params, { base:fapi, type:'SIGNED' } );\r\n        },\r\n\r\n        futuresPositionSideDual: async ( params = {} ) => {\r\n            return promiseRequest( 'v1/positionSide/dual', params, { base:fapi, type:'SIGNED' } );\r\n        },\r\n\r\n        futuresChangePositionSideDual: async ( dualSidePosition, params = {} ) => {\r\n            params.dualSidePosition = dualSidePosition;\r\n            return promiseRequest( 'v1/positionSide/dual', params, { base:fapi, type:'SIGNED', method:'POST' } );\r\n        },\r\n        futuresTransferAsset: async ( asset, amount, type ) => {\r\n            let params = Object.assign( { asset, amount, type } );\r\n            return promiseRequest( 'v1/futures/transfer', params, { base:sapi, type:'SIGNED', method:'POST' } );\r\n        },\r\n\r\n        futuresHistDataId: async ( symbol = false, params = {} ) => {\r\n            if ( symbol ) params.symbol = symbol;\r\n            return promiseRequest( 'v1/futuresHistDataId', params, { base: sapi, type: 'SIGNED', method: 'POST' } )\r\n        },\r\n\r\n        futuresDownloadLink: async ( downloadId ) => {\r\n            return promiseRequest( 'v1/downloadLink', { downloadId }, { base: sapi, type: 'SIGNED' } )\r\n        },\r\n\r\n        // futures websockets support: ticker bookTicker miniTicker aggTrade markPrice\r\n        /* TODO: https://binance-docs.github.io/apidocs/futures/en/#change-log\r\n        Cancel multiple orders DELETE /fapi/v1/batchOrders\r\n        New Future Account Transfer POST https://api.binance.com/sapi/v1/futures/transfer\r\n        Get Postion Margin Change History (TRADE)\r\n\r\n        wss://fstream.binance.com/ws/<listenKey>\r\n        Diff. Book Depth Streams (250ms, 100ms, or realtime): <symbol>@depth OR <symbol>@depth@100ms OR <symbol>@depth@0ms\r\n        Partial Book Depth Streams (5, 10, 20): <symbol>@depth<levels> OR <symbol>@depth<levels>@100ms\r\n        All Market Liquidation Order Streams: !forceOrder@arr\r\n        Liquidation Order Streams for specific symbol: <symbol>@forceOrder\r\n        Chart data (250ms): <symbol>@kline_<interval>\r\n        SUBSCRIBE, UNSUBSCRIBE, LIST_SUBSCRIPTIONS, SET_PROPERTY, GET_PROPERTY\r\n        Live Subscribing/Unsubscribing to streams: requires sending futures subscription id when connecting\r\n        futuresSubscriptions { \"method\": \"LIST_SUBSCRIPTIONS\", \"id\": 1 }\r\n        futuresUnsubscribe { \"method\": \"UNSUBSCRIBE\", \"params\": [ \"btcusdt@depth\" ], \"id\": 1 }\r\n        futures depthCache\r\n        */\r\n\r\n        /*\r\n        const futuresOrder = (side, symbol, quantity, price = 0, flags = {}, callback = false) => {\r\n            let opt = {\r\n                symbol: symbol,\r\n                side: side,\r\n                type: 'LIMIT',\r\n                quantity: quantity\r\n            };\r\n            if (typeof flags.type !== 'undefined') opt.type = flags.type;\r\n            if (opt.type.includes('LIMIT')) {\r\n                opt.price = price;\r\n                opt.timeInForce = 'GTC';\r\n            }\r\n            if (typeof flags.timeInForce !== 'undefined') opt.timeInForce = flags.timeInForce;\r\n            signedRequest(`${fapi}v1/order`, opt, function (error, response) {\r\n                if (!response) {\r\n                    if (callback) return callback(error, response);\r\n                    else return Binance.options.log('futuresOrder error:', error);\r\n                }\r\n                if (callback) return callback(error, response);\r\n                else return Binance.options.log(`futuresOrder ${side} (${symbol},${quantity},${price})`, response);\r\n            }, 'POST');\r\n        };*/\r\n\r\n        //** Delivery methods */\r\n        deliveryPing: async ( params = {} ) => {\r\n            return promiseRequest( 'v1/ping', params, { base:dapi } );\r\n        },\r\n\r\n        deliveryTime: async ( params = {} ) => {\r\n            return promiseRequest( 'v1/time', params, { base:dapi } ).then( r => r.serverTime );\r\n        },\r\n\r\n        deliveryExchangeInfo: async () => {\r\n            return promiseRequest( 'v1/exchangeInfo', {}, { base:dapi } );\r\n        },\r\n\r\n        deliveryPrices: async ( params = {} ) => {\r\n            let data = await promiseRequest( 'v1/ticker/price', params, { base:dapi } );\r\n            return data.reduce( ( out, i ) => ( ( out[i.symbol] =  i.price ), out ), {} );\r\n        },\r\n\r\n        deliveryDaily: async ( symbol = false, params = {} ) => {\r\n            if ( symbol ) params.symbol = symbol;\r\n            let data = await promiseRequest( 'v1/ticker/24hr', params, { base:dapi } );\r\n            return symbol ? data : data.reduce( ( out, i ) => ( ( out[i.symbol] = i ), out ), {} );\r\n        },\r\n\r\n        deliveryOpenInterest: async ( symbol ) => {\r\n            return promiseRequest( 'v1/openInterest', { symbol }, { base:dapi } ).then( r => r.openInterest );\r\n        },\r\n\r\n        deliveryCandles: async ( symbol, interval = \"30m\", params = {} ) => {\r\n            params.symbol = symbol;\r\n            params.interval = interval;\r\n            return promiseRequest( 'v1/klines', params, { base:dapi } );\r\n        },\r\n\r\n        deliveryContinuousKlines: async ( pair, contractType = \"CURRENT_QUARTER\", interval = \"30m\", params = {} ) => {\r\n            params.pair = pair;\r\n            params.interval = interval;\r\n            params.contractType = contractType;\r\n            return promiseRequest( 'v1/continuousKlines', params, { base:dapi } );\r\n        },\r\n\r\n        deliveryIndexKlines: async ( pair, interval = \"30m\", params = {} ) => {\r\n            params.pair = pair;\r\n            params.interval = interval;\r\n            return promiseRequest( 'v1/indexPriceKlines', params, { base:dapi } );\r\n        },\r\n\r\n        deliveryMarkPriceKlines: async ( symbol, interval = \"30m\", params = {} ) => {\r\n            params.symbol = symbol;\r\n            params.interval = interval;\r\n            return promiseRequest( 'v1/markPriceKlines', params, { base:dapi } );\r\n        },\r\n\r\n        deliveryMarkPrice: async ( symbol = false ) => {\r\n            return promiseRequest( 'v1/premiumIndex', symbol ? { symbol } : {}, { base:dapi } );\r\n        },\r\n\r\n        deliveryTrades: async ( symbol, params = {} ) => {\r\n            params.symbol = symbol;\r\n            return promiseRequest( 'v1/trades', params, { base:dapi } );\r\n        },\r\n\r\n        deliveryHistoricalTrades: async ( symbol, params = {} ) => {\r\n            params.symbol = symbol;\r\n            return promiseRequest( 'v1/historicalTrades', params, { base:dapi, type:'MARKET_DATA' } );\r\n        },\r\n\r\n        deliveryAggTrades: async ( symbol, params = {} ) => {\r\n            params.symbol = symbol;\r\n            return promiseRequest( 'v1/aggTrades', params, { base:dapi } );\r\n        },\r\n\r\n        deliveryUserTrades: async ( symbol, params = {} ) => {\r\n            params.symbol = symbol;\r\n            return promiseRequest( 'v1/userTrades', params, { base:dapi, type:'SIGNED' } );\r\n        },\r\n\r\n        deliveryGetDataStream: async ( params = {} ) => {\r\n            //A User Data Stream listenKey is valid for 60 minutes after creation. setInterval\r\n            return promiseRequest( 'v1/listenKey', params, { base:dapi, type:'SIGNED', method:'POST' } );\r\n        },\r\n\r\n        deliveryKeepDataStream: async ( params = {} ) => {\r\n            return promiseRequest( 'v1/listenKey', params, { base:dapi, type:'SIGNED', method:'PUT' } );\r\n        },\r\n\r\n        deliveryCloseDataStream: async ( params = {} ) => {\r\n            return promiseRequest( 'v1/listenKey', params, { base:dapi, type:'SIGNED', method:'DELETE' } );\r\n        },\r\n\r\n        deliveryLiquidationOrders: async ( symbol = false, params = {} ) => {\r\n            if ( symbol ) params.symbol = symbol;\r\n            return promiseRequest( 'v1/allForceOrders', params, { base:dapi } );\r\n        },\r\n\r\n        deliveryPositionRisk: async ( params = {} ) => {\r\n            return promiseRequest( 'v1/positionRisk', params, { base:dapi, type:'SIGNED' } );\r\n        },\r\n\r\n        deliveryLeverageBracket: async ( symbol = false, params = {} ) => {\r\n            if ( symbol ) params.symbol = symbol;\r\n            return promiseRequest( 'v1/leverageBracket', params, { base:dapi, type:'USER_DATA' } );\r\n        },\r\n\r\n        deliveryLeverageBracketSymbols: async ( symbol = false, params = {} ) => {\r\n            if ( symbol ) params.symbol = symbol;\r\n            return promiseRequest( 'v2/leverageBracket', params, { base:dapi, type:'USER_DATA' } );\r\n        },\r\n\r\n        // leverage 1 to 125\r\n        deliveryLeverage: async ( symbol, leverage, params = {} ) => {\r\n            params.symbol = symbol;\r\n            params.leverage = leverage;\r\n            return promiseRequest( 'v1/leverage', params, { base:dapi, method:'POST', type:'SIGNED' } );\r\n        },\r\n\r\n        // ISOLATED, CROSSED\r\n        deliveryMarginType: async ( symbol, marginType, params = {} ) => {\r\n            params.symbol = symbol;\r\n            params.marginType = marginType;\r\n            return promiseRequest( 'v1/marginType', params, { base:dapi, method:'POST', type:'SIGNED' } );\r\n        },\r\n\r\n        // type: 1: Add postion margin2: Reduce postion margin\r\n        deliveryPositionMargin: async ( symbol, amount, type = 1, params = {} ) => {\r\n            params.symbol = symbol;\r\n            params.amount = amount;\r\n            params.type = type;\r\n            return promiseRequest( 'v1/positionMargin', params, { base:dapi, method:'POST', type:'SIGNED' } );\r\n        },\r\n\r\n        deliveryPositionMarginHistory: async ( symbol, params = {} ) => {\r\n            params.symbol = symbol;\r\n            return promiseRequest( 'v1/positionMargin/history', params, { base:dapi, type:'SIGNED' } );\r\n        },\r\n\r\n        deliveryIncome: async ( params = {} ) => {\r\n            return promiseRequest( 'v1/income', params, { base:dapi, type:'SIGNED' } );\r\n        },\r\n\r\n        deliveryBalance: async ( params = {} ) => {\r\n            return promiseRequest( 'v1/balance', params, { base:dapi, type:'SIGNED' } );\r\n        },\r\n\r\n        deliveryAccount: async ( params = {} ) => {\r\n            return promiseRequest( 'v1/account', params, { base:dapi, type:'SIGNED' } );\r\n        },\r\n\r\n        deliveryDepth: async ( symbol, params = {} ) => {\r\n            params.symbol = symbol;\r\n            return promiseRequest( 'v1/depth', params, { base:dapi } );\r\n        },\r\n\r\n        deliveryQuote: async ( symbol = false, params = {} ) => {\r\n            if ( symbol ) params.symbol = symbol;\r\n            //let data = await promiseRequest( 'v1/ticker/bookTicker', params, {base:dapi} );\r\n            //return data.reduce((out, i) => ((out[i.symbol] = i), out), {}),\r\n            let data = await promiseRequest( 'v1/ticker/bookTicker', params, { base:dapi } );\r\n            return symbol ? data : data.reduce( ( out, i ) => ( ( out[i.symbol] = i ), out ), {} );\r\n        },\r\n\r\n        deliveryBuy: async ( symbol, quantity, price, params = {} ) => {\r\n            return deliveryOrder( 'BUY', symbol, quantity, price, params );\r\n        },\r\n\r\n        deliverySell: async ( symbol, quantity, price, params = {} ) => {\r\n            return deliveryOrder( 'SELL', symbol, quantity, price, params );\r\n        },\r\n\r\n        deliveryMarketBuy: async ( symbol, quantity, params = {} ) => {\r\n            return deliveryOrder( 'BUY', symbol, quantity, false, params );\r\n        },\r\n\r\n        deliveryMarketSell: async ( symbol, quantity, params = {} ) => {\r\n            return deliveryOrder( 'SELL', symbol, quantity, false, params );\r\n        },\r\n\r\n        deliveryOrder, // side symbol quantity [price] [params]\r\n\r\n        deliveryOrderStatus: async ( symbol, params = {} ) => { // Either orderId or origClientOrderId must be sent\r\n            params.symbol = symbol;\r\n            return promiseRequest( 'v1/order', params, { base:dapi, type:'SIGNED' } );\r\n        },\r\n\r\n        deliveryCancel: async ( symbol, params = {} ) => { // Either orderId or origClientOrderId must be sent\r\n            params.symbol = symbol;\r\n            return promiseRequest( 'v1/order', params, { base:dapi, type:'SIGNED', method:'DELETE' } );\r\n        },\r\n\r\n        deliveryCancelAll: async ( symbol, params = {} ) => {\r\n            params.symbol = symbol;\r\n            return promiseRequest( 'v1/allOpenOrders', params, { base:dapi, type:'SIGNED', method:'DELETE' } );\r\n        },\r\n\r\n        deliveryCountdownCancelAll: async ( symbol, countdownTime = 0, params = {} ) => {\r\n            params.symbol = symbol;\r\n            params.countdownTime = countdownTime;\r\n            return promiseRequest( 'v1/countdownCancelAll', params, { base:dapi, type:'SIGNED', method:'POST' } );\r\n        },\r\n\r\n        deliveryOpenOrders: async ( symbol = false, params = {} ) => {\r\n            if ( symbol ) params.symbol = symbol;\r\n            return promiseRequest( 'v1/openOrders', params, { base:dapi, type:'SIGNED' } );\r\n        },\r\n\r\n        deliveryAllOrders: async ( symbol = false, params = {} ) => { // Get all account orders; active, canceled, or filled.\r\n            if ( symbol ) params.symbol = symbol;\r\n            return promiseRequest( 'v1/allOrders', params, { base:dapi, type:'SIGNED' } );\r\n        },\r\n\r\n        deliveryPositionSideDual: async ( params = {} ) => {\r\n            return promiseRequest( 'v1/positionSide/dual', params, { base:dapi, type:'SIGNED' } );\r\n        },\r\n\r\n        deliveryChangePositionSideDual: async ( dualSidePosition, params = {} ) => {\r\n            params.dualSidePosition = dualSidePosition;\r\n            return promiseRequest( 'v1/positionSide/dual', params, { base:dapi, type:'SIGNED', method:'POST' } );\r\n        },\r\n\r\n        //** Margin methods */\r\n        /**\r\n         * Creates an order\r\n         * @param {string} side - BUY or SELL\r\n         * @param {string} symbol - the symbol to buy\r\n         * @param {numeric} quantity - the quantity required\r\n         * @param {numeric} price - the price to pay for each unit\r\n         * @param {object} flags - additional buy order flags\r\n         * @param {function} callback - the callback function\r\n         * @param {string} isIsolated - the isolate margin option\r\n         * @return {undefined}\r\n         */\r\n        mgOrder: function ( side, symbol, quantity, price, flags = {}, callback = false,isIsolated='FALSE'  ) {\r\n            marginOrder( side, symbol, quantity, price, {...flags,isIsolated}, callback );\r\n        },\r\n\r\n        /**\r\n         * Creates a buy order\r\n         * @param {string} symbol - the symbol to buy\r\n         * @param {numeric} quantity - the quantity required\r\n         * @param {numeric} price - the price to pay for each unit\r\n         * @param {object} flags - additional buy order flags\r\n         * @param {function} callback - the callback function\r\n         * @param {string} isIsolated - the isolate margin option\r\n         * @return {undefined}\r\n         */\r\n        mgBuy: function ( symbol, quantity, price, flags = {}, callback = false,isIsolated='FALSE'  ) {\r\n            marginOrder( 'BUY', symbol, quantity, price, {...flags,isIsolated}, callback );\r\n        },\r\n\r\n        /**\r\n         * Creates a sell order\r\n         * @param {string} symbol - the symbol to sell\r\n         * @param {numeric} quantity - the quantity required\r\n         * @param {numeric} price - the price to sell each unit for\r\n         * @param {object} flags - additional order flags\r\n         * @param {function} callback - the callback function\r\n         * @param {string} isIsolated - the isolate margin option\r\n         * @return {undefined}\r\n         */\r\n        mgSell: function ( symbol, quantity, price, flags = {}, callback = false,isIsolated='FALSE'  ) {\r\n            marginOrder( 'SELL', symbol, quantity, price, {...flags,isIsolated}, callback );\r\n        },\r\n\r\n        /**\r\n         * Creates a market buy order\r\n         * @param {string} symbol - the symbol to buy\r\n         * @param {numeric} quantity - the quantity required\r\n         * @param {object} flags - additional buy order flags\r\n         * @param {function} callback - the callback function\r\n         * @param {string} isIsolated - the isolate margin option\r\n         * @return {undefined}\r\n         */\r\n        mgMarketBuy: function ( symbol, quantity, flags = { type: 'MARKET' }, callback = false,isIsolated='FALSE' ) {\r\n            if ( typeof flags === 'function' ) { // Accept callback as third parameter\r\n                callback = flags;\r\n                flags = { type: 'MARKET' };\r\n            }\r\n            if ( typeof flags.type === 'undefined' ) flags.type = 'MARKET';\r\n            marginOrder( 'BUY', symbol, quantity, 0, {...flags,isIsolated}, callback );\r\n        },\r\n\r\n        /**\r\n         * Creates a market sell order\r\n         * @param {string} symbol - the symbol to sell\r\n         * @param {numeric} quantity - the quantity required\r\n         * @param {object} flags - additional sell order flags\r\n         * @param {function} callback - the callback function\r\n         * @param {string} isIsolated - the isolate margin option\r\n         * @return {undefined}\r\n         */\r\n        mgMarketSell: function ( symbol, quantity, flags = { type: 'MARKET' }, callback = false, isIsolated='FALSE'  ) {\r\n            if ( typeof flags === 'function' ) { // Accept callback as third parameter\r\n                callback = flags;\r\n                flags = { type: 'MARKET' };\r\n            }\r\n            if ( typeof flags.type === 'undefined' ) flags.type = 'MARKET';\r\n            marginOrder( 'SELL', symbol, quantity, 0, {...flags,isIsolated}, callback );\r\n        },\r\n\r\n        /**\r\n         * Cancels an order\r\n         * @param {string} symbol - the symbol to cancel\r\n         * @param {string} orderid - the orderid to cancel\r\n         * @param {function} callback - the callback function\r\n         * @return {undefined}\r\n         */\r\n        mgCancel: function ( symbol, orderid, callback = false,isIsolated='FALSE') {\r\n            signedRequest( sapi + 'v1/margin/order', { symbol: symbol, orderId: orderid,isIsolated }, function ( error, data ) {\r\n                if ( callback ) return callback.call( this, error, data, symbol );\r\n            }, 'DELETE' );\r\n        },\r\n\r\n        /**\r\n        * Gets all order of a given symbol\r\n        * @param {string} symbol - the symbol\r\n        * @param {function} callback - the callback function\r\n        * @param {object} options - additional options\r\n        * @return {promise or undefined} - omitting the callback returns a promise\r\n        */\r\n        mgAllOrders: function ( symbol, callback, options = {} ) {\r\n            let parameters = Object.assign( { symbol: symbol }, options );\r\n            if ( !callback ) {\r\n                return new Promise( ( resolve, reject ) => {\r\n                    callback = ( error, response ) => {\r\n                        if ( error ) {\r\n                            reject( error );\r\n                        } else {\r\n                            resolve( response );\r\n                        }\r\n                    }\r\n                    signedRequest( sapi + 'v1/margin/allOrders', parameters, function ( error, data ) {\r\n                        return callback.call( this, error, data, symbol );\r\n                    } );\r\n                } )\r\n            } else {\r\n                signedRequest( sapi + 'v1/margin/allOrders', parameters, function ( error, data ) {\r\n                    return callback.call( this, error, data, symbol );\r\n                } );\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Gets the status of an order\r\n         * @param {string} symbol - the symbol to check\r\n         * @param {string} orderid - the orderid to check\r\n         * @param {function} callback - the callback function\r\n         * @param {object} flags - any additional flags\r\n         * @return {undefined}\r\n         */\r\n        mgOrderStatus: function ( symbol, orderid, callback, flags = {} ) {\r\n            let parameters = Object.assign( { symbol: symbol, orderId: orderid }, flags );\r\n            signedRequest( sapi + 'v1/margin/order', parameters, function ( error, data ) {\r\n                if ( callback ) return callback.call( this, error, data, symbol );\r\n            } );\r\n        },\r\n\r\n        /**\r\n         * Gets open orders\r\n         * @param {string} symbol - the symbol to get\r\n         * @param {function} callback - the callback function\r\n         * @return {undefined}\r\n         */\r\n        mgOpenOrders: function ( symbol, callback ) {\r\n            let parameters = symbol ? { symbol: symbol } : {};\r\n            signedRequest( sapi + 'v1/margin/openOrders', parameters, function ( error, data ) {\r\n                return callback.call( this, error, data, symbol );\r\n            } );\r\n        },\r\n\r\n        /**\r\n         * Cancels all order of a given symbol\r\n         * @param {string} symbol - the symbol to cancel all orders for\r\n         * @param {function} callback - the callback function\r\n         * @return {undefined}\r\n         */\r\n        mgCancelOrders: function ( symbol, callback = false ) {\r\n            signedRequest( sapi + 'v1/margin/openOrders', { symbol: symbol }, function ( error, json ) {\r\n                if ( json.length === 0 ) {\r\n                    if ( callback ) return callback.call( this, 'No orders present for this symbol', {}, symbol );\r\n                }\r\n                for ( let obj of json ) {\r\n                    let quantity = obj.origQty - obj.executedQty;\r\n                    Binance.options.log( 'cancel order: ' + obj.side + ' ' + symbol + ' ' + quantity + ' @ ' + obj.price + ' #' + obj.orderId );\r\n                    signedRequest( sapi + 'v1/margin/order', { symbol: symbol, orderId: obj.orderId }, function ( error, data ) {\r\n                        if ( callback ) return callback.call( this, error, data, symbol );\r\n                    }, 'DELETE' );\r\n                }\r\n            } );\r\n        },\r\n\r\n        /**\r\n         * Transfer from main account to margin account\r\n         * @param {string} asset - the asset\r\n         * @param {number} amount - the asset\r\n         * @param {function} callback - the callback function\r\n         * @param {object} options - additional options\r\n         * @return {undefined}\r\n         */\r\n        mgTransferMainToMargin: function ( asset, amount, callback ) {\r\n            let parameters = Object.assign( { asset: asset, amount: amount, type: 1 } );\r\n            signedRequest( sapi + 'v1/margin/transfer', parameters, function ( error, data ) {\r\n                if ( callback ) return callback( error, data );\r\n            }, 'POST' );\r\n        },\r\n\r\n        /**\r\n         * Transfer from margin account to main account\r\n         * @param {string} asset - the asset\r\n         * @param {number} amount - the asset\r\n         * @param {function} callback - the callback function\r\n         * @return {undefined}\r\n         */\r\n        mgTransferMarginToMain: function ( asset, amount, callback ) {\r\n            let parameters = Object.assign( { asset: asset, amount: amount, type: 2 } );\r\n            signedRequest( sapi + 'v1/margin/transfer', parameters, function ( error, data ) {\r\n                if ( callback ) return callback( error, data );\r\n            }, 'POST' );\r\n        },\r\n\r\n        /**\r\n     * Transfer from main account to delivery account\r\n     * @param {string} asset - the asset\r\n     * @param {number} amount - the asset\r\n     * @param {function} callback - the callback function (optionnal)\r\n     * @param {object} options - additional options\r\n     * @return {undefined}\r\n     */\r\n        transferMainToFutures: ( asset, amount, callback ) =>\r\n            transferBetweenMainAndFutures( asset, amount, 1, callback ),\r\n\r\n        /**\r\n     * Transfer from delivery account to main account\r\n     * @param {string} asset - the asset\r\n     * @param {number} amount - the asset\r\n     * @param {function} callback - the callback function (optionnal)\r\n     * @return {undefined}\r\n     */\r\n        transferFuturesToMain: ( asset, amount, callback ) =>\r\n            transferBetweenMainAndFutures( asset, amount, 2, callback ),\r\n\r\n        /**\r\n     * Transfer from main account to delivery account\r\n     * @param {string} asset - the asset\r\n     * @param {number} amount - the asset\r\n     * @param {function} callback - the callback function (optionnal)\r\n     * @param {object} options - additional options\r\n     * @return {undefined}\r\n     */\r\n        transferMainToDelivery: ( asset, amount, callback ) =>\r\n            transferBetweenMainAndFutures( asset, amount, 3, callback ),\r\n\r\n        /**\r\n     * Transfer from delivery account to main account\r\n     * @param {string} asset - the asset\r\n     * @param {number} amount - the asset\r\n     * @param {function} callback - the callback function (optionnal)\r\n     * @return {undefined}\r\n     */\r\n        transferDeliveryToMain: ( asset, amount, callback ) =>\r\n            transferBetweenMainAndFutures( asset, amount, 4, callback ),\r\n\r\n        /**\r\n         * Get maximum transfer-out amount of an asset\r\n         * @param {string} asset - the asset\r\n         * @param {function} callback - the callback function\r\n         * @return {undefined}\r\n         */\r\n        maxTransferable: function ( asset, callback ) {\r\n            signedRequest( sapi + 'v1/margin/maxTransferable', { asset: asset }, function( error, data ) {\r\n                if( callback ) return callback( error, data );\r\n            } );\r\n        },\r\n\r\n        /**\r\n         * Margin account borrow/loan\r\n         * @param {string} asset - the asset\r\n         * @param {number} amount - the asset\r\n         * @param {function} callback - the callback function\r\n         * @param {string} isIsolated - the isolated option\r\n         * @param {string} symbol - symbol for isolated margin\r\n         * @return {undefined}\r\n         */\r\n        mgBorrow: function ( asset, amount, callback, isIsolated='FALSE',symbol=null ) {\r\n            let parameters = Object.assign( { asset: asset, amount: amount } );\r\n            if (isIsolated ==='TRUE' && !symbol) throw new Error('If \"isIsolated\" = \"TRUE\", \"symbol\" must be sent')\r\n            const isolatedObj = isIsolated === 'TRUE'?{\r\n                isIsolated,\r\n                symbol\r\n            }:{}\r\n            signedRequest( sapi + 'v1/margin/loan', {...parameters,...isolatedObj}, function ( error, data ) {\r\n                if ( callback ) return callback( error, data );\r\n            }, 'POST' );\r\n        },\r\n\r\n        /**\r\n         * Margin account repay\r\n         * @param {string} asset - the asset\r\n         * @param {number} amount - the asset\r\n         * @param {function} callback - the callback function\r\n         * @param {string} isIsolated - the isolated option\r\n         * @param {string} symbol - symbol for isolated margin\r\n         * @return {undefined}\r\n         */\r\n        mgRepay: function ( asset, amount, callback ,isIsolated='FALSE',symbol=null ) {\r\n            let parameters = Object.assign( { asset: asset, amount: amount } );\r\n            if (isIsolated ==='TRUE' && !symbol) throw new Error('If \"isIsolated\" = \"TRUE\", \"symbol\" must be sent')\r\n            const isolatedObj = isIsolated === 'TRUE'?{\r\n                isIsolated,\r\n                symbol\r\n            }:{}\r\n            signedRequest( sapi + 'v1/margin/repay', {...parameters,...isolatedObj}, function ( error, data ) {\r\n                if ( callback ) return callback( error, data );\r\n            }, 'POST' );\r\n        },\r\n        /**\r\n         * Margin account details\r\n         * @param {function} callback - the callback function\r\n         * @param {boolean} isIsolated - the callback function\r\n         * @return {undefined}\r\n         */\r\n        mgAccount: function( callback ,isIsolated = false) {\r\n            const endpoint = 'v1/margin' + (isIsolated)?'/isolated':''  + '/account'\r\n            signedRequest( sapi + endpoint, {}, function( error, data ) {\r\n                if( callback ) return callback( error, data );\r\n            } );\r\n        },\r\n        /**\r\n         * Get maximum borrow amount of an asset\r\n         * @param {string} asset - the asset\r\n         * @param {function} callback - the callback function\r\n         * @return {undefined}\r\n         */\r\n        maxBorrowable: function ( asset, callback ) {\r\n            signedRequest( sapi + 'v1/margin/maxBorrowable', { asset: asset }, function( error, data ) {\r\n                if( callback ) return callback( error, data );\r\n            } );\r\n        },\r\n\r\n        // Futures WebSocket Functions:\r\n        /**\r\n         * Subscribe to a single futures websocket\r\n         * @param {string} url - the futures websocket endpoint\r\n         * @param {function} callback - optional execution callback\r\n         * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}\r\n         * @return {WebSocket} the websocket reference\r\n         */\r\n        futuresSubscribeSingle: function ( url, callback, params = {} ) {\r\n            return futuresSubscribeSingle( url, callback, params );\r\n        },\r\n\r\n        /**\r\n         * Subscribe to a combined futures websocket\r\n         * @param {string} streams - the list of websocket endpoints to connect to\r\n         * @param {function} callback - optional execution callback\r\n         * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}\r\n         * @return {WebSocket} the websocket reference\r\n         */\r\n        futuresSubscribe: function ( streams, callback, params = {} ) {\r\n            return futuresSubscribe( streams, callback, params );\r\n        },\r\n\r\n        /**\r\n         * Returns the known futures websockets subscriptions\r\n         * @return {array} array of futures websocket subscriptions\r\n         */\r\n        futuresSubscriptions: function() {\r\n            return Binance.futuresSubscriptions;\r\n        },\r\n\r\n        /**\r\n         * Terminates a futures websocket\r\n         * @param {string} endpoint - the string associated with the endpoint\r\n         * @return {undefined}\r\n         */\r\n        futuresTerminate: function ( endpoint ) {\r\n            if ( Binance.options.verbose ) Binance.options.log( 'Futures WebSocket terminating:', endpoint );\r\n            return futuresTerminate( endpoint );\r\n        },\r\n\r\n        /**\r\n         * Futures WebSocket aggregated trades\r\n         * @param {array/string} symbols - an array or string of symbols to query\r\n         * @param {function} callback - callback function\r\n         * @return {string} the websocket endpoint\r\n         */\r\n        futuresAggTradeStream: function futuresAggTradeStream( symbols, callback ) {\r\n            let reconnect = () => {\r\n                if ( Binance.options.reconnect ) futuresAggTradeStream( symbols, callback );\r\n            };\r\n            let subscription, cleanCallback = data => callback( fAggTradeConvertData( data ) );\r\n            if ( Array.isArray( symbols ) ) {\r\n                if ( !isArrayUnique( symbols ) ) throw Error( 'futuresAggTradeStream: \"symbols\" cannot contain duplicate elements.' );\r\n                let streams = symbols.map( symbol => symbol.toLowerCase() + '@aggTrade' );\r\n                subscription = futuresSubscribe( streams, cleanCallback, { reconnect } );\r\n            } else {\r\n                let symbol = symbols;\r\n                subscription = futuresSubscribeSingle( symbol.toLowerCase() + '@aggTrade', cleanCallback, { reconnect } );\r\n            }\r\n            return subscription.endpoint;\r\n        },\r\n\r\n        /**\r\n         * Futures WebSocket mark price\r\n         * @param {symbol} symbol name or false. can also be a callback\r\n         * @param {function} callback - callback function\r\n         * @param {string} speed - 1 second updates. leave blank for default 3 seconds\r\n         * @return {string} the websocket endpoint\r\n         */\r\n        futuresMarkPriceStream: function fMarkPriceStream( symbol = false, callback = console.log, speed = '@1s' ) {\r\n            if ( typeof symbol == 'function' ) {\r\n                callback = symbol;\r\n                symbol = false;\r\n            }\r\n            let reconnect = () => {\r\n                if ( Binance.options.reconnect ) fMarkPriceStream( symbol, callback, speed );\r\n            };\r\n            const endpoint = symbol ? `${ symbol.toLowerCase() }@markPrice` : '!markPrice@arr'\r\n            let subscription = futuresSubscribeSingle( endpoint + speed, data => callback( fMarkPriceConvertData( data ) ), { reconnect } );\r\n            return subscription.endpoint;\r\n        },\r\n\r\n        /**\r\n         * Futures WebSocket liquidations stream\r\n         * @param {symbol} symbol name or false. can also be a callback\r\n         * @param {function} callback - callback function\r\n         * @return {string} the websocket endpoint\r\n         */\r\n        futuresLiquidationStream: function fLiquidationStream( symbol = false, callback = console.log ) {\r\n            if ( typeof symbol == 'function' ) {\r\n                callback = symbol;\r\n                symbol = false;\r\n            }\r\n            let reconnect = () => {\r\n                if ( Binance.options.reconnect ) fLiquidationStream( symbol, callback );\r\n            };\r\n            const endpoint = symbol ? `${ symbol.toLowerCase() }@forceOrder` : '!forceOrder@arr'\r\n            let subscription = futuresSubscribeSingle( endpoint, data => callback( fLiquidationConvertData( data ) ), { reconnect } );\r\n            return subscription.endpoint;\r\n        },\r\n\r\n        /**\r\n         * Futures WebSocket prevDay ticker\r\n         * @param {symbol} symbol name or false. can also be a callback\r\n         * @param {function} callback - callback function\r\n         * @return {string} the websocket endpoint\r\n         */\r\n        futuresTickerStream: function fTickerStream( symbol = false, callback = console.log ) {\r\n            if ( typeof symbol == 'function' ) {\r\n                callback = symbol;\r\n                symbol = false;\r\n            }\r\n            let reconnect = () => {\r\n                if ( Binance.options.reconnect ) fTickerStream( symbol, callback );\r\n            };\r\n            const endpoint = symbol ? `${ symbol.toLowerCase() }@ticker` : '!ticker@arr'\r\n            let subscription = futuresSubscribeSingle( endpoint, data => callback( fTickerConvertData( data ) ), { reconnect } );\r\n            return subscription.endpoint;\r\n        },\r\n\r\n        /**\r\n         * Futures WebSocket miniTicker\r\n         * @param {symbol} symbol name or false. can also be a callback\r\n         * @param {function} callback - callback function\r\n         * @return {string} the websocket endpoint\r\n         */\r\n        futuresMiniTickerStream: function fMiniTickerStream( symbol = false, callback = console.log ) {\r\n            if ( typeof symbol == 'function' ) {\r\n                callback = symbol;\r\n                symbol = false;\r\n            }\r\n            let reconnect = () => {\r\n                if ( Binance.options.reconnect ) fMiniTickerStream( symbol, callback );\r\n            };\r\n            const endpoint = symbol ? `${ symbol.toLowerCase() }@miniTicker` : '!miniTicker@arr'\r\n            let subscription = futuresSubscribeSingle( endpoint, data => callback( fMiniTickerConvertData( data ) ), { reconnect } );\r\n            return subscription.endpoint;\r\n        },\r\n\r\n        /**\r\n         * Futures WebSocket bookTicker\r\n         * @param {symbol} symbol name or false. can also be a callback\r\n         * @param {function} callback - callback function\r\n         * @return {string} the websocket endpoint\r\n         */\r\n        futuresBookTickerStream: function fBookTickerStream( symbol = false, callback = console.log ) {\r\n            if ( typeof symbol == 'function' ) {\r\n                callback = symbol;\r\n                symbol = false;\r\n            }\r\n            let reconnect = () => {\r\n                if ( Binance.options.reconnect ) fBookTickerStream( symbol, callback );\r\n            };\r\n            const endpoint = symbol ? `${ symbol.toLowerCase() }@bookTicker` : '!bookTicker'\r\n            let subscription = futuresSubscribeSingle( endpoint, data => callback( fBookTickerConvertData( data ) ), { reconnect } );\r\n            return subscription.endpoint;\r\n        },\r\n\r\n        /**\r\n         * Websocket futures klines\r\n         * @param {array/string} symbols - an array or string of symbols to query\r\n         * @param {string} interval - the time interval\r\n         * @param {function} callback - callback function\r\n         * @param {int} limit - maximum results, no more than 1000\r\n         * @return {string} the websocket endpoint\r\n         */\r\n        futuresChart: async function futuresChart( symbols, interval, callback, limit = 500 ) {\r\n            let reconnect = () => {\r\n                if ( Binance.options.reconnect ) futuresChart( symbols, interval, callback, limit );\r\n            };\r\n\r\n            let futuresChartInit = symbol => {\r\n                if ( typeof Binance.futuresMeta[symbol] === 'undefined' ) Binance.futuresMeta[symbol] = {};\r\n                if ( typeof Binance.futuresMeta[symbol][interval] === 'undefined' ) Binance.futuresMeta[symbol][interval] = {};\r\n                if ( typeof Binance.futuresTicks[symbol] === 'undefined' ) Binance.futuresTicks[symbol] = {};\r\n                if ( typeof Binance.futuresTicks[symbol][interval] === 'undefined' ) Binance.futuresTicks[symbol][interval] = {};\r\n                if ( typeof Binance.futuresRealtime[symbol] === 'undefined' ) Binance.futuresRealtime[symbol] = {};\r\n                if ( typeof Binance.futuresRealtime[symbol][interval] === 'undefined' ) Binance.futuresRealtime[symbol][interval] = {};\r\n                if ( typeof Binance.futuresKlineQueue[symbol] === 'undefined' ) Binance.futuresKlineQueue[symbol] = {};\r\n                if ( typeof Binance.futuresKlineQueue[symbol][interval] === 'undefined' ) Binance.futuresKlineQueue[symbol][interval] = [];\r\n                Binance.futuresMeta[symbol][interval].timestamp = 0;\r\n            }\r\n\r\n            let handleFuturesKlineStream = kline => {\r\n                let symbol = kline.s, interval = kline.k.i;\r\n                if ( !Binance.futuresMeta[symbol][interval].timestamp ) {\r\n                    if ( typeof ( Binance.futuresKlineQueue[symbol][interval] ) !== 'undefined' && kline !== null ) {\r\n                        Binance.futuresKlineQueue[symbol][interval].push( kline );\r\n                    }\r\n                } else {\r\n                    //Binance.options.log('futures klines at ' + kline.k.t);\r\n                    futuresKlineHandler( symbol, kline );\r\n                    if ( callback ) callback( symbol, interval, futuresKlineConcat( symbol, interval ) );\r\n                }\r\n            };\r\n\r\n            let getFuturesKlineSnapshot = async ( symbol, limit = 500 ) => {\r\n                let data = await promiseRequest( 'v1/klines', { symbol, interval, limit }, { base:fapi } );\r\n                futuresKlineData( symbol, interval, data );\r\n                //Binance.options.log('/futures klines at ' + Binance.futuresMeta[symbol][interval].timestamp);\r\n                if ( typeof Binance.futuresKlineQueue[symbol][interval] !== 'undefined' ) {\r\n                    for ( let kline of Binance.futuresKlineQueue[symbol][interval] ) futuresKlineHandler( symbol, kline, Binance.futuresMeta[symbol][interval].timestamp );\r\n                    delete Binance.futuresKlineQueue[symbol][interval];\r\n                }\r\n                if ( callback ) callback( symbol, interval, futuresKlineConcat( symbol, interval ) );\r\n            };\r\n\r\n            let subscription;\r\n            if ( Array.isArray( symbols ) ) {\r\n                if ( !isArrayUnique( symbols ) ) throw Error( 'futuresChart: \"symbols\" array cannot contain duplicate elements.' );\r\n                symbols.forEach( futuresChartInit );\r\n                let streams = symbols.map( symbol => `${ symbol.toLowerCase() }@kline_${ interval }` );\r\n                subscription = futuresSubscribe( streams, handleFuturesKlineStream, reconnect );\r\n                symbols.forEach( element => getFuturesKlineSnapshot( element, limit ) );\r\n            } else {\r\n                let symbol = symbols;\r\n                futuresChartInit( symbol );\r\n                subscription = futuresSubscribeSingle( symbol.toLowerCase() + '@kline_' + interval, handleFuturesKlineStream, reconnect );\r\n                getFuturesKlineSnapshot( symbol, limit );\r\n            }\r\n            return subscription.endpoint;\r\n        },\r\n\r\n        /**\r\n         * Websocket futures candlesticks\r\n         * @param {array/string} symbols - an array or string of symbols to query\r\n         * @param {string} interval - the time interval\r\n         * @param {function} callback - callback function\r\n         * @return {string} the websocket endpoint\r\n         */\r\n        futuresCandlesticks: function futuresCandlesticks( symbols, interval, callback ) {\r\n            let reconnect = () => {\r\n                if ( Binance.options.reconnect ) futuresCandlesticks( symbols, interval, callback );\r\n            };\r\n            let subscription;\r\n            if ( Array.isArray( symbols ) ) {\r\n                if ( !isArrayUnique( symbols ) ) throw Error( 'futuresCandlesticks: \"symbols\" array cannot contain duplicate elements.' );\r\n                let streams = symbols.map( symbol => symbol.toLowerCase() + '@kline_' + interval );\r\n                subscription = futuresSubscribe( streams, callback, { reconnect } );\r\n            } else {\r\n                let symbol = symbols.toLowerCase();\r\n                subscription = futuresSubscribeSingle( symbol + '@kline_' + interval, callback, { reconnect } );\r\n            }\r\n            return subscription.endpoint;\r\n        },\r\n\r\n        // Delivery WebSocket Functions:\r\n        /**\r\n         * Subscribe to a single delivery websocket\r\n         * @param {string} url - the delivery websocket endpoint\r\n         * @param {function} callback - optional execution callback\r\n         * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}\r\n         * @return {WebSocket} the websocket reference\r\n         */\r\n        deliverySubscribeSingle: function ( url, callback, params = {} ) {\r\n            return deliverySubscribeSingle( url, callback, params );\r\n        },\r\n\r\n        /**\r\n         * Subscribe to a combined delivery websocket\r\n         * @param {string} streams - the list of websocket endpoints to connect to\r\n         * @param {function} callback - optional execution callback\r\n         * @param {object} params - Optional reconnect {boolean} (whether to reconnect on disconnect), openCallback {function}, id {string}\r\n         * @return {WebSocket} the websocket reference\r\n         */\r\n        deliverySubscribe: function ( streams, callback, params = {} ) {\r\n            return deliverySubscribe( streams, callback, params );\r\n        },\r\n\r\n        /**\r\n         * Returns the known delivery websockets subscriptions\r\n         * @return {array} array of delivery websocket subscriptions\r\n         */\r\n        deliverySubscriptions: function() {\r\n            return Binance.deliverySubscriptions;\r\n        },\r\n\r\n        /**\r\n         * Terminates a delivery websocket\r\n         * @param {string} endpoint - the string associated with the endpoint\r\n         * @return {undefined}\r\n         */\r\n        deliveryTerminate: function ( endpoint ) {\r\n            if ( Binance.options.verbose ) Binance.options.log( 'Delivery WebSocket terminating:', endpoint );\r\n            return deliveryTerminate( endpoint );\r\n        },\r\n\r\n        /**\r\n         * Delivery WebSocket aggregated trades\r\n         * @param {array/string} symbols - an array or string of symbols to query\r\n         * @param {function} callback - callback function\r\n         * @return {string} the websocket endpoint\r\n         */\r\n        deliveryAggTradeStream: function deliveryAggTradeStream( symbols, callback ) {\r\n            let reconnect = () => {\r\n                if ( Binance.options.reconnect ) deliveryAggTradeStream( symbols, callback );\r\n            };\r\n            let subscription, cleanCallback = data => callback( dAggTradeConvertData( data ) );\r\n            if ( Array.isArray( symbols ) ) {\r\n                if ( !isArrayUnique( symbols ) ) throw Error( 'deliveryAggTradeStream: \"symbols\" cannot contain duplicate elements.' );\r\n                let streams = symbols.map( symbol => symbol.toLowerCase() + '@aggTrade' );\r\n                subscription = deliverySubscribe( streams, cleanCallback, { reconnect } );\r\n            } else {\r\n                let symbol = symbols;\r\n                subscription = deliverySubscribeSingle( symbol.toLowerCase() + '@aggTrade', cleanCallback, { reconnect } );\r\n            }\r\n            return subscription.endpoint;\r\n        },\r\n\r\n        /**\r\n         * Delivery WebSocket mark price\r\n         * @param {symbol} symbol name or false. can also be a callback\r\n         * @param {function} callback - callback function\r\n         * @param {string} speed - 1 second updates. leave blank for default 3 seconds\r\n         * @return {string} the websocket endpoint\r\n         */\r\n        deliveryMarkPriceStream: function dMarkPriceStream( symbol = false, callback = console.log, speed = '@1s' ) {\r\n            if ( typeof symbol == 'function' ) {\r\n                callback = symbol;\r\n                symbol = false;\r\n            }\r\n            let reconnect = () => {\r\n                if ( Binance.options.reconnect ) dMarkPriceStream( symbol, callback );\r\n            };\r\n            const endpoint = symbol ? `${ symbol.toLowerCase() }@markPrice` : '!markPrice@arr'\r\n            let subscription = deliverySubscribeSingle( endpoint + speed, data => callback( dMarkPriceConvertData( data ) ), { reconnect } );\r\n            return subscription.endpoint;\r\n        },\r\n\r\n        /**\r\n         * Delivery WebSocket liquidations stream\r\n         * @param {symbol} symbol name or false. can also be a callback\r\n         * @param {function} callback - callback function\r\n         * @return {string} the websocket endpoint\r\n         */\r\n        deliveryLiquidationStream: function dLiquidationStream( symbol = false, callback = console.log ) {\r\n            if ( typeof symbol == 'function' ) {\r\n                callback = symbol;\r\n                symbol = false;\r\n            }\r\n            let reconnect = () => {\r\n                if ( Binance.options.reconnect ) dLiquidationStream( symbol, callback );\r\n            };\r\n            const endpoint = symbol ? `${ symbol.toLowerCase() }@forceOrder` : '!forceOrder@arr'\r\n            let subscription = deliverySubscribeSingle( endpoint, data => callback( dLiquidationConvertData( data ) ), { reconnect } );\r\n            return subscription.endpoint;\r\n        },\r\n\r\n        /**\r\n         * Delivery WebSocket prevDay ticker\r\n         * @param {symbol} symbol name or false. can also be a callback\r\n         * @param {function} callback - callback function\r\n         * @return {string} the websocket endpoint\r\n         */\r\n        deliveryTickerStream: function dTickerStream( symbol = false, callback = console.log ) {\r\n            if ( typeof symbol == 'function' ) {\r\n                callback = symbol;\r\n                symbol = false;\r\n            }\r\n            let reconnect = () => {\r\n                if ( Binance.options.reconnect ) dTickerStream( symbol, callback );\r\n            };\r\n            const endpoint = symbol ? `${ symbol.toLowerCase() }@ticker` : '!ticker@arr'\r\n            let subscription = deliverySubscribeSingle( endpoint, data => callback( dTickerConvertData( data ) ), { reconnect } );\r\n            return subscription.endpoint;\r\n        },\r\n\r\n        /**\r\n         * Delivery WebSocket miniTicker\r\n         * @param {symbol} symbol name or false. can also be a callback\r\n         * @param {function} callback - callback function\r\n         * @return {string} the websocket endpoint\r\n         */\r\n        deliveryMiniTickerStream: function dMiniTickerStream( symbol = false, callback = console.log ) {\r\n            if ( typeof symbol == 'function' ) {\r\n                callback = symbol;\r\n                symbol = false;\r\n            }\r\n            let reconnect = () => {\r\n                if ( Binance.options.reconnect ) dMiniTickerStream( symbol, callback );\r\n            };\r\n            const endpoint = symbol ? `${ symbol.toLowerCase() }@miniTicker` : '!miniTicker@arr'\r\n            let subscription = deliverySubscribeSingle( endpoint, data => callback( dMiniTickerConvertData( data ) ), { reconnect } );\r\n            return subscription.endpoint;\r\n        },\r\n\r\n        /**\r\n         * Delivery WebSocket bookTicker\r\n         * @param {symbol} symbol name or false. can also be a callback\r\n         * @param {function} callback - callback function\r\n         * @return {string} the websocket endpoint\r\n         */\r\n        deliveryBookTickerStream: function dBookTickerStream( symbol = false, callback = console.log ) {\r\n            if ( typeof symbol == 'function' ) {\r\n                callback = symbol;\r\n                symbol = false;\r\n            }\r\n            let reconnect = () => {\r\n                if ( Binance.options.reconnect ) dBookTickerStream( symbol, callback );\r\n            };\r\n            const endpoint = symbol ? `${ symbol.toLowerCase() }@bookTicker` : '!bookTicker'\r\n            let subscription = deliverySubscribeSingle( endpoint, data => callback( dBookTickerConvertData( data ) ), { reconnect } );\r\n            return subscription.endpoint;\r\n        },\r\n\r\n        /**\r\n         * Websocket delivery klines\r\n         * @param {array/string} symbols - an array or string of symbols to query\r\n         * @param {string} interval - the time interval\r\n         * @param {function} callback - callback function\r\n         * @param {int} limit - maximum results, no more than 1000\r\n         * @return {string} the websocket endpoint\r\n         */\r\n        deliveryChart: async function deliveryChart( symbols, interval, callback, limit = 500 ) {\r\n            let reconnect = () => {\r\n                if ( Binance.options.reconnect ) deliveryChart( symbols, interval, callback, limit );\r\n            };\r\n\r\n            let deliveryChartInit = symbol => {\r\n                if ( typeof Binance.deliveryMeta[symbol] === 'undefined' ) Binance.deliveryMeta[symbol] = {};\r\n                if ( typeof Binance.deliveryMeta[symbol][interval] === 'undefined' ) Binance.deliveryMeta[symbol][interval] = {};\r\n                if ( typeof Binance.deliveryTicks[symbol] === 'undefined' ) Binance.deliveryTicks[symbol] = {};\r\n                if ( typeof Binance.deliveryTicks[symbol][interval] === 'undefined' ) Binance.deliveryTicks[symbol][interval] = {};\r\n                if ( typeof Binance.deliveryRealtime[symbol] === 'undefined' ) Binance.deliveryRealtime[symbol] = {};\r\n                if ( typeof Binance.deliveryRealtime[symbol][interval] === 'undefined' ) Binance.deliveryRealtime[symbol][interval] = {};\r\n                if ( typeof Binance.deliveryKlineQueue[symbol] === 'undefined' ) Binance.deliveryKlineQueue[symbol] = {};\r\n                if ( typeof Binance.deliveryKlineQueue[symbol][interval] === 'undefined' ) Binance.deliveryKlineQueue[symbol][interval] = [];\r\n                Binance.deliveryMeta[symbol][interval].timestamp = 0;\r\n            }\r\n\r\n            let handleDeliveryKlineStream = kline => {\r\n                let symbol = kline.s, interval = kline.k.i;\r\n                if ( !Binance.deliveryMeta[symbol][interval].timestamp ) {\r\n                    if ( typeof ( Binance.deliveryKlineQueue[symbol][interval] ) !== 'undefined' && kline !== null ) {\r\n                        Binance.deliveryKlineQueue[symbol][interval].push( kline );\r\n                    }\r\n                } else {\r\n                    //Binance.options.log('futures klines at ' + kline.k.t);\r\n                    deliveryKlineHandler( symbol, kline );\r\n                    if ( callback ) callback( symbol, interval, deliveryKlineConcat( symbol, interval ) );\r\n                }\r\n            };\r\n\r\n            let getDeliveryKlineSnapshot = async ( symbol, limit = 500 ) => {\r\n                let data = await promiseRequest( 'v1/klines', { symbol, interval, limit }, { base:fapi } );\r\n                deliveryKlineData( symbol, interval, data );\r\n                //Binance.options.log('/delivery klines at ' + Binance.deliveryMeta[symbol][interval].timestamp);\r\n                if ( typeof Binance.deliveryKlineQueue[symbol][interval] !== 'undefined' ) {\r\n                    for ( let kline of Binance.deliveryKlineQueue[symbol][interval] ) deliveryKlineHandler( symbol, kline, Binance.deliveryMeta[symbol][interval].timestamp );\r\n                    delete Binance.deliveryKlineQueue[symbol][interval];\r\n                }\r\n                if ( callback ) callback( symbol, interval, deliveryKlineConcat( symbol, interval ) );\r\n            };\r\n\r\n            let subscription;\r\n            if ( Array.isArray( symbols ) ) {\r\n                if ( !isArrayUnique( symbols ) ) throw Error( 'deliveryChart: \"symbols\" array cannot contain duplicate elements.' );\r\n                symbols.forEach( deliveryChartInit );\r\n                let streams = symbols.map( symbol => `${ symbol.toLowerCase() }@kline_${ interval }` );\r\n                subscription = deliverySubscribe( streams, handleDeliveryKlineStream, reconnect );\r\n                symbols.forEach( element => getDeliveryKlineSnapshot( element, limit ) );\r\n            } else {\r\n                let symbol = symbols;\r\n                deliveryChartInit( symbol );\r\n                subscription = deliverySubscribeSingle( symbol.toLowerCase() + '@kline_' + interval, handleDeliveryKlineStream, reconnect );\r\n                getDeliveryKlineSnapshot( symbol, limit );\r\n            }\r\n            return subscription.endpoint;\r\n        },\r\n\r\n        /**\r\n         * Websocket delivery candlesticks\r\n         * @param {array/string} symbols - an array or string of symbols to query\r\n         * @param {string} interval - the time interval\r\n         * @param {function} callback - callback function\r\n         * @return {string} the websocket endpoint\r\n         */\r\n        deliveryCandlesticks: function deliveryCandlesticks( symbols, interval, callback ) {\r\n            let reconnect = () => {\r\n                if ( Binance.options.reconnect ) deliveryCandlesticks( symbols, interval, callback );\r\n            };\r\n            let subscription;\r\n            if ( Array.isArray( symbols ) ) {\r\n                if ( !isArrayUnique( symbols ) ) throw Error( 'deliveryCandlesticks: \"symbols\" array cannot contain duplicate elements.' );\r\n                let streams = symbols.map( symbol => symbol.toLowerCase() + '@kline_' + interval );\r\n                subscription = deliverySubscribe( streams, callback, { reconnect } );\r\n            } else {\r\n                let symbol = symbols.toLowerCase();\r\n                subscription = deliverySubscribeSingle( symbol + '@kline_' + interval, callback, { reconnect } );\r\n            }\r\n            return subscription.endpoint;\r\n        },\r\n\r\n        websockets: {\r\n            /**\r\n             * Userdata websockets function\r\n             * @param {function} callback - the callback function\r\n             * @param {function} execution_callback - optional execution callback\r\n             * @param {function} subscribed_callback - subscription callback\r\n             * @param {function} list_status_callback - status callback\r\n             * @return {undefined}\r\n             */\r\n            userData: function userData( callback, execution_callback = false, subscribed_callback = false, list_status_callback = false ) {\r\n                let reconnect = () => {\r\n                    if ( Binance.options.reconnect ) userData( callback, execution_callback, subscribed_callback );\r\n                };\r\n                apiRequest( base + 'v3/userDataStream', {}, function ( error, response ) {\r\n                    Binance.options.listenKey = response.listenKey;\r\n                    setTimeout( function userDataKeepAlive() { // keepalive\r\n                        try {\r\n                            apiRequest( base + 'v3/userDataStream?listenKey=' + Binance.options.listenKey, {}, function ( err ) {\r\n                                if ( err ) setTimeout( userDataKeepAlive, 60000 ); // retry in 1 minute\r\n                                else setTimeout( userDataKeepAlive, 60 * 30 * 1000 ); // 30 minute keepalive\r\n                            }, 'PUT' );\r\n                        } catch ( error ) {\r\n                            setTimeout( userDataKeepAlive, 60000 ); // retry in 1 minute\r\n                        }\r\n                    }, 60 * 30 * 1000 ); // 30 minute keepalive\r\n                    Binance.options.balance_callback = callback;\r\n                    Binance.options.execution_callback = execution_callback;\r\n                    Binance.options.list_status_callback = list_status_callback;\r\n                    const subscription = subscribe( Binance.options.listenKey, userDataHandler, reconnect );\r\n                    if ( subscribed_callback ) subscribed_callback( subscription.endpoint );\r\n                }, 'POST' );\r\n            },\r\n\r\n            /**\r\n             * Margin Userdata websockets function\r\n             * @param {function} callback - the callback function\r\n             * @param {function} execution_callback - optional execution callback\r\n             * @param {function} subscribed_callback - subscription callback\r\n             * @param {function} list_status_callback - status callback\r\n             * @return {undefined}\r\n             */\r\n            userMarginData: function userMarginData( callback, execution_callback = false, subscribed_callback = false, list_status_callback = false ) {\r\n                let reconnect = () => {\r\n                    if ( Binance.options.reconnect ) userMarginData( callback, execution_callback, subscribed_callback );\r\n                };\r\n                apiRequest( sapi + 'v1/userDataStream', {}, function ( error, response ) {\r\n                    Binance.options.listenMarginKey = response.listenKey;\r\n                    setTimeout( function userDataKeepAlive() { // keepalive\r\n                        try {\r\n                            apiRequest( sapi + 'v1/userDataStream?listenKey=' + Binance.options.listenMarginKey, {}, function ( err ) {\r\n                                if ( err ) setTimeout( userDataKeepAlive, 60000 ); // retry in 1 minute\r\n                                else setTimeout( userDataKeepAlive, 60 * 30 * 1000 ); // 30 minute keepalive\r\n                            }, 'PUT' );\r\n                        } catch ( error ) {\r\n                            setTimeout( userDataKeepAlive, 60000 ); // retry in 1 minute\r\n                        }\r\n                    }, 60 * 30 * 1000 ); // 30 minute keepalive\r\n                    Binance.options.margin_balance_callback = callback;\r\n                    Binance.options.margin_execution_callback = execution_callback;\r\n                    Binance.options.margin_list_status_callback = list_status_callback;\r\n                    const subscription = subscribe( Binance.options.listenMarginKey, userMarginDataHandler, reconnect );\r\n                    if ( subscribed_callback ) subscribed_callback( subscription.endpoint );\r\n                }, 'POST' );\r\n            },\r\n\r\n            /**\r\n             * Future Userdata websockets function\r\n             * @param {function} margin_call_callback\r\n             * @param {function} account_update_callback\r\n             * @param {function} order_update_callback\r\n             * @param {Function} subscribed_callback - subscription callback\r\n             */\r\n            userFutureData: function userFutureData( margin_call_callback, account_update_callback = undefined, order_update_callback = undefined, subscribed_callback = undefined, account_config_update_callback = undefined ) {\r\n                const url = ( Binance.options.test ) ? fapiTest : fapi;\r\n\r\n                let reconnect = () => {\r\n                    if ( Binance.options.reconnect ) userFutureData( margin_call_callback, account_update_callback, order_update_callback, subscribed_callback )\r\n                }\r\n\r\n                apiRequest( url + 'v1/listenKey', {}, function ( error, response ) {\r\n                    Binance.options.listenFutureKey = response.listenKey;\r\n                    setTimeout( function userDataKeepAlive() { // keepalive\r\n                        try {\r\n                            apiRequest( url + 'v1/listenKey?listenKey=' + Binance.options.listenFutureKey, {}, function ( err ) {\r\n                                if ( err ) setTimeout( userDataKeepAlive, 60000 ); // retry in 1 minute\r\n                                else setTimeout( userDataKeepAlive, 60 * 30 * 1000 ); // 30 minute keepalive\r\n                            }, 'PUT' );\r\n                        } catch ( error ) {\r\n                            setTimeout( userDataKeepAlive, 60000 ); // retry in 1 minute\r\n                        }\r\n                    }, 60 * 30 * 1000 ); // 30 minute keepalive\r\n                    Binance.options.future_margin_call_callback = margin_call_callback;\r\n                    Binance.options.future_account_update_callback = account_update_callback;\r\n                    Binance.options.future_account_config_update_callback = account_config_update_callback;\r\n                    Binance.options.future_order_update_callback = order_update_callback;\r\n                    const subscription = futuresSubscribe( Binance.options.listenFutureKey, userFutureDataHandler, { reconnect } );\r\n                    if ( subscribed_callback ) subscribed_callback( subscription.endpoint );\r\n                }, 'POST' );\r\n            },\r\n\r\n            /**\r\n           * Delivery Userdata websockets function\r\n           * @param {function} margin_call_callback\r\n           * @param {function} account_update_callback\r\n           * @param {function} order_update_callback\r\n           * @param {Function} subscribed_callback - subscription callback\r\n           */\r\n            userDeliveryData: function userDeliveryData(\r\n                margin_call_callback,\r\n                account_update_callback = undefined,\r\n                order_update_callback = undefined,\r\n                subscribed_callback = undefined\r\n            ) {\r\n                const url = Binance.options.test ? dapiTest : dapi;\r\n\r\n                let reconnect = () => {\r\n                    if ( Binance.options.reconnect )\r\n                        userDeliveryData(\r\n                            margin_call_callback,\r\n                            account_update_callback,\r\n                            order_update_callback,\r\n                            subscribed_callback\r\n                        );\r\n                };\r\n\r\n                apiRequest(\r\n                    url + \"v1/listenKey\",\r\n                    {},\r\n                    function ( error, response ) {\r\n                        Binance.options.listenDeliveryKey = response.listenKey;\r\n                        setTimeout( function userDataKeepAlive() {\r\n                            // keepalive\r\n                            try {\r\n                                apiRequest(\r\n                                    url +\r\n                        \"v1/listenKey?listenKey=\" +\r\n                        Binance.options.listenDeliveryKey,\r\n                                    {},\r\n                                    function ( err ) {\r\n                                        if ( err ) setTimeout( userDataKeepAlive, 60000 );\r\n                                        // retry in 1 minute\r\n                                        else setTimeout( userDataKeepAlive, 60 * 30 * 1000 ); // 30 minute keepalive\r\n                                    },\r\n                                    \"PUT\"\r\n                                );\r\n                            } catch ( error ) {\r\n                                setTimeout( userDataKeepAlive, 60000 ); // retry in 1 minute\r\n                            }\r\n                        }, 60 * 30 * 1000 ); // 30 minute keepalive\r\n                        Binance.options.delivery_margin_call_callback = margin_call_callback;\r\n                        Binance.options.delivery_account_update_callback = account_update_callback;\r\n                        Binance.options.delivery_order_update_callback = order_update_callback;\r\n                        const subscription = deliverySubscribe(\r\n                            Binance.options.listenDeliveryKey,\r\n                            userDeliveryDataHandler,\r\n                            { reconnect }\r\n                        );\r\n                        if ( subscribed_callback ) subscribed_callback( subscription.endpoint );\r\n                    },\r\n                    \"POST\"\r\n                );\r\n            },\r\n\r\n            /**\r\n             * Subscribe to a generic websocket\r\n             * @param {string} url - the websocket endpoint\r\n             * @param {function} callback - optional execution callback\r\n             * @param {boolean} reconnect - subscription callback\r\n             * @return {WebSocket} the websocket reference\r\n             */\r\n            subscribe: function ( url, callback, reconnect = false ) {\r\n                return subscribe( url, callback, reconnect );\r\n            },\r\n\r\n            /**\r\n             * Subscribe to a generic combined websocket\r\n             * @param {string} url - the websocket endpoint\r\n             * @param {function} callback - optional execution callback\r\n             * @param {boolean} reconnect - subscription callback\r\n             * @return {WebSocket} the websocket reference\r\n             */\r\n            subscribeCombined: function ( url, callback, reconnect = false ) {\r\n                return subscribeCombined( url, callback, reconnect );\r\n            },\r\n\r\n            /**\r\n             * Returns the known websockets subscriptions\r\n             * @return {array} array of web socket subscriptions\r\n             */\r\n            subscriptions: function() {\r\n                return Binance.subscriptions;\r\n            },\r\n\r\n            /**\r\n             * Terminates a web socket\r\n             * @param {string} endpoint - the string associated with the endpoint\r\n             * @return {undefined}\r\n             */\r\n            terminate: function ( endpoint ) {\r\n                if ( Binance.options.verbose ) Binance.options.log( 'WebSocket terminating:', endpoint );\r\n                return terminate( endpoint );\r\n            },\r\n\r\n            /**\r\n             * Websocket depth chart\r\n             * @param {array/string} symbols - an array or string of symbols to query\r\n             * @param {function} callback - callback function\r\n             * @return {string} the websocket endpoint\r\n             */\r\n            depth: function depth ( symbols, callback ) {\r\n                let reconnect = () => {\r\n                    if ( Binance.options.reconnect ) depth( symbols, callback );\r\n                };\r\n                let subscription;\r\n                if ( Array.isArray( symbols ) ) {\r\n                    if ( !isArrayUnique( symbols ) ) throw Error( 'depth: \"symbols\" cannot contain duplicate elements.' );\r\n                    let streams = symbols.map( function ( symbol ) {\r\n                        return symbol.toLowerCase() + '@depth@100ms';\r\n                    } );\r\n                    subscription = subscribeCombined( streams, callback, reconnect );\r\n                } else {\r\n                    let symbol = symbols;\r\n                    subscription = subscribe( symbol.toLowerCase() + '@depth@100ms', callback, reconnect );\r\n                }\r\n                return subscription.endpoint;\r\n            },\r\n\r\n            /**\r\n             * Websocket depth cache\r\n             * @param {array/string} symbols - an array or string of symbols to query\r\n             * @param {function} callback - callback function\r\n             * @param {int} limit - the number of entries\r\n             * @return {string} the websocket endpoint\r\n             */\r\n            depthCache: function depthCacheFunction( symbols, callback, limit = 500 ) {\r\n                let reconnect = () => {\r\n                    if ( Binance.options.reconnect ) depthCacheFunction( symbols, callback, limit );\r\n                };\r\n\r\n                let symbolDepthInit = symbol => {\r\n                    if ( typeof Binance.depthCacheContext[symbol] === 'undefined' ) Binance.depthCacheContext[symbol] = {};\r\n                    let context = Binance.depthCacheContext[symbol];\r\n                    context.snapshotUpdateId = null;\r\n                    context.lastEventUpdateId = null;\r\n                    context.messageQueue = [];\r\n                    Binance.depthCache[symbol] = { bids: {}, asks: {} };\r\n                };\r\n\r\n                let assignEndpointIdToContext = ( symbol, endpointId ) => {\r\n                    if ( Binance.depthCacheContext[symbol] ) {\r\n                        let context = Binance.depthCacheContext[symbol];\r\n                        context.endpointId = endpointId;\r\n                    }\r\n                };\r\n\r\n                let handleDepthStreamData = depth => {\r\n                    let symbol = depth.s;\r\n                    let context = Binance.depthCacheContext[symbol];\r\n                    if ( context.messageQueue && !context.snapshotUpdateId ) {\r\n                        context.messageQueue.push( depth );\r\n                    } else {\r\n                        try {\r\n                            depthHandler( depth );\r\n                        } catch ( err ) {\r\n                            return terminate( context.endpointId, true );\r\n                        }\r\n                        if ( callback ) callback( symbol, Binance.depthCache[symbol], context );\r\n                    }\r\n                };\r\n\r\n                let getSymbolDepthSnapshot = ( symbol, cb ) => {\r\n                    publicRequest( base + 'v3/depth', { symbol: symbol, limit: limit }, function ( error, json ) {\r\n                        if ( error ) {\r\n                            return cb( error, null );\r\n                        }\r\n                        // Store symbol next use\r\n                        json.symb = symbol;\r\n                        cb( null, json )\r\n                    } );\r\n                };\r\n\r\n                let updateSymbolDepthCache = json => {\r\n                    // Get previous store symbol\r\n                    let symbol = json.symb;\r\n                    // Initialize depth cache from snapshot\r\n                    Binance.depthCache[symbol] = depthData( json );\r\n                    // Prepare depth cache context\r\n                    let context = Binance.depthCacheContext[symbol];\r\n                    context.snapshotUpdateId = json.lastUpdateId;\r\n                    context.messageQueue = context.messageQueue.filter( depth => depth.u > context.snapshotUpdateId );\r\n                    // Process any pending depth messages\r\n                    for ( let depth of context.messageQueue ) {\r\n                        /* Although sync errors shouldn't ever happen here, we catch and swallow them anyway\r\n                         just in case. The stream handler function above will deal with broken caches. */\r\n                        try {\r\n                            depthHandler( depth );\r\n                        } catch ( err ) {\r\n                            // Do nothing\r\n                        }\r\n                    }\r\n                    delete context.messageQueue;\r\n                    if ( callback ) callback( symbol, Binance.depthCache[symbol] );\r\n                };\r\n\r\n                /* If an array of symbols are sent we use a combined stream connection rather.\r\n                 This is transparent to the developer, and results in a single socket connection.\r\n                 This essentially eliminates \"unexpected response\" errors when subscribing to a lot of data. */\r\n                let subscription;\r\n                if ( Array.isArray( symbols ) ) {\r\n                    if ( !isArrayUnique( symbols ) ) throw Error( 'depthCache: \"symbols\" cannot contain duplicate elements.' );\r\n                    symbols.forEach( symbolDepthInit );\r\n                    let streams = symbols.map( function ( symbol ) {\r\n                        return symbol.toLowerCase() + `@depth@100ms`;\r\n                    } );\r\n                    subscription = subscribeCombined( streams, handleDepthStreamData, reconnect, function () {\r\n                        async.mapLimit( symbols, 50, getSymbolDepthSnapshot, ( err, results ) => {\r\n                            if ( err ) throw err;\r\n                            results.forEach( updateSymbolDepthCache );\r\n                        } );\r\n                    } );\r\n                    symbols.forEach( s => assignEndpointIdToContext( s, subscription.endpoint ) );\r\n                } else {\r\n                    let symbol = symbols;\r\n                    symbolDepthInit( symbol );\r\n                    subscription = subscribe( symbol.toLowerCase() + `@depth@100ms`, handleDepthStreamData, reconnect, function () {\r\n                        async.mapLimit( [ symbol ], 1, getSymbolDepthSnapshot, ( err, results ) => {\r\n                            if ( err ) throw err;\r\n                            results.forEach( updateSymbolDepthCache );\r\n                        } );\r\n                    } );\r\n                    assignEndpointIdToContext( symbol, subscription.endpoint );\r\n                }\r\n                return subscription.endpoint;\r\n            },\r\n\r\n            /**\r\n             * Clear Websocket depth cache\r\n             * @param {String|Array} symbols   - a single symbol, or an array of symbols, to clear the cache of\r\n             * @returns {void}\r\n             */\r\n            clearDepthCache( symbols ) {\r\n                const symbolsArr = Array.isArray( symbols ) ? symbols : [ symbols ];\r\n                symbolsArr.forEach( thisSymbol => {\r\n                    delete Binance.depthCache[thisSymbol];\r\n                } );\r\n            },\r\n\r\n            /**\r\n             * Websocket staggered depth cache\r\n             * @param {array/string} symbols - an array of symbols to query\r\n             * @param {function} callback - callback function\r\n             * @param {int} limit - the number of entries\r\n             * @param {int} stagger - ms between each depth cache\r\n             * @return {Promise} the websocket endpoint\r\n             */\r\n            depthCacheStaggered: function ( symbols, callback, limit = 100, stagger = 200 ) {\r\n                if ( !Array.isArray( symbols ) ) symbols = [ symbols ];\r\n                let chain = null;\r\n\r\n                symbols.forEach( symbol => {\r\n                    let promise = () => new Promise( resolve => {\r\n                        this.depthCache( symbol, callback, limit );\r\n                        setTimeout( resolve, stagger );\r\n                    } );\r\n                    chain = chain ? chain.then( promise ) : promise();\r\n                } );\r\n\r\n                return chain;\r\n            },\r\n\r\n            /**\r\n             * Websocket aggregated trades\r\n             * @param {array/string} symbols - an array or string of symbols to query\r\n             * @param {function} callback - callback function\r\n             * @return {string} the websocket endpoint\r\n             */\r\n            aggTrades: function trades( symbols, callback ) {\r\n                let reconnect = () => {\r\n                    if ( Binance.options.reconnect ) trades( symbols, callback );\r\n                };\r\n                let subscription;\r\n                if ( Array.isArray( symbols ) ) {\r\n                    if ( !isArrayUnique( symbols ) ) throw Error( 'trades: \"symbols\" cannot contain duplicate elements.' );\r\n                    let streams = symbols.map( function ( symbol ) {\r\n                        return symbol.toLowerCase() + '@aggTrade';\r\n                    } );\r\n                    subscription = subscribeCombined( streams, callback, reconnect );\r\n                } else {\r\n                    let symbol = symbols;\r\n                    subscription = subscribe( symbol.toLowerCase() + '@aggTrade', callback, reconnect );\r\n                }\r\n                return subscription.endpoint;\r\n            },\r\n\r\n            /**\r\n            * Websocket raw trades\r\n            * @param {array/string} symbols - an array or string of symbols to query\r\n            * @param {function} callback - callback function\r\n            * @return {string} the websocket endpoint\r\n            */\r\n            trades: function trades( symbols, callback ) {\r\n                let reconnect = () => {\r\n                    if ( Binance.options.reconnect ) trades( symbols, callback );\r\n                };\r\n\r\n                let subscription;\r\n                if ( Array.isArray( symbols ) ) {\r\n                    if ( !isArrayUnique( symbols ) ) throw Error( 'trades: \"symbols\" cannot contain duplicate elements.' );\r\n                    let streams = symbols.map( function ( symbol ) {\r\n                        return symbol.toLowerCase() + '@trade';\r\n                    } );\r\n                    subscription = subscribeCombined( streams, callback, reconnect );\r\n                } else {\r\n                    let symbol = symbols;\r\n                    subscription = subscribe( symbol.toLowerCase() + '@trade', callback, reconnect );\r\n                }\r\n                return subscription.endpoint;\r\n            },\r\n\r\n            /**\r\n             * Websocket klines\r\n             * @param {array/string} symbols - an array or string of symbols to query\r\n             * @param {string} interval - the time interval\r\n             * @param {function} callback - callback function\r\n             * @param {int} limit - maximum results, no more than 1000\r\n             * @return {string} the websocket endpoint\r\n             */\r\n            chart: function chart( symbols, interval, callback, limit = 500 ) {\r\n                let reconnect = () => {\r\n                    if ( Binance.options.reconnect ) chart( symbols, interval, callback, limit );\r\n                };\r\n\r\n                let symbolChartInit = symbol => {\r\n                    if ( typeof Binance.info[symbol] === 'undefined' ) Binance.info[symbol] = {};\r\n                    if ( typeof Binance.info[symbol][interval] === 'undefined' ) Binance.info[symbol][interval] = {};\r\n                    if ( typeof Binance.ohlc[symbol] === 'undefined' ) Binance.ohlc[symbol] = {};\r\n                    if ( typeof Binance.ohlc[symbol][interval] === 'undefined' ) Binance.ohlc[symbol][interval] = {};\r\n                    if ( typeof Binance.ohlcLatest[symbol] === 'undefined' ) Binance.ohlcLatest[symbol] = {};\r\n                    if ( typeof Binance.ohlcLatest[symbol][interval] === 'undefined' ) Binance.ohlcLatest[symbol][interval] = {};\r\n                    if ( typeof Binance.klineQueue[symbol] === 'undefined' ) Binance.klineQueue[symbol] = {};\r\n                    if ( typeof Binance.klineQueue[symbol][interval] === 'undefined' ) Binance.klineQueue[symbol][interval] = [];\r\n                    Binance.info[symbol][interval].timestamp = 0;\r\n                }\r\n\r\n                let handleKlineStreamData = kline => {\r\n                    let symbol = kline.s, interval = kline.k.i;\r\n                    if ( !Binance.info[symbol][interval].timestamp ) {\r\n                        if ( typeof ( Binance.klineQueue[symbol][interval] ) !== 'undefined' && kline !== null ) {\r\n                            Binance.klineQueue[symbol][interval].push( kline );\r\n                        }\r\n                    } else {\r\n                        //Binance.options.log('@klines at ' + kline.k.t);\r\n                        klineHandler( symbol, kline );\r\n                        if ( callback ) callback( symbol, interval, klineConcat( symbol, interval ) );\r\n                    }\r\n                };\r\n\r\n                let getSymbolKlineSnapshot = ( symbol, limit = 500 ) => {\r\n                    publicRequest( base + 'v3/klines', { symbol: symbol, interval: interval, limit: limit }, function ( error, data ) {\r\n                        klineData( symbol, interval, data );\r\n                        //Binance.options.log('/klines at ' + Binance.info[symbol][interval].timestamp);\r\n                        if ( typeof Binance.klineQueue[symbol][interval] !== 'undefined' ) {\r\n                            for ( let kline of Binance.klineQueue[symbol][interval] ) klineHandler( symbol, kline, Binance.info[symbol][interval].timestamp );\r\n                            delete Binance.klineQueue[symbol][interval];\r\n                        }\r\n                        if ( callback ) callback( symbol, interval, klineConcat( symbol, interval ) );\r\n                    } );\r\n                };\r\n\r\n                let subscription;\r\n                if ( Array.isArray( symbols ) ) {\r\n                    if ( !isArrayUnique( symbols ) ) throw Error( 'chart: \"symbols\" cannot contain duplicate elements.' );\r\n                    symbols.forEach( symbolChartInit );\r\n                    let streams = symbols.map( function ( symbol ) {\r\n                        return symbol.toLowerCase() + '@kline_' + interval;\r\n                    } );\r\n                    subscription = subscribeCombined( streams, handleKlineStreamData, reconnect );\r\n                    symbols.forEach( element => getSymbolKlineSnapshot( element, limit ) );\r\n                } else {\r\n                    let symbol = symbols;\r\n                    symbolChartInit( symbol );\r\n                    subscription = subscribe( symbol.toLowerCase() + '@kline_' + interval, handleKlineStreamData, reconnect );\r\n                    getSymbolKlineSnapshot( symbol, limit );\r\n                }\r\n                return subscription.endpoint;\r\n            },\r\n\r\n            /**\r\n             * Websocket candle sticks\r\n             * @param {array/string} symbols - an array or string of symbols to query\r\n             * @param {string} interval - the time interval\r\n             * @param {function} callback - callback function\r\n             * @return {string} the websocket endpoint\r\n             */\r\n            candlesticks: function candlesticks( symbols, interval, callback ) {\r\n                let reconnect = () => {\r\n                    if ( Binance.options.reconnect ) candlesticks( symbols, interval, callback );\r\n                };\r\n\r\n                /* If an array of symbols are sent we use a combined stream connection rather.\r\n                 This is transparent to the developer, and results in a single socket connection.\r\n                 This essentially eliminates \"unexpected response\" errors when subscribing to a lot of data. */\r\n                let subscription;\r\n                if ( Array.isArray( symbols ) ) {\r\n                    if ( !isArrayUnique( symbols ) ) throw Error( 'candlesticks: \"symbols\" cannot contain duplicate elements.' );\r\n                    let streams = symbols.map( function ( symbol ) {\r\n                        return symbol.toLowerCase() + '@kline_' + interval;\r\n                    } );\r\n                    subscription = subscribeCombined( streams, callback, reconnect );\r\n                } else {\r\n                    let symbol = symbols.toLowerCase();\r\n                    subscription = subscribe( symbol + '@kline_' + interval, callback, reconnect );\r\n                }\r\n                return subscription.endpoint;\r\n            },\r\n\r\n            /**\r\n             * Websocket mini ticker\r\n             * @param {function} callback - callback function\r\n             * @return {string} the websocket endpoint\r\n             */\r\n            miniTicker: function miniTicker( callback ) {\r\n                let reconnect = () => {\r\n                    if ( Binance.options.reconnect ) miniTicker( callback );\r\n                };\r\n                let subscription = subscribe( '!miniTicker@arr', function ( data ) {\r\n                    let markets = {};\r\n                    for ( let obj of data ) {\r\n                        markets[obj.s] = {\r\n                            close: obj.c,\r\n                            open: obj.o,\r\n                            high: obj.h,\r\n                            low: obj.l,\r\n                            volume: obj.v,\r\n                            quoteVolume: obj.q,\r\n                            eventTime: obj.E\r\n                        };\r\n                    }\r\n                    callback( markets );\r\n                }, reconnect );\r\n                return subscription.endpoint;\r\n            },\r\n\r\n            /**\r\n             * Spot WebSocket bookTicker (bid/ask quotes including price & amount)\r\n             * @param {symbol} symbol name or false. can also be a callback\r\n             * @param {function} callback - callback function\r\n             * @return {string} the websocket endpoint\r\n             */\r\n            bookTickers: function bookTickerStream( symbol = false, callback = console.log ) {\r\n                if ( typeof symbol == 'function' ) {\r\n                    callback = symbol;\r\n                    symbol = false;\r\n                }\r\n                let reconnect = () => {\r\n                    if ( Binance.options.reconnect ) bookTickerStream( symbol, callback );\r\n                };\r\n                const endpoint = symbol ? `${ symbol.toLowerCase() }@bookTicker` : '!bookTicker'\r\n                let subscription = subscribe( endpoint, data => callback( fBookTickerConvertData( data ) ), reconnect );\r\n                return subscription.endpoint;\r\n            },\r\n\r\n            /**\r\n             * Websocket prevday percentage\r\n             * @param {array/string} symbols - an array or string of symbols to query\r\n             * @param {function} callback - callback function\r\n             * @param {boolean} singleCallback - avoid call one callback for each symbol in data array\r\n             * @return {string} the websocket endpoint\r\n             */\r\n            prevDay: function prevDay( symbols, callback, singleCallback ) {\r\n                let reconnect = () => {\r\n                    if ( Binance.options.reconnect ) prevDay( symbols, callback, singleCallback );\r\n                };\r\n\r\n                let subscription;\r\n                // Combine stream for array of symbols\r\n                if ( Array.isArray( symbols ) ) {\r\n                    if ( !isArrayUnique( symbols ) ) throw Error( 'prevDay: \"symbols\" cannot contain duplicate elements.' );\r\n                    let streams = symbols.map( function ( symbol ) {\r\n                        return symbol.toLowerCase() + '@ticker';\r\n                    } );\r\n                    subscription = subscribeCombined( streams, function ( data ) {\r\n                        prevDayStreamHandler( data, callback );\r\n                    }, reconnect );\r\n                    // Raw stream for  a single symbol\r\n                } else if ( symbols ) {\r\n                    let symbol = symbols;\r\n                    subscription = subscribe( symbol.toLowerCase() + '@ticker', function ( data ) {\r\n                        prevDayStreamHandler( data, callback );\r\n                    }, reconnect );\r\n                    // Raw stream of all listed symbols\r\n                } else {\r\n                    subscription = subscribe( '!ticker@arr', function ( data ) {\r\n                        if ( singleCallback ) {\r\n                            prevDayStreamHandler( data, callback );\r\n                        } else {\r\n                            for ( let line of data ) {\r\n                                prevDayStreamHandler( line, callback );\r\n                            }\r\n                        }\r\n                    }, reconnect );\r\n                }\r\n                return subscription.endpoint;\r\n            }\r\n        }\r\n    };\r\n}\r\nmodule.exports = api;\r\n//https://github.com/binance-exchange/binance-official-api-docs\r\n"]},"metadata":{},"sourceType":"script"}