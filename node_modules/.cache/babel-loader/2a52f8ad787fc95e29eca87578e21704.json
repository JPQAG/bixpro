{"ast":null,"code":"'use strict'; //  ---------------------------------------------------------------------------\n\nconst Exchange = require('./base/Exchange');\n\nconst {\n  ExchangeError,\n  InsufficientFunds,\n  InvalidOrder,\n  AuthenticationError,\n  PermissionDenied,\n  InvalidNonce,\n  OrderNotFound,\n  DDoSProtection\n} = require('./base/errors');\n\nconst Precise = require('./base/Precise'); //  ---------------------------------------------------------------------------\n\n\nmodule.exports = class btcbox extends Exchange {\n  describe() {\n    return this.deepExtend(super.describe(), {\n      'id': 'btcbox',\n      'name': 'BtcBox',\n      'countries': ['JP'],\n      'rateLimit': 1000,\n      'version': 'v1',\n      'has': {\n        'cancelOrder': true,\n        'CORS': false,\n        'createOrder': true,\n        'fetchBalance': true,\n        'fetchOpenOrders': true,\n        'fetchOrder': true,\n        'fetchOrderBook': true,\n        'fetchOrders': true,\n        'fetchTicker': true,\n        'fetchTickers': false,\n        'fetchTrades': true\n      },\n      'urls': {\n        'logo': 'https://user-images.githubusercontent.com/51840849/87327317-98c55400-c53c-11ea-9a11-81f7d951cc74.jpg',\n        'api': 'https://www.btcbox.co.jp/api',\n        'www': 'https://www.btcbox.co.jp/',\n        'doc': 'https://blog.btcbox.jp/en/archives/8762',\n        'fees': 'https://support.btcbox.co.jp/hc/en-us/articles/360001235694-Fees-introduction'\n      },\n      'api': {\n        'public': {\n          'get': ['depth', 'orders', 'ticker']\n        },\n        'private': {\n          'post': ['balance', 'trade_add', 'trade_cancel', 'trade_list', 'trade_view', 'wallet']\n        }\n      },\n      'markets': {\n        'BTC/JPY': {\n          'id': 'btc',\n          'symbol': 'BTC/JPY',\n          'base': 'BTC',\n          'quote': 'JPY',\n          'baseId': 'btc',\n          'quoteId': 'jpy',\n          'taker': 0.05 / 100,\n          'maker': 0.05 / 100\n        },\n        'ETH/JPY': {\n          'id': 'eth',\n          'symbol': 'ETH/JPY',\n          'base': 'ETH',\n          'quote': 'JPY',\n          'baseId': 'eth',\n          'quoteId': 'jpy',\n          'taker': 0.10 / 100,\n          'maker': 0.10 / 100\n        },\n        'LTC/JPY': {\n          'id': 'ltc',\n          'symbol': 'LTC/JPY',\n          'base': 'LTC',\n          'quote': 'JPY',\n          'baseId': 'ltc',\n          'quoteId': 'jpy',\n          'taker': 0.10 / 100,\n          'maker': 0.10 / 100\n        },\n        'BCH/JPY': {\n          'id': 'bch',\n          'symbol': 'BCH/JPY',\n          'base': 'BCH',\n          'quote': 'JPY',\n          'baseId': 'bch',\n          'quoteId': 'jpy',\n          'taker': 0.10 / 100,\n          'maker': 0.10 / 100\n        }\n      },\n      'exceptions': {\n        '104': AuthenticationError,\n        '105': PermissionDenied,\n        '106': InvalidNonce,\n        '107': InvalidOrder,\n        // price should be an integer\n        '200': InsufficientFunds,\n        '201': InvalidOrder,\n        // amount too small\n        '202': InvalidOrder,\n        // price should be [0 : 1000000]\n        '203': OrderNotFound,\n        '401': OrderNotFound,\n        // cancel canceled, closed or non-existent order\n        '402': DDoSProtection\n      }\n    });\n  }\n\n  async fetchBalance(params = {}) {\n    await this.loadMarkets();\n    const response = await this.privatePostBalance(params);\n    const result = {\n      'info': response\n    };\n    const codes = Object.keys(this.currencies);\n\n    for (let i = 0; i < codes.length; i++) {\n      const code = codes[i];\n      const currency = this.currency(code);\n      const currencyId = currency['id'];\n      const free = currencyId + '_balance';\n\n      if (free in response) {\n        const account = this.account();\n        const used = currencyId + '_lock';\n        account['free'] = this.safeString(response, free);\n        account['used'] = this.safeString(response, used);\n        result[code] = account;\n      }\n    }\n\n    return this.parseBalance(result, false);\n  }\n\n  async fetchOrderBook(symbol, limit = undefined, params = {}) {\n    await this.loadMarkets();\n    const market = this.market(symbol);\n    const request = {};\n    const numSymbols = this.symbols.length;\n\n    if (numSymbols > 1) {\n      request['coin'] = market['baseId'];\n    }\n\n    const response = await this.publicGetDepth(this.extend(request, params));\n    return this.parseOrderBook(response, symbol);\n  }\n\n  parseTicker(ticker, market = undefined) {\n    const timestamp = this.milliseconds();\n    let symbol = undefined;\n\n    if (market !== undefined) {\n      symbol = market['symbol'];\n    }\n\n    const last = this.safeNumber(ticker, 'last');\n    return {\n      'symbol': symbol,\n      'timestamp': timestamp,\n      'datetime': this.iso8601(timestamp),\n      'high': this.safeNumber(ticker, 'high'),\n      'low': this.safeNumber(ticker, 'low'),\n      'bid': this.safeNumber(ticker, 'buy'),\n      'bidVolume': undefined,\n      'ask': this.safeNumber(ticker, 'sell'),\n      'askVolume': undefined,\n      'vwap': undefined,\n      'open': undefined,\n      'close': last,\n      'last': last,\n      'previousClose': undefined,\n      'change': undefined,\n      'percentage': undefined,\n      'average': undefined,\n      'baseVolume': this.safeNumber(ticker, 'vol'),\n      'quoteVolume': this.safeNumber(ticker, 'volume'),\n      'info': ticker\n    };\n  }\n\n  async fetchTicker(symbol, params = {}) {\n    await this.loadMarkets();\n    const market = this.market(symbol);\n    const request = {};\n    const numSymbols = this.symbols.length;\n\n    if (numSymbols > 1) {\n      request['coin'] = market['baseId'];\n    }\n\n    const response = await this.publicGetTicker(this.extend(request, params));\n    return this.parseTicker(response, market);\n  }\n\n  parseTrade(trade, market = undefined) {\n    const timestamp = this.safeTimestamp(trade, 'date');\n    let symbol = undefined;\n\n    if (market !== undefined) {\n      symbol = market['symbol'];\n    }\n\n    const id = this.safeString(trade, 'tid');\n    const priceString = this.safeString(trade, 'price');\n    const amountString = this.safeString(trade, 'amount');\n    const price = this.parseNumber(priceString);\n    const amount = this.parseNumber(amountString);\n    const cost = this.parseNumber(Precise.stringMul(priceString, amountString));\n    const type = undefined;\n    const side = this.safeString(trade, 'type');\n    return {\n      'info': trade,\n      'id': id,\n      'order': undefined,\n      'timestamp': timestamp,\n      'datetime': this.iso8601(timestamp),\n      'symbol': symbol,\n      'type': type,\n      'side': side,\n      'takerOrMaker': undefined,\n      'price': price,\n      'amount': amount,\n      'cost': cost,\n      'fee': undefined\n    };\n  }\n\n  async fetchTrades(symbol, since = undefined, limit = undefined, params = {}) {\n    await this.loadMarkets();\n    const market = this.market(symbol);\n    const request = {};\n    const numSymbols = this.symbols.length;\n\n    if (numSymbols > 1) {\n      request['coin'] = market['baseId'];\n    }\n\n    const response = await this.publicGetOrders(this.extend(request, params));\n    return this.parseTrades(response, market, since, limit);\n  }\n\n  async createOrder(symbol, type, side, amount, price = undefined, params = {}) {\n    await this.loadMarkets();\n    const market = this.market(symbol);\n    const request = {\n      'amount': amount,\n      'price': price,\n      'type': side,\n      'coin': market['baseId']\n    };\n    const response = await this.privatePostTradeAdd(this.extend(request, params)); //\n    //     {\n    //         \"result\":true,\n    //         \"id\":\"11\"\n    //     }\n    //\n\n    return this.parseOrder(response, market);\n  }\n\n  async cancelOrder(id, symbol = undefined, params = {}) {\n    await this.loadMarkets(); // a special case for btcbox â€“ default symbol is BTC/JPY\n\n    if (symbol === undefined) {\n      symbol = 'BTC/JPY';\n    }\n\n    const market = this.market(symbol);\n    const request = {\n      'id': id,\n      'coin': market['baseId']\n    };\n    const response = await this.privatePostTradeCancel(this.extend(request, params)); //\n    //     {\"result\":true, \"id\":\"11\"}\n    //\n\n    return this.parseOrder(response, market);\n  }\n\n  parseOrderStatus(status) {\n    const statuses = {\n      // TODO: complete list\n      'part': 'open',\n      // partially or not at all executed\n      'all': 'closed',\n      // fully executed\n      'cancelled': 'canceled',\n      'closed': 'closed',\n      // never encountered, seems to be bug in the doc\n      'no': 'closed' // not clarified in the docs...\n\n    };\n    return this.safeString(statuses, status, status);\n  }\n\n  parseOrder(order, market = undefined) {\n    //\n    //     {\n    //         \"id\":11,\n    //         \"datetime\":\"2014-10-21 10:47:20\",\n    //         \"type\":\"sell\",\n    //         \"price\":42000,\n    //         \"amount_original\":1.2,\n    //         \"amount_outstanding\":1.2,\n    //         \"status\":\"closed\",\n    //         \"trades\":[]\n    //     }\n    //\n    const id = this.safeString(order, 'id');\n    const datetimeString = this.safeString(order, 'datetime');\n    let timestamp = undefined;\n\n    if (datetimeString !== undefined) {\n      timestamp = this.parse8601(order['datetime'] + '+09:00'); // Tokyo time\n    }\n\n    const amount = this.safeNumber(order, 'amount_original');\n    const remaining = this.safeNumber(order, 'amount_outstanding');\n    const price = this.safeNumber(order, 'price'); // status is set by fetchOrder method only\n\n    let status = this.parseOrderStatus(this.safeString(order, 'status')); // fetchOrders do not return status, use heuristic\n\n    if (status === undefined) {\n      if (remaining !== undefined && remaining === 0) {\n        status = 'closed';\n      }\n    }\n\n    const trades = undefined; // todo: this.parseTrades (order['trades']);\n\n    let symbol = undefined;\n\n    if (market !== undefined) {\n      symbol = market['symbol'];\n    }\n\n    const side = this.safeString(order, 'type');\n    return this.safeOrder({\n      'id': id,\n      'clientOrderId': undefined,\n      'timestamp': timestamp,\n      'datetime': this.iso8601(timestamp),\n      'lastTradeTimestamp': undefined,\n      'amount': amount,\n      'remaining': remaining,\n      'filled': undefined,\n      'side': side,\n      'type': undefined,\n      'timeInForce': undefined,\n      'postOnly': undefined,\n      'status': status,\n      'symbol': symbol,\n      'price': price,\n      'stopPrice': undefined,\n      'cost': undefined,\n      'trades': trades,\n      'fee': undefined,\n      'info': order,\n      'average': undefined\n    });\n  }\n\n  async fetchOrder(id, symbol = undefined, params = {}) {\n    await this.loadMarkets(); // a special case for btcbox â€“ default symbol is BTC/JPY\n\n    if (symbol === undefined) {\n      symbol = 'BTC/JPY';\n    }\n\n    const market = this.market(symbol);\n    const request = this.extend({\n      'id': id,\n      'coin': market['baseId']\n    }, params);\n    const response = await this.privatePostTradeView(this.extend(request, params));\n    return this.parseOrder(response, market);\n  }\n\n  async fetchOrdersByType(type, symbol = undefined, since = undefined, limit = undefined, params = {}) {\n    await this.loadMarkets(); // a special case for btcbox â€“ default symbol is BTC/JPY\n\n    if (symbol === undefined) {\n      symbol = 'BTC/JPY';\n    }\n\n    const market = this.market(symbol);\n    const request = {\n      'type': type,\n      // 'open' or 'all'\n      'coin': market['baseId']\n    };\n    const response = await this.privatePostTradeList(this.extend(request, params));\n    const orders = this.parseOrders(response, market, since, limit); // status (open/closed/canceled) is undefined\n    // btcbox does not return status, but we know it's 'open' as we queried for open orders\n\n    if (type === 'open') {\n      for (let i = 0; i < orders.length; i++) {\n        orders[i]['status'] = 'open';\n      }\n    }\n\n    return orders;\n  }\n\n  async fetchOrders(symbol = undefined, since = undefined, limit = undefined, params = {}) {\n    return await this.fetchOrdersByType('all', symbol, since, limit, params);\n  }\n\n  async fetchOpenOrders(symbol = undefined, since = undefined, limit = undefined, params = {}) {\n    return await this.fetchOrdersByType('open', symbol, since, limit, params);\n  }\n\n  nonce() {\n    return this.milliseconds();\n  }\n\n  sign(path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {\n    let url = this.urls['api'] + '/' + this.version + '/' + path;\n\n    if (api === 'public') {\n      if (Object.keys(params).length) {\n        url += '?' + this.urlencode(params);\n      }\n    } else {\n      this.checkRequiredCredentials();\n      const nonce = this.nonce().toString();\n      const query = this.extend({\n        'key': this.apiKey,\n        'nonce': nonce\n      }, params);\n      const request = this.urlencode(query);\n      const secret = this.hash(this.encode(this.secret));\n      query['signature'] = this.hmac(this.encode(request), this.encode(secret));\n      body = this.urlencode(query);\n      headers = {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      };\n    }\n\n    return {\n      'url': url,\n      'method': method,\n      'body': body,\n      'headers': headers\n    };\n  }\n\n  handleErrors(httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {\n    if (response === undefined) {\n      return; // resort to defaultErrorHandler\n    } // typical error response: {\"result\":false,\"code\":\"401\"}\n\n\n    if (httpCode >= 400) {\n      return; // resort to defaultErrorHandler\n    }\n\n    const result = this.safeValue(response, 'result');\n\n    if (result === undefined || result === true) {\n      return; // either public API (no error codes expected) or success\n    }\n\n    const code = this.safeValue(response, 'code');\n    const feedback = this.id + ' ' + body;\n    this.throwExactlyMatchedException(this.exceptions, code, feedback);\n    throw new ExchangeError(feedback); // unknown message\n  }\n\n  async request(path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {\n    let response = await this.fetch2(path, api, method, params, headers, body);\n\n    if (typeof response === 'string') {\n      // sometimes the exchange returns whitespace prepended to json\n      response = this.strip(response);\n\n      if (!this.isJsonEncodedObject(response)) {\n        throw new ExchangeError(this.id + ' ' + response);\n      }\n\n      response = JSON.parse(response);\n    }\n\n    return response;\n  }\n\n};","map":{"version":3,"sources":["C:/Users/James Price/Documents/VS Code/bixpro/node_modules/ccxt/js/btcbox.js"],"names":["Exchange","require","ExchangeError","InsufficientFunds","InvalidOrder","AuthenticationError","PermissionDenied","InvalidNonce","OrderNotFound","DDoSProtection","Precise","module","exports","btcbox","describe","deepExtend","fetchBalance","params","loadMarkets","response","privatePostBalance","result","codes","Object","keys","currencies","i","length","code","currency","currencyId","free","account","used","safeString","parseBalance","fetchOrderBook","symbol","limit","undefined","market","request","numSymbols","symbols","publicGetDepth","extend","parseOrderBook","parseTicker","ticker","timestamp","milliseconds","last","safeNumber","iso8601","fetchTicker","publicGetTicker","parseTrade","trade","safeTimestamp","id","priceString","amountString","price","parseNumber","amount","cost","stringMul","type","side","fetchTrades","since","publicGetOrders","parseTrades","createOrder","privatePostTradeAdd","parseOrder","cancelOrder","privatePostTradeCancel","parseOrderStatus","status","statuses","order","datetimeString","parse8601","remaining","trades","safeOrder","fetchOrder","privatePostTradeView","fetchOrdersByType","privatePostTradeList","orders","parseOrders","fetchOrders","fetchOpenOrders","nonce","sign","path","api","method","headers","body","url","urls","version","urlencode","checkRequiredCredentials","toString","query","apiKey","secret","hash","encode","hmac","handleErrors","httpCode","reason","requestHeaders","requestBody","safeValue","feedback","throwExactlyMatchedException","exceptions","fetch2","strip","isJsonEncodedObject","JSON","parse"],"mappings":"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","sourcesContent":["'use strict';\n\n//  ---------------------------------------------------------------------------\n\nconst Exchange = require ('./base/Exchange');\nconst { ExchangeError, InsufficientFunds, InvalidOrder, AuthenticationError, PermissionDenied, InvalidNonce, OrderNotFound, DDoSProtection } = require ('./base/errors');\nconst Precise = require ('./base/Precise');\n\n//  ---------------------------------------------------------------------------\n\nmodule.exports = class btcbox extends Exchange {\n    describe () {\n        return this.deepExtend (super.describe (), {\n            'id': 'btcbox',\n            'name': 'BtcBox',\n            'countries': [ 'JP' ],\n            'rateLimit': 1000,\n            'version': 'v1',\n            'has': {\n                'cancelOrder': true,\n                'CORS': false,\n                'createOrder': true,\n                'fetchBalance': true,\n                'fetchOpenOrders': true,\n                'fetchOrder': true,\n                'fetchOrderBook': true,\n                'fetchOrders': true,\n                'fetchTicker': true,\n                'fetchTickers': false,\n                'fetchTrades': true,\n            },\n            'urls': {\n                'logo': 'https://user-images.githubusercontent.com/51840849/87327317-98c55400-c53c-11ea-9a11-81f7d951cc74.jpg',\n                'api': 'https://www.btcbox.co.jp/api',\n                'www': 'https://www.btcbox.co.jp/',\n                'doc': 'https://blog.btcbox.jp/en/archives/8762',\n                'fees': 'https://support.btcbox.co.jp/hc/en-us/articles/360001235694-Fees-introduction',\n            },\n            'api': {\n                'public': {\n                    'get': [\n                        'depth',\n                        'orders',\n                        'ticker',\n                    ],\n                },\n                'private': {\n                    'post': [\n                        'balance',\n                        'trade_add',\n                        'trade_cancel',\n                        'trade_list',\n                        'trade_view',\n                        'wallet',\n                    ],\n                },\n            },\n            'markets': {\n                'BTC/JPY': { 'id': 'btc', 'symbol': 'BTC/JPY', 'base': 'BTC', 'quote': 'JPY', 'baseId': 'btc', 'quoteId': 'jpy', 'taker': 0.05 / 100, 'maker': 0.05 / 100 },\n                'ETH/JPY': { 'id': 'eth', 'symbol': 'ETH/JPY', 'base': 'ETH', 'quote': 'JPY', 'baseId': 'eth', 'quoteId': 'jpy', 'taker': 0.10 / 100, 'maker': 0.10 / 100 },\n                'LTC/JPY': { 'id': 'ltc', 'symbol': 'LTC/JPY', 'base': 'LTC', 'quote': 'JPY', 'baseId': 'ltc', 'quoteId': 'jpy', 'taker': 0.10 / 100, 'maker': 0.10 / 100 },\n                'BCH/JPY': { 'id': 'bch', 'symbol': 'BCH/JPY', 'base': 'BCH', 'quote': 'JPY', 'baseId': 'bch', 'quoteId': 'jpy', 'taker': 0.10 / 100, 'maker': 0.10 / 100 },\n            },\n            'exceptions': {\n                '104': AuthenticationError,\n                '105': PermissionDenied,\n                '106': InvalidNonce,\n                '107': InvalidOrder, // price should be an integer\n                '200': InsufficientFunds,\n                '201': InvalidOrder, // amount too small\n                '202': InvalidOrder, // price should be [0 : 1000000]\n                '203': OrderNotFound,\n                '401': OrderNotFound, // cancel canceled, closed or non-existent order\n                '402': DDoSProtection,\n            },\n        });\n    }\n\n    async fetchBalance (params = {}) {\n        await this.loadMarkets ();\n        const response = await this.privatePostBalance (params);\n        const result = { 'info': response };\n        const codes = Object.keys (this.currencies);\n        for (let i = 0; i < codes.length; i++) {\n            const code = codes[i];\n            const currency = this.currency (code);\n            const currencyId = currency['id'];\n            const free = currencyId + '_balance';\n            if (free in response) {\n                const account = this.account ();\n                const used = currencyId + '_lock';\n                account['free'] = this.safeString (response, free);\n                account['used'] = this.safeString (response, used);\n                result[code] = account;\n            }\n        }\n        return this.parseBalance (result, false);\n    }\n\n    async fetchOrderBook (symbol, limit = undefined, params = {}) {\n        await this.loadMarkets ();\n        const market = this.market (symbol);\n        const request = {};\n        const numSymbols = this.symbols.length;\n        if (numSymbols > 1) {\n            request['coin'] = market['baseId'];\n        }\n        const response = await this.publicGetDepth (this.extend (request, params));\n        return this.parseOrderBook (response, symbol);\n    }\n\n    parseTicker (ticker, market = undefined) {\n        const timestamp = this.milliseconds ();\n        let symbol = undefined;\n        if (market !== undefined) {\n            symbol = market['symbol'];\n        }\n        const last = this.safeNumber (ticker, 'last');\n        return {\n            'symbol': symbol,\n            'timestamp': timestamp,\n            'datetime': this.iso8601 (timestamp),\n            'high': this.safeNumber (ticker, 'high'),\n            'low': this.safeNumber (ticker, 'low'),\n            'bid': this.safeNumber (ticker, 'buy'),\n            'bidVolume': undefined,\n            'ask': this.safeNumber (ticker, 'sell'),\n            'askVolume': undefined,\n            'vwap': undefined,\n            'open': undefined,\n            'close': last,\n            'last': last,\n            'previousClose': undefined,\n            'change': undefined,\n            'percentage': undefined,\n            'average': undefined,\n            'baseVolume': this.safeNumber (ticker, 'vol'),\n            'quoteVolume': this.safeNumber (ticker, 'volume'),\n            'info': ticker,\n        };\n    }\n\n    async fetchTicker (symbol, params = {}) {\n        await this.loadMarkets ();\n        const market = this.market (symbol);\n        const request = {};\n        const numSymbols = this.symbols.length;\n        if (numSymbols > 1) {\n            request['coin'] = market['baseId'];\n        }\n        const response = await this.publicGetTicker (this.extend (request, params));\n        return this.parseTicker (response, market);\n    }\n\n    parseTrade (trade, market = undefined) {\n        const timestamp = this.safeTimestamp (trade, 'date');\n        let symbol = undefined;\n        if (market !== undefined) {\n            symbol = market['symbol'];\n        }\n        const id = this.safeString (trade, 'tid');\n        const priceString = this.safeString (trade, 'price');\n        const amountString = this.safeString (trade, 'amount');\n        const price = this.parseNumber (priceString);\n        const amount = this.parseNumber (amountString);\n        const cost = this.parseNumber (Precise.stringMul (priceString, amountString));\n        const type = undefined;\n        const side = this.safeString (trade, 'type');\n        return {\n            'info': trade,\n            'id': id,\n            'order': undefined,\n            'timestamp': timestamp,\n            'datetime': this.iso8601 (timestamp),\n            'symbol': symbol,\n            'type': type,\n            'side': side,\n            'takerOrMaker': undefined,\n            'price': price,\n            'amount': amount,\n            'cost': cost,\n            'fee': undefined,\n        };\n    }\n\n    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {\n        await this.loadMarkets ();\n        const market = this.market (symbol);\n        const request = {};\n        const numSymbols = this.symbols.length;\n        if (numSymbols > 1) {\n            request['coin'] = market['baseId'];\n        }\n        const response = await this.publicGetOrders (this.extend (request, params));\n        return this.parseTrades (response, market, since, limit);\n    }\n\n    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {\n        await this.loadMarkets ();\n        const market = this.market (symbol);\n        const request = {\n            'amount': amount,\n            'price': price,\n            'type': side,\n            'coin': market['baseId'],\n        };\n        const response = await this.privatePostTradeAdd (this.extend (request, params));\n        //\n        //     {\n        //         \"result\":true,\n        //         \"id\":\"11\"\n        //     }\n        //\n        return this.parseOrder (response, market);\n    }\n\n    async cancelOrder (id, symbol = undefined, params = {}) {\n        await this.loadMarkets ();\n        // a special case for btcbox â€“ default symbol is BTC/JPY\n        if (symbol === undefined) {\n            symbol = 'BTC/JPY';\n        }\n        const market = this.market (symbol);\n        const request = {\n            'id': id,\n            'coin': market['baseId'],\n        };\n        const response = await this.privatePostTradeCancel (this.extend (request, params));\n        //\n        //     {\"result\":true, \"id\":\"11\"}\n        //\n        return this.parseOrder (response, market);\n    }\n\n    parseOrderStatus (status) {\n        const statuses = {\n            // TODO: complete list\n            'part': 'open', // partially or not at all executed\n            'all': 'closed', // fully executed\n            'cancelled': 'canceled',\n            'closed': 'closed', // never encountered, seems to be bug in the doc\n            'no': 'closed', // not clarified in the docs...\n        };\n        return this.safeString (statuses, status, status);\n    }\n\n    parseOrder (order, market = undefined) {\n        //\n        //     {\n        //         \"id\":11,\n        //         \"datetime\":\"2014-10-21 10:47:20\",\n        //         \"type\":\"sell\",\n        //         \"price\":42000,\n        //         \"amount_original\":1.2,\n        //         \"amount_outstanding\":1.2,\n        //         \"status\":\"closed\",\n        //         \"trades\":[]\n        //     }\n        //\n        const id = this.safeString (order, 'id');\n        const datetimeString = this.safeString (order, 'datetime');\n        let timestamp = undefined;\n        if (datetimeString !== undefined) {\n            timestamp = this.parse8601 (order['datetime'] + '+09:00'); // Tokyo time\n        }\n        const amount = this.safeNumber (order, 'amount_original');\n        const remaining = this.safeNumber (order, 'amount_outstanding');\n        const price = this.safeNumber (order, 'price');\n        // status is set by fetchOrder method only\n        let status = this.parseOrderStatus (this.safeString (order, 'status'));\n        // fetchOrders do not return status, use heuristic\n        if (status === undefined) {\n            if (remaining !== undefined && remaining === 0) {\n                status = 'closed';\n            }\n        }\n        const trades = undefined; // todo: this.parseTrades (order['trades']);\n        let symbol = undefined;\n        if (market !== undefined) {\n            symbol = market['symbol'];\n        }\n        const side = this.safeString (order, 'type');\n        return this.safeOrder ({\n            'id': id,\n            'clientOrderId': undefined,\n            'timestamp': timestamp,\n            'datetime': this.iso8601 (timestamp),\n            'lastTradeTimestamp': undefined,\n            'amount': amount,\n            'remaining': remaining,\n            'filled': undefined,\n            'side': side,\n            'type': undefined,\n            'timeInForce': undefined,\n            'postOnly': undefined,\n            'status': status,\n            'symbol': symbol,\n            'price': price,\n            'stopPrice': undefined,\n            'cost': undefined,\n            'trades': trades,\n            'fee': undefined,\n            'info': order,\n            'average': undefined,\n        });\n    }\n\n    async fetchOrder (id, symbol = undefined, params = {}) {\n        await this.loadMarkets ();\n        // a special case for btcbox â€“ default symbol is BTC/JPY\n        if (symbol === undefined) {\n            symbol = 'BTC/JPY';\n        }\n        const market = this.market (symbol);\n        const request = this.extend ({\n            'id': id,\n            'coin': market['baseId'],\n        }, params);\n        const response = await this.privatePostTradeView (this.extend (request, params));\n        return this.parseOrder (response, market);\n    }\n\n    async fetchOrdersByType (type, symbol = undefined, since = undefined, limit = undefined, params = {}) {\n        await this.loadMarkets ();\n        // a special case for btcbox â€“ default symbol is BTC/JPY\n        if (symbol === undefined) {\n            symbol = 'BTC/JPY';\n        }\n        const market = this.market (symbol);\n        const request = {\n            'type': type, // 'open' or 'all'\n            'coin': market['baseId'],\n        };\n        const response = await this.privatePostTradeList (this.extend (request, params));\n        const orders = this.parseOrders (response, market, since, limit);\n        // status (open/closed/canceled) is undefined\n        // btcbox does not return status, but we know it's 'open' as we queried for open orders\n        if (type === 'open') {\n            for (let i = 0; i < orders.length; i++) {\n                orders[i]['status'] = 'open';\n            }\n        }\n        return orders;\n    }\n\n    async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {\n        return await this.fetchOrdersByType ('all', symbol, since, limit, params);\n    }\n\n    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {\n        return await this.fetchOrdersByType ('open', symbol, since, limit, params);\n    }\n\n    nonce () {\n        return this.milliseconds ();\n    }\n\n    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {\n        let url = this.urls['api'] + '/' + this.version + '/' + path;\n        if (api === 'public') {\n            if (Object.keys (params).length) {\n                url += '?' + this.urlencode (params);\n            }\n        } else {\n            this.checkRequiredCredentials ();\n            const nonce = this.nonce ().toString ();\n            const query = this.extend ({\n                'key': this.apiKey,\n                'nonce': nonce,\n            }, params);\n            const request = this.urlencode (query);\n            const secret = this.hash (this.encode (this.secret));\n            query['signature'] = this.hmac (this.encode (request), this.encode (secret));\n            body = this.urlencode (query);\n            headers = {\n                'Content-Type': 'application/x-www-form-urlencoded',\n            };\n        }\n        return { 'url': url, 'method': method, 'body': body, 'headers': headers };\n    }\n\n    handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {\n        if (response === undefined) {\n            return; // resort to defaultErrorHandler\n        }\n        // typical error response: {\"result\":false,\"code\":\"401\"}\n        if (httpCode >= 400) {\n            return; // resort to defaultErrorHandler\n        }\n        const result = this.safeValue (response, 'result');\n        if (result === undefined || result === true) {\n            return; // either public API (no error codes expected) or success\n        }\n        const code = this.safeValue (response, 'code');\n        const feedback = this.id + ' ' + body;\n        this.throwExactlyMatchedException (this.exceptions, code, feedback);\n        throw new ExchangeError (feedback); // unknown message\n    }\n\n    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {\n        let response = await this.fetch2 (path, api, method, params, headers, body);\n        if (typeof response === 'string') {\n            // sometimes the exchange returns whitespace prepended to json\n            response = this.strip (response);\n            if (!this.isJsonEncodedObject (response)) {\n                throw new ExchangeError (this.id + ' ' + response);\n            }\n            response = JSON.parse (response);\n        }\n        return response;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}